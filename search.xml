<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Windows下使用MinGW编译boost库</title>
      <link href="/2022/04/25/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8MinGW%E7%BC%96%E8%AF%91boost%E5%BA%93/"/>
      <url>/2022/04/25/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8MinGW%E7%BC%96%E8%AF%91boost%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows下使用MinGW编译boost库"><a href="#Windows下使用MinGW编译boost库" class="headerlink" title="Windows下使用MinGW编译boost库"></a>Windows下使用MinGW编译boost库</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>​        解压并打开boost源码目录，</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call .\build.bat 改成 call .\build.bat gcc</span><br><span class="line">SET TOOLSET=msvc 改成 SET TOOLSET=gcc</span><br></pre></td></tr></tbody></table></figure><p>​        执行bootstrap.bat批处理文件，会在目录内产生一个b2.exe文件。在目录文件夹，按住shift键+鼠标右键，选择“在此处打开PowerShell窗口”（或“在此处打开控制台窗口”），执行指令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./b2.exe --help </span><br></pre></td></tr></tbody></table></figure><p>会列出关于boost的编译选项，其主要选项如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--prefix=&lt;PREFIX&gt;   编译后安装路径，默认C:\Boost</span><br><span class="line">--build-type=&lt;type&gt; 编译类型，可选minimal（最小）、complete（完整），默认minimal。</span><br><span class="line">--with-&lt;library&gt;    加入此参数，代表只编译的库。</span><br><span class="line">--without-&lt;library&gt; 加入此参数，代表忽略编译的库。</span><br><span class="line">toolset             编译器，win下默认msvc，用MinGW则选择gcc。</span><br></pre></td></tr></tbody></table></figure><p>在此编译参数可设置为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./b2.exe install --prefix=E:\boost\boost_1_76_0_mingw --build-type=complete toolset=gcc threading=multi</span><br></pre></td></tr></tbody></table></figure><p>参数解析：完整编译（会编译包含/不包含运行时库的debug/release的动态/静态库），编译器选择MinGW（gcc），多线程，编译完成后将库和头文件复制到D:\boost\boost_1.65.1_mingw路径。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>程序内存概念</title>
      <link href="/2022/04/25/%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/04/25/%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="程序内存概念"><a href="#程序内存概念" class="headerlink" title="程序内存概念"></a>程序内存概念</h1><p><strong>一 预备知识</strong></p><p>​        在区分一个程序的<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E6%A0%88&amp;spm=1001.2101.3001.7020">堆栈</a>、bss、text段、RO、RW、ZI等概念时，首先区分一下程序进程和程序文件，然后了解一下哈弗结构和冯诺依曼结构。</p><p>​        程序进程就是程序运行时的程序，程序文件是编译后生成的可执行程序，比如.bin文件等，这两个概念很好区分，特别强调一下，分开表达主要是怕读者在阅读过程中混淆了。</p><p>​        哈佛结构和冯诺依曼结构的主要区别就是处理器能不能实现取指令和取数据的并发进行。嵌入式芯片中主要是哈佛结构，PC机上是冯诺依曼结构。</p><p><strong>经典的哈佛结构</strong><br>        程序存储器和数据存储器是各自独立的存储器。处理器应该有两套总线，一套是程序存储器的数据和地址总线，一套是数据存储器的数据和地址总线。取指令和取数据能并发进行。51的程序进程的逻辑代码段放在ROM中，而变量部分则放在RAM中，取ROM中的指令和RAM中的变量是两套总线。</p><p><strong>改进型哈佛结构</strong><br>        程序存储器和数据存储器是各自独立的存储器。处理器只有一套总线，分时访问程序存储器和数据存储器，但是在处理器中有icache和dcache将程序和数据分开，所以处理器仍然可以并步执行取指令和取数据。从ARM9开始以后所有的ARM处理器内核都是改进型的哈佛结构。ARM的逻辑代码和变量都是存放在RAM中的，但是，它在内存中划分了两部分的空间，其中一部分放逻辑代码，另一部分存放变量，之间不会相互干扰。</p><p><strong>冯诺依曼结构</strong>：<br>        没有程序存储空间和数据存储空间之分。处理器只有一套总线，取指令和取数据是不能同时进行的。程序进程全部在RAM中，他们之间一般是按照代码的执行顺序依次存储。由于全部在RAM中，运行速度快，所需的RAM多。</p><p><strong>二 程序文件中的分区</strong></p><p>备注：只针对嵌入式，pc程序文件没有探究过。小标题“程序文件中的分区”其实不是很恰当，不知道该如何形容，此部分概念通常出现在一个程序编译完成后的大小统计，请自行理解。</p><p>​    相关概念：Code，RO_data，RW_data，ZI_data，RO，RW，常出现在嵌入式程序编译完成后的统计，例如MDK，IAR，ARM GCC。</p><p>有些技术文章中会直接使用RO，请注意区分RO和RO-data的区别。 </p><p><strong>Code</strong>：即代码域，它指的是编译器生成的机器指令。<br><strong>RO_data</strong>：ReadOnly data，即只读数据域，它指程序中用到的只读数据，全局变量，例如C语言中const关键字定义的全局变量就是典型的RO-data。<br><strong>RW_data</strong>：ReadWrite data，即可读写数据域，它指初始化为“非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。例如全局变量或者静态变量，且定义时赋予“非0值”给该变量进行初始化。<br><strong>ZI_data</strong>：ZeroInitialie data，即0初始化数据，它指初始化为“0值”的可读写数据域，它与RW_data的区别是程序刚运行时这些数据初始值全都为0，而后续运行过程与RW-data的性质一样，它们也常驻在RAM区，因而应用程序可以更改其内容。包括未初始化的全局变量，和初始化为0的全局变量。<br><strong>RO</strong>：只读区域，包括RO_data和code。 </p><p>当程序存储在ROM中时，所占用的大小为Code + RO_data + RW_data 。<br>当程序执行时， RW_data和 ZI_data在RAM中，RO_data和code视cpu架构（51、arm、x86）不同处于ROM或者RAM中。其中ZI_data对应了BSS段，RW_data对应数据段，code对应代码段， RO_data对应数据段。</p><p><strong>三 程序进程中的分区</strong></p><p> <strong>三 程序进程中的分区</strong>：</p><p>相关概念：堆(heap)，栈(stack)，BSS段，数据段(data)，代码段( code /text)，全局静态区，文字常量区，程序代码区。<br> <strong>BSS段</strong>：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。<br> <strong>数据段</strong>：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。<br> <strong>代码段</strong>：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。<br> <strong>堆（heap）</strong>：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。<br> **栈(stack)**：栈又称堆栈，用户存放程序临时创建的局部变量。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场。</p><p> 全局静态区，文字常量区，程序代码区是从内存地址分配的角度来描述的。<br><strong>全局区（静态区）（static）</strong>—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。</p><p><strong>文字常量区</strong>—常量字符串就是放在这里的。<br><strong>程序代码区</strong>—存放函数体的二进制代码。</p><p><img src="/2022/04/25/%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5/.%5C%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5%5Ccode_ram.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git常用指令</title>
      <link href="/2022/04/25/Git/"/>
      <url>/2022/04/25/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git常用指令"><a href="#Git常用指令" class="headerlink" title="Git常用指令"></a>Git常用指令</h1><p>[TOC]</p><table><thead><tr><th align="center">name</th><th align="center">名词</th></tr></thead><tbody><tr><td align="center">Workspace</td><td align="center">工作区</td></tr><tr><td align="center">Index / Stage</td><td align="center">暂存区</td></tr><tr><td align="center">Repository</td><td align="center">仓库区（或本地仓库）</td></tr><tr><td align="center">Remote</td><td align="center">远程仓库</td></tr></tbody></table><h3 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a><strong>一、新建代码库</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#&nbsp;在当前目录新建一个Git代码库</span><br><span class="line">$&nbsp;git&nbsp;init</span><br><span class="line">#&nbsp;新建一个目录，将其初始化为Git代码库</span><br><span class="line">$&nbsp;git&nbsp;init&nbsp;[project-name]</span><br><span class="line">#&nbsp;下载一个项目和它的整个代码历史</span><br><span class="line">$&nbsp;git&nbsp;clone&nbsp;[url]</span><br></pre></td></tr></tbody></table></figure><h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a><strong>二、配置</strong></h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#&nbsp;显示当前的Git配置</span><br><span class="line">$&nbsp;git&nbsp;config&nbsp;--list</span><br><span class="line">#&nbsp;编辑Git配置文件</span><br><span class="line">$&nbsp;git&nbsp;config&nbsp;-e&nbsp;[--global]</span><br><span class="line">#&nbsp;设置提交代码时的用户信息</span><br><span class="line">$&nbsp;git&nbsp;config&nbsp;[--global]&nbsp;user.name&nbsp;"[name]"</span><br><span class="line">$&nbsp;git&nbsp;config&nbsp;[--global]&nbsp;user.email&nbsp;"[email&nbsp;address]"</span><br><span class="line">#&nbsp;颜色设置</span><br><span class="line">git&nbsp;config&nbsp;--global&nbsp;color.ui&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;git&nbsp;status等命令自动着色</span><br><span class="line">git&nbsp;config&nbsp;--global&nbsp;color.status&nbsp;auto</span><br><span class="line">git&nbsp;config&nbsp;--global&nbsp;color.diff&nbsp;auto</span><br><span class="line">git&nbsp;config&nbsp;--global&nbsp;color.branch&nbsp;auto</span><br><span class="line">git&nbsp;config&nbsp;--global&nbsp;color.interactive&nbsp;auto</span><br><span class="line">git&nbsp;config&nbsp;--global&nbsp;--unset&nbsp;http.proxy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;remove&nbsp;&nbsp;proxy&nbsp;configuration&nbsp;on&nbsp;git</span><br><span class="line">git config user.name // 查看git用户名</span><br><span class="line">git config user.password //查看git密码</span><br><span class="line">git config user.email // 查看git邮箱地址</span><br><span class="line">git config --global user.name "xxxx(新的用户名)" // 修改git用户名</span><br><span class="line">git config --global user.password "xxxx(新的密码)" // 修改git密码</span><br><span class="line">git config --global user.email "xxxx@xxx.com(新的邮箱)" // 修改git邮箱</span><br></pre></td></tr></tbody></table></figure><h3 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#&nbsp;添加指定文件到暂存区</span><br><span class="line">$&nbsp;git&nbsp;add&nbsp;[file1]&nbsp;[file2]&nbsp;...</span><br><span class="line">#&nbsp;添加指定目录到暂存区，包括子目录</span><br><span class="line">$&nbsp;git&nbsp;add&nbsp;[dir]</span><br><span class="line">#&nbsp;添加当前目录的所有文件到暂存区</span><br><span class="line">$&nbsp;git&nbsp;add&nbsp;.</span><br><span class="line">#&nbsp;添加每个变化前，都会要求确认</span><br><span class="line">#&nbsp;对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$&nbsp;git&nbsp;add&nbsp;-p</span><br><span class="line">#&nbsp;删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$&nbsp;git&nbsp;rm&nbsp;[file1]&nbsp;[file2]&nbsp;...</span><br><span class="line">#&nbsp;停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$&nbsp;git&nbsp;rm&nbsp;--cached&nbsp;[file]</span><br><span class="line">#&nbsp;改名文件，并且将这个改名放入暂存区</span><br><span class="line">$&nbsp;git&nbsp;mv&nbsp;[file-original]&nbsp;[file-renamed]</span><br></pre></td></tr></tbody></table></figure><h3 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a><strong>四、代码提交</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#&nbsp;提交暂存区到仓库区</span><br><span class="line">$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;[message]</span><br><span class="line">#&nbsp;提交暂存区的指定文件到仓库区</span><br><span class="line">$&nbsp;git&nbsp;commit&nbsp;[file1]&nbsp;[file2]&nbsp;...&nbsp;-m&nbsp;[message]</span><br><span class="line">#&nbsp;提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$&nbsp;git&nbsp;commit&nbsp;-a</span><br><span class="line">#&nbsp;提交时显示所有diff信息</span><br><span class="line">$&nbsp;git&nbsp;commit&nbsp;-v</span><br><span class="line">#&nbsp;将add和commit合为一步</span><br><span class="line">$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'message'</span><br><span class="line">#&nbsp;使用一次新的commit，替代上一次提交</span><br><span class="line">#&nbsp;如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$&nbsp;git&nbsp;commit&nbsp;--amend&nbsp;-m&nbsp;[message]</span><br><span class="line">#&nbsp;重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$&nbsp;git&nbsp;commit&nbsp;--amend&nbsp;[file1]&nbsp;[file2]&nbsp;...</span><br></pre></td></tr></tbody></table></figure><h3 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a><strong>五、分支</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#&nbsp;列出所有本地分支</span><br><span class="line">$&nbsp;git&nbsp;branch</span><br><span class="line">#&nbsp;列出所有远程分支</span><br><span class="line">$&nbsp;git&nbsp;branch&nbsp;-r</span><br><span class="line">#&nbsp;列出所有本地分支和远程分支</span><br><span class="line">$&nbsp;git&nbsp;branch&nbsp;-a</span><br><span class="line">#&nbsp;新建一个分支，但依然停留在当前分支</span><br><span class="line">$&nbsp;git&nbsp;branch&nbsp;[branch-name]</span><br><span class="line">#&nbsp;新建一个分支，并切换到该分支</span><br><span class="line">$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;[branch]</span><br><span class="line">#&nbsp;新建一个分支，指向指定commit</span><br><span class="line">$&nbsp;git&nbsp;branch&nbsp;[branch]&nbsp;[commit]</span><br><span class="line">#&nbsp;新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$&nbsp;git&nbsp;branch&nbsp;--track&nbsp;[branch]&nbsp;[remote-branch]</span><br><span class="line">#&nbsp;切换到指定分支，并更新工作区</span><br><span class="line">$&nbsp;git&nbsp;checkout&nbsp;[branch-name]</span><br><span class="line">#&nbsp;切换到上一个分支</span><br><span class="line">$&nbsp;git&nbsp;checkout&nbsp;-</span><br><span class="line">#&nbsp;建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$&nbsp;git&nbsp;branch&nbsp;--set-upstream&nbsp;[branch]&nbsp;[remote-branch]</span><br><span class="line">#&nbsp;合并指定分支到当前分支</span><br><span class="line">$&nbsp;git&nbsp;merge&nbsp;[branch]</span><br><span class="line">#&nbsp;选择一个commit，合并进当前分支</span><br><span class="line">$&nbsp;git&nbsp;cherry-pick&nbsp;[commit]</span><br><span class="line">#&nbsp;删除分支</span><br><span class="line">$&nbsp;git&nbsp;branch&nbsp;-d&nbsp;[branch-name]</span><br><span class="line">#&nbsp;删除远程分支</span><br><span class="line">$&nbsp;git&nbsp;push&nbsp;origin&nbsp;--delete&nbsp;[branch-name]</span><br><span class="line">$&nbsp;git&nbsp;branch&nbsp;-dr&nbsp;[remote/branch]</span><br><span class="line">#&nbsp;检出版本v2.0</span><br><span class="line">$&nbsp;git&nbsp;checkout&nbsp;v2.0</span><br><span class="line">#&nbsp;从远程分支develop创建新本地分支devel并检出</span><br><span class="line">$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;devel&nbsp;origin/develop</span><br><span class="line">#&nbsp;检出head版本的README文件（可用于修改错误回退）</span><br><span class="line">git&nbsp;checkout&nbsp;--&nbsp;README </span><br></pre></td></tr></tbody></table></figure><h3 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#&nbsp;列出所有tag</span><br><span class="line">$&nbsp;git&nbsp;tag</span><br><span class="line">#&nbsp;新建一个tag在当前commit</span><br><span class="line">$&nbsp;git&nbsp;tag&nbsp;[tag]</span><br><span class="line">#&nbsp;新建一个tag在指定commit</span><br><span class="line">$&nbsp;git&nbsp;tag&nbsp;[tag]&nbsp;[commit]</span><br><span class="line">#&nbsp;删除本地tag</span><br><span class="line">$&nbsp;git&nbsp;tag&nbsp;-d&nbsp;[tag]</span><br><span class="line">#&nbsp;删除远程tag</span><br><span class="line">$&nbsp;git&nbsp;push&nbsp;origin&nbsp;:refs/tags/[tagName]</span><br><span class="line">#&nbsp;查看tag信息</span><br><span class="line">$&nbsp;git&nbsp;show&nbsp;[tag]</span><br><span class="line">#&nbsp;提交指定tag</span><br><span class="line">$&nbsp;git&nbsp;push&nbsp;[remote]&nbsp;[tag]</span><br><span class="line">#&nbsp;提交所有tag</span><br><span class="line">$&nbsp;git&nbsp;push&nbsp;[remote]&nbsp;--tags</span><br><span class="line">#&nbsp;新建一个分支，指向某个tag</span><br><span class="line">$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;[branch]&nbsp;[tag]</span><br></pre></td></tr></tbody></table></figure><h3 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#&nbsp;显示有变更的文件</span><br><span class="line">$&nbsp;git&nbsp;status</span><br><span class="line">#&nbsp;显示当前分支的版本历史</span><br><span class="line">$&nbsp;git&nbsp;log</span><br><span class="line">#&nbsp;显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$&nbsp;git&nbsp;log&nbsp;--stat</span><br><span class="line">#&nbsp;搜索提交历史，根据关键词</span><br><span class="line">$&nbsp;git&nbsp;log&nbsp;-S&nbsp;[keyword]</span><br><span class="line">#&nbsp;显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$&nbsp;git&nbsp;log&nbsp;[tag]&nbsp;HEAD&nbsp;--pretty=format:%s</span><br><span class="line">#&nbsp;显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span><br><span class="line">$&nbsp;git&nbsp;log&nbsp;[tag]&nbsp;HEAD&nbsp;--grep&nbsp;feature</span><br><span class="line">#&nbsp;显示某个文件的版本历史，包括文件改名</span><br><span class="line">$&nbsp;git&nbsp;log&nbsp;--follow&nbsp;[file]</span><br><span class="line">$&nbsp;git&nbsp;whatchanged&nbsp;[file]</span><br><span class="line">#&nbsp;显示指定文件相关的每一次diff</span><br><span class="line">$&nbsp;git&nbsp;log&nbsp;-p&nbsp;[file]</span><br><span class="line">#&nbsp;显示过去5次提交</span><br><span class="line">$&nbsp;git&nbsp;log&nbsp;-5&nbsp;--pretty&nbsp;--oneline</span><br><span class="line">#&nbsp;显示所有提交过的用户，按提交次数排序</span><br><span class="line">$&nbsp;git&nbsp;shortlog&nbsp;-sn</span><br><span class="line">#&nbsp;显示指定文件是什么人在什么时间修改过</span><br><span class="line">$&nbsp;git&nbsp;blame&nbsp;[file]</span><br><span class="line">#&nbsp;显示暂存区和工作区的差异</span><br><span class="line">$&nbsp;git&nbsp;diff</span><br><span class="line">#&nbsp;显示暂存区和上一个commit的差异</span><br><span class="line">$&nbsp;git&nbsp;diff&nbsp;--cached&nbsp;[file]</span><br><span class="line">#&nbsp;显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$&nbsp;git&nbsp;diff&nbsp;HEAD</span><br><span class="line">#&nbsp;显示两次提交之间的差异</span><br><span class="line">$&nbsp;git&nbsp;diff&nbsp;[first-branch]...[second-branch]</span><br><span class="line">#&nbsp;显示今天你写了多少行代码</span><br><span class="line">$&nbsp;git&nbsp;diff&nbsp;--shortstat&nbsp;"@{0&nbsp;day&nbsp;ago}"</span><br><span class="line">#&nbsp;显示某次提交的元数据和内容变化</span><br><span class="line">$&nbsp;git&nbsp;show&nbsp;[commit]</span><br><span class="line">#&nbsp;显示某次提交发生变化的文件</span><br><span class="line">$&nbsp;git&nbsp;show&nbsp;--name-only&nbsp;[commit]</span><br><span class="line">#&nbsp;显示某次提交时，某个文件的内容</span><br><span class="line">$&nbsp;git&nbsp;show&nbsp;[commit]:[filename]</span><br><span class="line">#&nbsp;显示当前分支的最近几次提交</span><br><span class="line">$&nbsp;git&nbsp;reflog</span><br></pre></td></tr></tbody></table></figure><h3 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a><strong>八、远程同步</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#&nbsp;下载远程仓库的所有变动</span><br><span class="line">$&nbsp;git&nbsp;fetch&nbsp;[remote]</span><br><span class="line">#&nbsp;显示所有远程仓库</span><br><span class="line">$&nbsp;git&nbsp;remote&nbsp;-v</span><br><span class="line">#&nbsp;显示某个远程仓库的信息</span><br><span class="line">$&nbsp;git&nbsp;remote&nbsp;show&nbsp;[remote]</span><br><span class="line">#&nbsp;增加一个新的远程仓库，并命名</span><br><span class="line">$&nbsp;git&nbsp;remote&nbsp;add&nbsp;[shortname]&nbsp;[url]</span><br><span class="line">#&nbsp;取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$&nbsp;git&nbsp;pull&nbsp;[remote]&nbsp;[branch]</span><br><span class="line">#&nbsp;上传本地指定分支到远程仓库</span><br><span class="line">$&nbsp;git&nbsp;push&nbsp;[remote]&nbsp;[branch]</span><br><span class="line">#&nbsp;强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$&nbsp;git&nbsp;push&nbsp;[remote]&nbsp;--force</span><br><span class="line">#&nbsp;推送所有分支到远程仓库</span><br><span class="line">$&nbsp;git&nbsp;push&nbsp;[remote]&nbsp;--all</span><br></pre></td></tr></tbody></table></figure><h3 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a><strong>九、撤销</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#&nbsp;恢复暂存区的指定文件到工作区</span><br><span class="line">$&nbsp;git&nbsp;checkout&nbsp;[file]</span><br><span class="line">#&nbsp;恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$&nbsp;git&nbsp;checkout&nbsp;[commit]&nbsp;[file]</span><br><span class="line">#&nbsp;恢复暂存区的所有文件到工作区</span><br><span class="line">$&nbsp;git&nbsp;checkout&nbsp;.</span><br><span class="line">#&nbsp;重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$&nbsp;git&nbsp;reset&nbsp;[file]</span><br><span class="line">#&nbsp;重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$&nbsp;git&nbsp;reset&nbsp;--hard</span><br><span class="line">#&nbsp;重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$&nbsp;git&nbsp;reset&nbsp;[commit]</span><br><span class="line">#&nbsp;重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$&nbsp;git&nbsp;reset&nbsp;--hard&nbsp;[commit]</span><br><span class="line">#&nbsp;重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$&nbsp;git&nbsp;reset&nbsp;--keep&nbsp;[commit]</span><br><span class="line">#&nbsp;新建一个commit，用来撤销指定commit</span><br><span class="line">#&nbsp;后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$&nbsp;git&nbsp;revert&nbsp;[commit]</span><br><span class="line">#&nbsp;暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$&nbsp;git&nbsp;stash</span><br><span class="line">$&nbsp;git&nbsp;stash&nbsp;pop</span><br></pre></td></tr></tbody></table></figure><h3 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">git&nbsp;init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;初始化本地git仓库（创建新仓库）</span><br><span class="line">git&nbsp;config&nbsp;--global&nbsp;user.name&nbsp;"xxx"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;配置用户名</span><br><span class="line">git&nbsp;config&nbsp;--global&nbsp;user.email&nbsp;"xxx@xxx.com"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;配置邮件</span><br><span class="line">git&nbsp;config&nbsp;--global&nbsp;color.ui&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;git&nbsp;status等命令自动着色</span><br><span class="line">git&nbsp;config&nbsp;--global&nbsp;color.status&nbsp;auto</span><br><span class="line">git&nbsp;config&nbsp;--global&nbsp;color.diff&nbsp;auto</span><br><span class="line">git&nbsp;config&nbsp;--global&nbsp;color.branch&nbsp;auto</span><br><span class="line">git&nbsp;config&nbsp;--global&nbsp;color.interactive&nbsp;auto</span><br><span class="line">git&nbsp;config&nbsp;--global&nbsp;--unset&nbsp;http.proxy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;remove&nbsp;&nbsp;proxy&nbsp;configuration&nbsp;on&nbsp;git</span><br><span class="line">git&nbsp;clone&nbsp;git+ssh://git@192.168.53.168/VT.git&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;clone远程仓库</span><br><span class="line">git&nbsp;status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看当前版本状态（是否修改）</span><br><span class="line">git&nbsp;add&nbsp;xyz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;添加xyz文件至index</span><br><span class="line">git&nbsp;add&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;增加当前子目录下所有更改过的文件至index</span><br><span class="line">git&nbsp;commit&nbsp;-m&nbsp;'xxx'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;提交</span><br><span class="line">git&nbsp;commit&nbsp;--amend&nbsp;-m&nbsp;'xxx'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;合并上一次提交（用于反复修改）</span><br><span class="line">git&nbsp;commit&nbsp;-am&nbsp;'xxx'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;将add和commit合为一步</span><br><span class="line">git&nbsp;rm&nbsp;xxx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;删除index中的文件</span><br><span class="line">git&nbsp;rm&nbsp;-r&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;递归删除</span><br><span class="line">git&nbsp;log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示提交日志</span><br><span class="line">git&nbsp;log&nbsp;-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示1行日志&nbsp;-n为n行</span><br><span class="line">git&nbsp;log&nbsp;-5</span><br><span class="line">git&nbsp;log&nbsp;--stat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示提交日志及相关变动文件</span><br><span class="line">git&nbsp;log&nbsp;-p&nbsp;-m</span><br><span class="line">git&nbsp;show&nbsp;dfb02e6e4f2f7b573337763e5c0013802e392818&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示某个提交的详细内容</span><br><span class="line">git&nbsp;show&nbsp;dfb02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;可只用commitid的前几位</span><br><span class="line">git&nbsp;show&nbsp;HEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示HEAD提交日志</span><br><span class="line">git&nbsp;show&nbsp;HEAD^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示HEAD的父（上一个版本）的提交日志&nbsp;^^为上两个版本&nbsp;^5为上5个版本</span><br><span class="line">git&nbsp;tag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示已存在的tag</span><br><span class="line">git&nbsp;tag&nbsp;-a&nbsp;v2.0&nbsp;-m&nbsp;'xxx'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;增加v2.0的tag</span><br><span class="line">git&nbsp;show&nbsp;v2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示v2.0的日志及详细内容</span><br><span class="line">git&nbsp;log&nbsp;v2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示v2.0的日志</span><br><span class="line">git&nbsp;diff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有未添加至index的变更</span><br><span class="line">git&nbsp;diff&nbsp;--cached&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有已添加index但还未commit的变更</span><br><span class="line">git&nbsp;diff&nbsp;HEAD^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;比较与上一个版本的差异</span><br><span class="line">git&nbsp;diff&nbsp;HEAD&nbsp;--&nbsp;./lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;比较与HEAD版本lib目录的差异</span><br><span class="line">git&nbsp;diff&nbsp;origin/master..master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;比较远程分支master上有本地分支master上没有的</span><br><span class="line">git&nbsp;diff&nbsp;origin/master..master&nbsp;--stat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;只显示差异的文件，不显示具体内容</span><br><span class="line">git&nbsp;remote&nbsp;add&nbsp;origin&nbsp;git+ssh://git@192.168.53.168/VT.git&nbsp;#&nbsp;增加远程定义（用于push/pull/fetch）</span><br><span class="line">git&nbsp;branch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示本地分支</span><br><span class="line">git&nbsp;branch&nbsp;--contains&nbsp;50089&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示包含提交50089的分支</span><br><span class="line">git&nbsp;branch&nbsp;-a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有分支</span><br><span class="line">git&nbsp;branch&nbsp;-r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有原创分支</span><br><span class="line">git&nbsp;branch&nbsp;--merged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有已合并到当前分支的分支</span><br><span class="line">git&nbsp;branch&nbsp;--no-merged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有未合并到当前分支的分支</span><br><span class="line">git&nbsp;branch&nbsp;-m&nbsp;master&nbsp;master_copy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;本地分支改名</span><br><span class="line">git&nbsp;checkout&nbsp;-b&nbsp;master_copy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;从当前分支创建新分支master_copy并检出</span><br><span class="line">git&nbsp;checkout&nbsp;-b&nbsp;master&nbsp;master_copy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;上面的完整版</span><br><span class="line">git&nbsp;checkout&nbsp;features/performance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;检出已存在的features/performance分支</span><br><span class="line">git&nbsp;checkout&nbsp;--track&nbsp;hotfixes/BJVEP933&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span><br><span class="line">git&nbsp;checkout&nbsp;v2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;检出版本v2.0</span><br><span class="line">git&nbsp;checkout&nbsp;-b&nbsp;devel&nbsp;origin/develop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;从远程分支develop创建新本地分支devel并检出</span><br><span class="line">git&nbsp;checkout&nbsp;--&nbsp;README&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;检出head版本的README文件（可用于修改错误回退）</span><br><span class="line">git&nbsp;merge&nbsp;origin/master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;合并远程master分支至当前分支</span><br><span class="line">git&nbsp;cherry-pick&nbsp;ff44785404a8e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;合并提交ff44785404a8e的修改</span><br><span class="line">git&nbsp;push&nbsp;origin&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;将当前分支push到远程master分支</span><br><span class="line">git&nbsp;push&nbsp;origin&nbsp;:hotfixes/BJVEP933&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;删除远程仓库的hotfixes/BJVEP933分支</span><br><span class="line">git&nbsp;push&nbsp;--tags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;把所有tag推送到远程仓库</span><br><span class="line">git&nbsp;fetch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;获取所有远程分支（不更新本地分支，另需merge）</span><br><span class="line">git&nbsp;fetch&nbsp;--prune&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;获取所有原创分支并清除服务器上已删掉的分支</span><br><span class="line">git&nbsp;pull&nbsp;origin&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;获取远程分支master并merge到当前分支</span><br><span class="line">git&nbsp;mv&nbsp;README&nbsp;README2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;重命名文件README为README2</span><br><span class="line">git&nbsp;reset&nbsp;--hard&nbsp;HEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;将当前版本重置为HEAD（通常用于merge失败回退）</span><br><span class="line">git&nbsp;rebase</span><br><span class="line">git&nbsp;branch&nbsp;-d&nbsp;hotfixes/BJVEP933&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</span><br><span class="line">git&nbsp;branch&nbsp;-D&nbsp;hotfixes/BJVEP933&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;强制删除分支hotfixes/BJVEP933</span><br><span class="line">git&nbsp;ls-files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;列出git&nbsp;index包含的文件</span><br><span class="line">git&nbsp;show-branch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;图示当前分支历史</span><br><span class="line">git&nbsp;show-branch&nbsp;--all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;图示所有分支历史</span><br><span class="line">git&nbsp;whatchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示提交历史对应的文件修改</span><br><span class="line">git&nbsp;revert&nbsp;dfb02e6e4f2f7b573337763e5c0013802e392818&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span><br><span class="line">git&nbsp;ls-tree&nbsp;HEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;内部命令：显示某个git对象</span><br><span class="line">git&nbsp;rev-parse&nbsp;v2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;内部命令：显示某个ref对于的SHA1 HASH</span><br><span class="line">git&nbsp;reflog&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有提交，包括孤立节点</span><br><span class="line">git&nbsp;show&nbsp;HEAD@{5}</span><br><span class="line">git&nbsp;show&nbsp;master@{yesterday}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示master分支昨天的状态</span><br><span class="line">git&nbsp;log&nbsp;--pretty=format:'%h&nbsp;%s'&nbsp;--graph&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;图示提交日志</span><br><span class="line">git&nbsp;show&nbsp;HEAD~3</span><br><span class="line">git&nbsp;show&nbsp;-s&nbsp;--pretty=raw&nbsp;2be7fcb476</span><br><span class="line">git&nbsp;stash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;暂存当前修改，将所有至为HEAD状态</span><br><span class="line">git&nbsp;stash&nbsp;list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看所有暂存</span><br><span class="line">git&nbsp;stash&nbsp;show&nbsp;-p&nbsp;stash@{0}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;参考第一次暂存</span><br><span class="line">git&nbsp;stash&nbsp;apply&nbsp;stash@{0}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;应用第一次暂存</span><br><span class="line">git&nbsp;grep&nbsp;"delete&nbsp;from"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;文件中搜索文本“delete&nbsp;from”</span><br><span class="line">git&nbsp;grep&nbsp;-e&nbsp;'#define'&nbsp;--and&nbsp;-e&nbsp;SORT_DIRENT</span><br><span class="line">git&nbsp;gc</span><br><span class="line">git&nbsp;fsck</span><br><span class="line">#&nbsp;生成一个可供发布的压缩包</span><br><span class="line">$&nbsp;git&nbsp;archive</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>开源许可协议 GNU GPL</title>
      <link href="/2022/04/24/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE-GNU-GPL/"/>
      <url>/2022/04/24/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE-GNU-GPL/</url>
      
        <content type="html"><![CDATA[<h1 id="开源许可协议-GNU-GPL"><a href="#开源许可协议-GNU-GPL" class="headerlink" title="开源许可协议 | GNU GPL"></a>开源许可协议 | GNU GPL</h1><p>[TOC]</p><p>​        在开源领域中，许可协议是指开源社区为了维护作者和贡献者的合法权利，保证软件不被一些商业机构或个人窃取，影响软件的发展而开发的协议。其中，GPL是开源许可协议中非常流行的许可协议之一。</p><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a><strong>一、基本概念</strong></h2><p><img src="/2022/04/24/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE-GNU-GPL/GPL.png"></p><p>​                                                                   GPL标志</p><p>​        GNU通用公共许可协议（英语：GNU General Public License，缩写GNU GPL 或 GPL），GPL是由理查德·斯托曼于1989年编写，最初提供给列入GNU项目的一些软件程序所使用。</p><p>​        GPL是自由软件和开源软件的最流行许可证。到2004年4月，GPL已占Freshmeat上所列的自由软件的约75%，SourceForge的约68%。类似的，2001年一项关于Red Hat Linux 7.1的调查显示一般的代码都以GPL发布。</p><h2 id="二、协议特点"><a href="#二、协议特点" class="headerlink" title="二、协议特点"></a><strong>二、协议特点</strong></h2><h3 id="2-1-传染性"><a href="#2-1-传染性" class="headerlink" title="2.1 传染性"></a><strong>2.1 传染性</strong></h3><p>​        GPL协议具有一个很显著的特点“传染性” ：即当具有GPL协议的软件与其它协议的软件相组合或者GPL的衍生产品，必须按照GPL的条款分发。“衍生产品”通常被解释为包含GPL代码或动态链接到GPL库的软件。GPL下所有衍生产品都必须属于GPL，许可证是根据著作权法运行的。</p><h3 id="2-2-可商用"><a href="#2-2-可商用" class="headerlink" title="2.2 可商用"></a><strong>2.2 可商用</strong></h3><p>​        GPL软件可以用于盈利，可以以任何价格出售，可以作为创建专有软件的工具（例如：GPL协议的编译器）。</p><h2 id="三、使用者的自由"><a href="#三、使用者的自由" class="headerlink" title="三、使用者的自由"></a><strong>三、使用者的自由</strong></h2><h3 id="1-自由运行"><a href="#1-自由运行" class="headerlink" title="1. 自由运行"></a><strong>1. 自由运行</strong></h3><p>​    可以按照自己的意愿运行软件；</p><h3 id="2-自由修改"><a href="#2-自由修改" class="headerlink" title="2. 自由修改"></a><strong>2. 自由修改</strong></h3><p>可以按己的意愿修改软件；</p><h3 id="3-自由复制"><a href="#3-自由复制" class="headerlink" title="3. 自由复制"></a><strong>3. 自由复制</strong></h3><p>可以自由分发软件副本；</p><h3 id="4-自由分发"><a href="#4-自由分发" class="headerlink" title="4. 自由分发"></a><strong>4. 自由分发</strong></h3><p>可以将你修改过的软件版本再分发给其他人，从而回馈开源，促进开源；</p><h2 id="四、符合GPL协议的软件"><a href="#四、符合GPL协议的软件" class="headerlink" title="四、符合GPL协议的软件"></a><strong>四、符合GPL协议的软件</strong></h2><p>著名的GPL自由软件包括EMACS，Linux内核（并非所有Linux发行版的内核都是开源的）和<a href="https://so.csdn.net/so/search?q=GCC&amp;spm=1001.2101.3001.7020">GCC</a>。</p><h2 id="五、GPL发展阶段"><a href="#五、GPL发展阶段" class="headerlink" title="五、GPL发展阶段"></a><strong>五、GPL发展阶段</strong></h2><p><strong>GPLv1：</strong>解决了软件经销商只分发软件的二进制，而不提供软件源码的问题；要求符合GPL的软件与其它软件组合后的整体必须以GPLv1条款分发，限制了经销商增加许可证的限制；</p><p><strong>GPLv2：</strong>规定被许可人只有在满足所有许可证的义务下才可以分发包含GPL许可的软件，就算有相互矛盾的义务，许可证的义务也可能不被切断，阻止任何一方使用专利侵权索赔或其他诉讼来损害用户在许可证下的自由；</p><p>**GPLv3提高了与许多开放源代码软件许可证（如Apache许可证版本2.0）和GNU Affero通用公共许可证（GPLv2无法组合）的兼容性；比较有意思的是，林纳斯·托瓦兹（Linux内核的发明人及该计划的合作者）决定不采用GPLv3作为Linux内核的许可协议，仍然使用GPLv2许可。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>GPL 维护了代码所有者的合法权益，保证了代码以及其衍生产品的开源，从而促进了代码的开源，让众多的软件开发者不断地从中收益，同时也不断的回馈开源社区，让开源队伍越来越壮大！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>几种常见的开源协议介绍</title>
      <link href="/2022/04/24/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/04/24/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="开源协议介绍"><a href="#开源协议介绍" class="headerlink" title="开源协议介绍"></a>开源协议介绍</h1><p>[TOC]</p><h2 id="一、几种常见的开源协议介绍"><a href="#一、几种常见的开源协议介绍" class="headerlink" title="一、几种常见的开源协议介绍"></a>一、几种常见的开源协议介绍</h2><p>常用的几种开源协议：</p><ul><li><p><strong>GPL （GNU General Public License） ：GNU通用公共许可协议</strong></p></li><li><p><strong>LGPL （GNU Lesser General Public License） ：GNU宽通用公共许可协议</strong></p></li><li><p><strong>BSD (Berkeley Software Distribution) :伯克利软件分发许可协议</strong></p></li><li><p><strong>MIT （Massachusetts Institute of Technology）：MIT许可协议之名源自麻省理工学院，又称“X许可协议”或“X11许可协议”</strong></p></li><li><p><strong>Apache （Apache License） ：Apache许可协议</strong></p></li><li><p><strong>MPL （Mozilla Public License） ：Mozilla公共许可协议</strong></p></li></ul><h3 id="1-BSD协议"><a href="#1-BSD协议" class="headerlink" title="1.BSD协议"></a>1.BSD协议</h3><p>​        BSD开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。但前提是发布使用了BSD协议的代码，或以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： </p><ul><li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li><li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 </li></ul><p>​        BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p><h3 id="2-MIT协议"><a href="#2-MIT协议" class="headerlink" title="2.MIT协议"></a>2.MIT协议</h3><p>​        MIT是和BSD一样宽范的许可协议，源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称X11协议。作者只想保留版权,而无任何其他了限制。MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。<br>​        MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。 </p><ul><li>被授权人有权利使用、复制、修改、合并、出版发行、散布、再授权及贩售软件及软件的副本。</li><li>被授权人可根据程序的需要修改授权条款为适当的内容。</li><li>在软件和软件的所有副本中都必须包含版权声明和许可声明。 </li></ul><p>​        此授权条款并非属copyleft的自由软件授权条款，允许在自由/开放源码软件或非自由软件（proprietary software）所使用。MIT的内容可依照程序著作权者的需求更改内容。此亦为MIT与BSD（The BSD license, 3-clause BSD license）本质上不同处。MIT条款可与其他授权条款并存。另外，MIT条款也是自由软件基金会（FSF）所认可的自由软件授权条款，与GPL兼容。</p><h3 id="3-Apache-协议"><a href="#3-Apache-协议" class="headerlink" title="3.Apache 协议"></a>3.Apache 协议</h3><p>​        Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件： </p><ol><li>需要给代码的用户一份Apache Licence。</li><li>如果修改了代码，需要再被修改的文件中说明。</li><li>在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li><li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。 </li></ol><p>使用这个协议的好处是: </p><ol><li>永久权利：一旦被授权，永久拥有。</li><li>全球范围的权利：在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。</li><li>授权免费：无版税， 前期、后期均无任何费用。</li><li>授权无排他性：任何人都可以获得授权</li><li>授权不可撤消 一旦获得授权，没有任何人可以取消。 </li></ol><p>Apache Licence也是对商业应用友好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。</p><h3 id="4-GPL协议"><a href="#4-GPL协议" class="headerlink" title="4.GPL协议"></a>4.GPL协议</h3><p>GPL（ GNU General Public Licence ）的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。Linux就是采用了GPL协议。</p><ol><li>可自由复制：你可以将软件复制到你的电脑，你客户的电脑，或者任何地方。复制份数没有任何限制。</li><li>可自由分发：在你的网站提供下载，拷贝到U盘送人，或者将源代码打印出来从窗户扔出去（环保起见，请别这样做）。</li><li>可以用来盈利：你可以在分发软件的时候收费，但你必须在收费前向你的客户提供该软件的 GNU GPL 许可协议，以便让他们知道，他们可以从别的渠道免费得到这份软件，以及你收费的理由。</li><li>可自由修改：如果你想添加或删除某个功能，没问题，如果你想在别的项目中使用部分代码，也没问题，唯一的要求是，使用了这段代码的项目也必须使用 GPL 协议。 </li></ol><p>还有一些要求 </p><ol><li>如果你使用了GPL协议的开源代码，将此开源代码用在了你的软件产品里，那么，你的整个软件产品必须开源，而且必须以GPL协议开源。</li><li>如果软件以GPL协议开源，那么源代码必须是面向社会开源的。而且你发布产品的时候源代码也必须一同附上。</li><li>如果软件以GPL协议开源，那么你可以对该软件收取一定的服务费用，但你永远不能对该软件的源代码收费。</li></ol><p>5.LGPL协议<br>        LGPL 是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并 发布和销售。 </p><p>​        但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因 此LGPL协议的开源 代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。 </p><p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p><h3 id="6-MPL"><a href="#6-MPL" class="headerlink" title="6.MPL"></a><strong>6.MPL</strong></h3><p>​        MPL既是得到自由软件基金会承认的自由软件许可证，也是得到开放源代码促进会承认的开源软件许可证。MPL允许在其授权下的源代码与其他授权的文件进行混合，包括私有许可证。但在MPL授权下的代码文件必须保持MPL授权，并且保持开源。这样的条款让MPL既不像MIT和BSD那样允许派生作品完全转化为私有，也不像GPL那样要求所有的派生作品，包括新的组件在内，全部必须保持GPL。通过允许在派生项目中存在私有模块，同时保证核心文件的开源，MPL同时激励了商业及开源社区来参与帮助开发核心软件。</p><p>​        使用MPL授权的软件并不受专利的限制，其可以自由使用，修改，并可自由的重新发布。带有专利代码的版本仍然可以使用，转让，甚至出售，但未经许可则不能修改代码。此外，MPL并不授予用户对于开发者商标的使用权。</p><p>​        为了满足MPL的条款限制，用户必须负担一些“责任”，主要是关于散发使用MPL授权的软件。用户必须确保重新散发的软件所有源代码均以MPL授权，即使是以可执行文件的方式提供或是与其他使用专有软件授权的源代码结合也一样。但若跟以GNU通用公共许可协议、GNU宽通用公共许可证、Affero通用公共许可证授权的源代码结合则是例外。此时开发者则可选用以上三种更加严格的条款来授权。</p><h2 id="二、开源协议选择"><a href="#二、开源协议选择" class="headerlink" title="二、开源协议选择"></a>二、开源协议选择</h2><p>按照使用条件的不同，开源软件许可证可以分为三类（严苛程度递减）。 </p><p>第一类使用该开源软件的代码再散布（redistribute）时，源码也必须以相同许可证公开。代表许可类型 GPL，AGPL。 </p><p>第二类使用该开源软件的代码并且对开源代码有所修改后再散布时，源码必须以相同许可证公开。如LGPL，CPL，CDDL，CPL，MPL等。 </p><p>第三类用该开源软件的代码（包括修改）再散布（redistribute）时，没有特殊限制，只需要明记许可。如ASL，BSD，MIT等。</p><p><img src="/2022/04/24/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GCC常用编译选项</title>
      <link href="/2022/04/24/GCC%E5%B8%B8%E7%94%A8%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9/"/>
      <url>/2022/04/24/GCC%E5%B8%B8%E7%94%A8%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="GCC常用编译选项"><a href="#GCC常用编译选项" class="headerlink" title="GCC常用编译选项"></a>GCC常用编译选项</h1><p>​        </p><p>[TOC]</p><p>​        GCC有很多编译选项，有一些常用的选项可以作为检查代码质量的辅助手段，有的则可以让编译器对代码和编译目标文件进行优化，还有的是专门为了调试代码设计的，熟悉这些编译选项可以让开发者在使用GCC时更加游刃有余。</p><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS := -Wall -Wundef -Wshadow -Wconversion -Werror=return-type \</span><br><span class="line">    -Werror=implicit-function-declaration -Werror=unused-variable \</span><br><span class="line">    -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE \</span><br><span class="line">    -Wno-trigraphs -Os</span><br></pre></td></tr></tbody></table></figure><p>对于调试版本，将<code>-Os</code>替换为<code>-g -Og</code>。</p><h2 id="一-警告选项"><a href="#一-警告选项" class="headerlink" title="一 警告选项"></a>一 警告选项</h2><p>​        GCC编译器支持对代码进行诊断，<strong>针对代码本身不是错误但是疑似错误或者可能存在风险的地方发出警告</strong>，而警告编译选项就是用于<strong>控制需要告警的警告类型</strong>的。一般启用特定类型警告的格式为<code>-Wxxx</code>，而排除特定类型的警告的格式则一般为<code>-Wno-xxx</code>。</p><h3 id="1-Wall"><a href="#1-Wall" class="headerlink" title="1 -Wall"></a>1 -Wall</h3><p>​        这是一个非常常用的编译选项，用于启用一批<strong>比较常见且易于修改的警告</strong>，这些选项都是对代码进行基本的检查，比如下面这些：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-Waddress</td><td>检查是否存在可疑的内存地址使用</td></tr><tr><td>-Wformat</td><td>检查标准库函数的使用格式是否正确，比如printf的格式化字符串中的格式符和对应的参数是否匹配</td></tr><tr><td>-Wunused-function</td><td>对已声明但是未定义的静态函数和未被使用的非内联静态函数发出警告</td></tr><tr><td>-Wswitch</td><td>当用switch用于枚举类型时，判断分支是否包含所有枚举值，否则发出警告</td></tr><tr><td>-Wunused-variable</td><td>对声明但未被使用的变量发出警告</td></tr><tr><td>-Wunused-but-set-variable</td><td>对声明且被赋值但未被使用的变量发出警告</td></tr><tr><td>-Warray-bounds=1</td><td>数组越界检查，需启用选项-ftree-vrp</td></tr></tbody></table><p>​        当需要排除某些类型的警告时，记得使用<code>-Wno-xxx</code>, 比如使用<code>-Wall -Wno-unused-variable</code>可以从<code>-Wall</code>中排除<code>-Wunused-variable</code>。</p><p>​        完整的列表参见链接**<a href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html">Warning-Options</a>**。</p><h3 id="2-Wextra"><a href="#2-Wextra" class="headerlink" title="2 -Wextra"></a>2 -Wextra</h3><p>​        单单只有<code>-Wall</code>可能还不够严格，GCC还有<code>-Wextra</code>作为补充，包括另外一些没有被<code>-Wall</code>包含的警告类型，比如笔者比较喜欢的几个：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-Wcast-function-type</td><td>当函数被强转为不兼容的函数指针时发出警告</td></tr><tr><td>-Wempty-body</td><td>当存在空的if、else或者do while语句时发出警告</td></tr><tr><td>-Wunused-parameter</td><td>当函数有未被使用的参数时发出警告，需配合-Wall</td></tr><tr><td>-Wunused-but-set-parameter</td><td>当存在被设置但是未被使用的参数发出警告，需配合-Wall</td></tr><tr><td>-Wsign-compare</td><td>当比较有符号和无符号值时发出警告</td></tr></tbody></table><p>对于不同语言，<code>-Wall</code>和<code>-Wextra</code>启用的选项可能略有差异</p><h3 id="3-Werror"><a href="#3-Werror" class="headerlink" title="3 -Werror"></a>3 -Werror</h3><p><code>-Werror</code>用于将所有警告视为错误。</p><p>​        如果不希望某些类型的警告被视为错误可以使用<code>-Wno-error=&lt;警告类型&gt;</code>，比如<code>-Wno-error=switch</code>；而使用<code>-Werror=&lt;警告类型&gt;</code>则可以将指定警告类型视为错误，比如<code>-Werror=switch</code>。</p><p>​        当代码量变得比较大的时候，同时启用<code>-Wall -Wextra -Werror</code>是比较严苛的，可能存在一些不准确的警告，这时可以将<code>-Werror</code>替换为只将某些警告视为错误，在自动化编译构建的时候提前报错终止提示开发者进行改进。</p><p>​        对于大部分<code>-Wunused-</code>类警告选项，其实都是<strong>让开发者明确知道定义的变量或者参数是不是必须的</strong>，是多余的还是忘记使用了，对于反思代码逻辑和简化代码都是很有帮助的，所以建议将这些警告视为错误。</p><h3 id="4-Wpedantic"><a href="#4-Wpedantic" class="headerlink" title="4 -Wpedantic"></a>4 -Wpedantic</h3><p>对于所有不符合<code>ISO C/ISO C++</code>语言标准的源代码发出警告，等价于<code>-pedantic</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-pedantic-errors`参数将这些警告视为错误，等同于`-Werror=pedantic</span><br></pre></td></tr></tbody></table></figure><h3 id="5-Wshadow"><a href="#5-Wshadow" class="headerlink" title="5 -Wshadow"></a>5 -Wshadow</h3><p>当局部变量屏蔽（shadow）已有已有变量时发出警告。比如以下代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int ret = 0;</span><br><span class="line">for (int i = 0; i &lt; 10; ++i) {</span><br><span class="line">    int ret = i;  //  warning: declaration shadows a local variable</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="6-Wconversion"><a href="#6-Wconversion" class="headerlink" title="6 -Wconversion"></a>6 -Wconversion</h3><p>​        在<strong>隐式转换可能导致值变化的时候</strong>发出警告。在隐式转换的时候，如果值发生变化，那么结果可能就不是预料中的，所以最好使用显式转换。</p><h2 id="二-优化选项"><a href="#二-优化选项" class="headerlink" title="二 优化选项"></a>二 优化选项</h2><p>​        优化选项用于控制编译器对代码的优化等级。比较常用的是<code>-O2</code>和<code>-Os</code>。详细的介绍请查看官网**<a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">Optimize-Options</a>**。</p><h3 id="1-O0-Og"><a href="#1-O0-Og" class="headerlink" title="1 -O0/-Og"></a>1 -O0/-Og</h3><p>​        <code>-O0</code>是默认选项，不执行任何优化。在编译调试版本的时候，一般使用<code>-O0</code>，可以确保调试执行过程完全和代码一致（如果使用优化选项，根据源文件设定的断点和经过优化编译得到的程序可能对不上，所以不能准确停在预期的地方）。</p><p>​        <code>-Og</code>是针对调试的优化选项，它会启用<code>-O1</code>的优化指令，除了那么可能会干扰调试的优化选项，同时可获取到更多的调试信息，提供更好好的编译体验，</p><h3 id="2-O-O1"><a href="#2-O-O1" class="headerlink" title="2 -O/-O1"></a>2 -O/-O1</h3><p>​        执行级别1的优化，尝试减少代码大小和提高性能，但是不包括需要花费大量编译时间的优化选项。</p><p>比如：</p><ol><li><code>-fdce</code>：移除不可能执行到的代码</li><li><code>-fif-conversion</code>：尝试简化if语句。使用更少的分支、转化成标志位等操作</li><li><code>-fmerge-constants</code>：尝试合并相同的常量</li></ol><h3 id="3-O2"><a href="#3-O2" class="headerlink" title="3 -O2"></a>3 -O2</h3><p>​        执行<code>-O1</code>所有优化选项，同时额外执行<strong>几乎全部不需要在空间和性能之间平衡</strong>的优化选项。</p><p>比如：</p><ol><li><code>-fgcse</code>：优化全局公共表达式、常量的传递</li><li><code>-fcode-hoisting</code>：将所有分支都需要执行的表达式尽早执行（对于优化代码大小很有用，同时也提升性能）</li><li><code>-finline-functions</code>：考虑将所有函数变成内联函数（即使没有被声明为inline）</li></ol><h3 id="4-Os"><a href="#4-Os" class="headerlink" title="4 -Os"></a>4 -Os</h3><p>​        这是专门用于优化代码大小的优化级别，执行<code>-O2</code>所有优化选项，排除那些可能导致程序大小增加的优化选项。</p><h3 id="5-O3"><a href="#5-O3" class="headerlink" title="5 -O3"></a>5 -O3</h3><p>​        最高优化等级。该优化级别较高，执行的优化不会很直观，所以可能也会出现一些问题，需要看实际情况选择是否需要使用<code>-O3</code>。在使用<code>-O3</code>优化级别时，<strong>小概率出现代码执行一段时间后出现了一些不符合预期的现象</strong>，在降低优化等级时则没有问题。</p><h3 id="6-ffunction-sections-fdata-sections-Wl-–gc-sections"><a href="#6-ffunction-sections-fdata-sections-Wl-–gc-sections" class="headerlink" title="6 -ffunction-sections/-fdata-sections/-Wl,–gc-sections"></a>6 -ffunction-sections/-fdata-sections/-Wl,–gc-sections</h3><p>​        在开发过程中，可能会实现一些实际并不会用到的函数或者对外有多个接口，并不是所有的接口都需要用到所有的模块和函数，但是默认情况下，GCC会把整个静态库链接到目标可执行文件，所以会增加可执行文件的大小。</p><p>​        GCC在链接的时候以<code>section</code>为单元处理，所以可以尝试使用<code>-ffunction-sections/-fdata-sections</code>将每个函数或者符号创建成独立的<code>section</code>，然后结合选项<code>-Wl,--gc-sections</code>让链接器忽略用不到的<code>section</code>，这样就可以减少目标可执行程序的大小。其中<code>-Wl</code>表示将后面的参数传递给链接器，所以也可以直接设置链接器选项。</p><p>​        注意这个并不是所有的链接器都支持的，大多数支持编译ELF目标文件的工具链都是支持的，<strong>一般嵌入式开发会比较常用</strong>的。</p><h2 id="三-代码生成选项"><a href="#三-代码生成选项" class="headerlink" title="三 代码生成选项"></a>三 代码生成选项</h2><p>​        最常用的就只有<code>-fPIC</code>，该选项用于生成**位置无关代码(PIC，position-independent code)**，主要是为了生成共享库。此类代码通过全局偏移表 (GOT) 访问所有常量地址，在程序启动的时候，动态加载器会确定需要使用的共享库的GOT。</p><p><code>-fPIE</code>和<code>-fPIC</code>是类似的，但<code>-fPIE</code>产生的位置无关代码只能用于链接可执行文件。</p><p>另外可能还会偶尔用到<code>-fpic</code>和<code>-fpie</code>，它们和全大写的区别只在于系统对GOT大小有一定限制。</p><h2 id="四-调试选项"><a href="#四-调试选项" class="headerlink" title="四 调试选项"></a>四 调试选项</h2><p>​        一般情况下是为了能够正常使用调试器调试程序，必须要让编译器给编译目标添加额外的调试信息。最常使用的是<code>-g</code>，一般可以满足需求。但是如果为了提升一些调试程序的性能，可以配合使用针对调试的优化选项<code>-Og</code>。（添加的调试信息可以使用<code>strip</code>工具移除，一般对于需要release的程序代码可以都通过此工具移除一些敏感信息，同时也能够减少目标文件的大小。）</p><p>​        GCC的编译选项还有很多，对于常用的就是上面这一些，在开发阶段，最重要还是通过一些有用的警告选项排查常见的代码bug，提高代码的鲁棒性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Thread.sleep(0)的作用</title>
      <link href="/2022/04/24/Thread.sleep(0)%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2022/04/24/Thread.sleep(0)%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Thread-sleep-0-的作用"><a href="#Thread-sleep-0-的作用" class="headerlink" title="Thread.sleep(0)的作用"></a>Thread.sleep(0)的作用</h1><p>我们可能经常会用到 Thread.Sleep 函数来吧使线程挂起一段时间。那么你有没有正确的理解这个函数的用法呢？<br>思考下面这两个问题：</p><p>假设现在是 2008-4-7 12:00:00.000，如果我调用一下 Thread.Sleep(1000) ，在 2008-4-7 12:00:01.000 的时候，这个线程会不会被唤醒？</p><p>某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？</p><p>我们先回顾一下操作系统原理。</p><p>操作系统中，CPU竞争有很多种策略。Unix系统使用的是时间片算法，而Windows则属于抢占式的。</p><p>在时间片算法中，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程 序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。</p><p>所谓抢占式操作系统，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。因此可以看出，在抢 占式操作系统中，操作系统假设所有的进程都是“人品很好”的，会主动退出 CPU 。</p><p>在抢占式操作系统中，假设有若干进程，操作系统会根据他们的优先级、饥饿时间（已经多长时间没有使用过 CPU 了），给他们算出一 个总的优先级来。操作系统就会把 CPU 交给总优先级最高的这个进程。当进程执行完毕或者自己主动挂起后，操作系统就会重新计算一 次所有进程的总优先级，然后再挑一个优先级最高的把 CPU 控制权交给他。</p><p>我们用分蛋糕的场景来描述这两种算法。假设有源源不断的蛋糕（源源不断的时间），一副刀叉（一个CPU），10个等待吃蛋糕的人（10 个进程）。</p><p>如果是 Unix操作系统来负责分蛋糕，那么他会这样定规矩：每个人上来吃 1 分钟，时间到了换下一个。最后一个人吃完了就再从头开始。于是，不管这10个人是不是优先级不同、饥饿程度不同、饭量不同，每个人上来的时候都可以吃 1 分钟。当然，如果有人本来不太饿，或者饭量小，吃了30秒钟之后就吃饱了，那么他可以跟操作系统说：我已经吃饱了（挂起）。于是操作系统就会让下一个人接着来。</p><p>如果是 Windows 操作系统来负责分蛋糕的，那么场面就很有意思了。他会这样定规矩：我会根据你们的优先级、饥饿程度去给你们每个人计算一个优先级。优先级最高的那个人，可以上来吃蛋糕——吃到你不想吃为止。等这个人吃完了，我再重新根据优先级、饥饿程度来计算每个人的优先级，然后再分给优先级最高的那个人。</p><p>这样看来，这个场面就有意思了——可能有些人是PPMM，因此具有高优先级，于是她就可以经常来吃蛋糕。可能另外一个人是个丑男，而去很ws，所以优先级特别低，于是好半天了才轮到他一次（因为随着时间的推移，他会越来越饥饿，因此算出来的总优先级就会越来越高，因此总有一天会轮到他的）。而且，如果一不小心让一个大胖子得到了刀叉，因为他饭量大，可能他会霸占着蛋糕连续吃很久很久，导致旁边的人在那里咽口水。。。</p><p>而且，还可能会有这种情况出现：操作系统现在计算出来的结果，5号PPMM总优先级最高，而且高出别人一大截。因此就叫5号来吃蛋糕。5号吃了一小会儿，觉得没那么饿了，于是说“我不吃了”（挂起）。，因此操作系统就会重新计算所有人的优先级。</p><p>因为5号刚刚吃过，因此她的饥饿程度变小了，于是总优先级变小了；而其他人因为多等了一会儿，饥饿程度都变大了，所以总优先级也变大了。不过这时候仍然有可能5号的优先级比别的都高，只不过现在只比其他的高一点点——但她仍然是总优先级最高的啊。因此操作系统就会说：5号mm上来吃蛋糕……（5号mm心里郁闷，这不刚吃过嘛……人家要减肥……谁叫你长那么漂亮，获得了那么高的优先级）。</p><p>那么，Thread.Sleep 函数是干吗的呢？还用刚才的分蛋糕的场景来描述。上面的场景里面，5号MM在吃了一次蛋糕之后，觉得已经有8分饱了，她觉得在未来的半个小时之内都不想再来吃蛋糕了，那么她就会跟操作系统说：在未来的半个小时之内不要再叫我上来吃蛋糕了。</p><p>这样，操作系统在随后的半个小时里面重新计算所有人总优先级的时候，就会忽略5号mm。Sleep函数就是干这事的，他告诉操作系统“在未来的多少毫秒内我不参与CPU竞争”。</p><p>看完了 Thread.Sleep 的作用，我们再来想想文章开头的两个问题。</p><p>对于第一个问题，答案是：不一定。因为你只是告诉操作系统：在未来的1000毫秒内我不想再参与到CPU竞争。那么1000毫秒过去之后，这时候也许另外一个线程正在使用CPU，那么这时候操作系统是不会重新分配CPU的，直到那个线程挂起或结束；况且，即使这个时候恰巧轮到操作系统进行CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU还是可能被其他线程抢占去。</p><p>与此相似的，Thread有个Resume函数，是用来唤醒挂起的线程的。好像上面所说的一样，这个函数只是“告诉操作系统我从现在起开始参与CPU竞争了”，这个函数的调用并不能马上使得这个线程获得CPU控制权。</p><p>对于第二个问题，答案是：有，而且区别很明显。假设我们刚才的分蛋糕场景里面，有另外一个PPMM 7号，她的优先级也非常非常高（因为非常非常漂亮），所以操作系统总是会叫道她来吃蛋糕。而且，7号也非常喜欢吃蛋糕，而且饭量也很大。不过，7号人品很好，她很善良，她没吃几口就会想：如果现在有别人比我更需要吃蛋糕，那么我就让给他。</p><p>因此，她可以每吃几口就跟操作系统说：我们来重新计算一下所有人的总优先级吧。不过，操作系统不接受这个建议——因为操作系统不提供这个接口。于是7号mm就换了个说法：“在未来的0毫秒之内不要再叫我上来吃蛋糕了”。这个指令操作系统是接受的，于是此时操作系统就会重新计算大家的总优先级——注意这个时候是连7号一起计算的，因为“0毫秒已经过去了”嘛。因此如果没有比7号更需要吃蛋糕的人出现，那么下一次7号还是会被叫上来吃蛋糕。</p><p>因此，Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。这也是我们在大循环里面经常会写一句Thread.Sleep(0) ，因为这样就给了其他线程比如Paint线程获得CPU控制权的权力，这样界面就不会假死在那里。</p><p>另外，虽然上面提到说“除非它自己放弃使用 CPU ，否则将完全霸占 CPU”，但这个行为仍然是受到制约的——操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。至于我们的大循环造成程序假死，并不是因为这个线程一直在霸占着CPU。</p><p>实际上在这段时间操作系统已经进行过多次CPU竞争了，只不过其他线程在获得CPU控制权之后很短时间内马上就退出了，于是就又轮到了这个线程继续执行循环，于是就又用了很久才被操作系统强制挂起。。。因此反应到界面上，看起来就好像这个线程一直在霸占着CPU一样。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2022/04/24/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2022/04/24/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>[TOC]</p><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>基本的位操作符有与、或、异或、取反、左移、右移这6种:</p><table><thead><tr><th>符号</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td><td>两个bit都为1，才为1</td></tr><tr><td>|</td><td>或</td><td>两个bit都为0，才为0</td></tr><tr><td>^</td><td>异或</td><td>两个bit相同为0，不同为1</td></tr><tr><td>~</td><td>取反</td><td>0变1，1变0</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>左移若干位，高位丢弃，低位补0</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>右移若干位，无符号数高位补0，有符号数不同编译器处理不同，有的补符号位（算术右移），有的补0（逻辑右移）</td></tr></tbody></table><h2 id="位运算示例操作"><a href="#位运算示例操作" class="headerlink" title="位运算示例操作"></a>位运算示例操作</h2><table><thead><tr><th>位运算</th><th>功能</th><th>示例</th><th></th></tr></thead><tbody><tr><td>x &gt;&gt; 1</td><td>去掉最后一位</td><td>101101-&gt;10110</td><td></td></tr><tr><td>x &lt;&lt; 1</td><td>在最后加一个0</td><td>101101-&gt;1011010</td><td></td></tr><tr><td>x &lt;&lt; 1</td><td>在最后加一个1</td><td>101101-&gt;1011011</td><td></td></tr><tr><td>x\</td><td>1</td><td>把最后一位变成1</td><td>101100-&gt;101101</td></tr><tr><td>x &amp; -2</td><td>把最后一位变成0</td><td>101101-&gt;101100</td><td></td></tr><tr><td>x ^ 1</td><td>最后一位取反</td><td>101101-&gt;101100</td><td></td></tr><tr><td>x \</td><td>(1 &lt;&lt; (k-1))</td><td>把右数第k位变成1</td><td>101001-&gt;101101,k=3</td></tr><tr><td>x &amp; ~ (1 &lt;&lt; (k-1))</td><td>把右数第k位变成0</td><td>101101-&gt;101001,k=3</td><td></td></tr><tr><td>x ^(1 &lt;&lt;(k-1))</td><td>右数第k位取反</td><td>101001-&gt;101101,k=3</td><td></td></tr><tr><td>x &amp; 7</td><td>取末三位</td><td>1101101-&gt;101</td><td></td></tr><tr><td>x &amp; (1 &lt;&lt; k-1)</td><td>取末k位</td><td>1101101-&gt;1101,k=5</td><td></td></tr><tr><td>x &gt;&gt; (k-1) &amp; 1</td><td>取右数第k位</td><td>1101101-&gt;1,k=4</td><td></td></tr><tr><td>x \</td><td>((1 &lt;&lt; k)-1)</td><td>把末k位变成1</td><td>101001-&gt;101111,k=4</td></tr><tr><td>x ^ (1 &lt;&lt; k-1)</td><td>末k位取反</td><td>101001-&gt;100110,k=4</td><td></td></tr><tr><td>x &amp; (x+1)</td><td>把右边连续的1变成0</td><td>100101111-&gt;100100000</td><td></td></tr><tr><td>x \</td><td>(x+1)</td><td>把右起第一个0变成1</td><td>100101111-&gt;100111111</td></tr><tr><td>x \</td><td>(x-1)</td><td>把右边连续的0变成1</td><td>11011000-&gt;11011111</td></tr><tr><td>(x ^ (x+1)) &gt;&gt; 1</td><td>取右边连续的1</td><td>100101111-&gt;1111</td><td></td></tr><tr><td>x &amp; -x</td><td>去掉右起第一个1的左边</td><td>100101000-&gt;1000</td><td></td></tr><tr><td>x&amp;0x7F</td><td>取末7位</td><td>100101000-&gt;101000</td><td></td></tr><tr><td>x&amp; ~0x7F</td><td>是否小于127</td><td>001111111 &amp; ~0x7F-&gt;0</td><td></td></tr><tr><td>x &amp; 1</td><td>判断奇偶</td><td>00000111&amp;1-&gt;1</td><td></td></tr></tbody></table><p>使用位运算的两点注意事项：</p><ol><li>位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。</li><li>位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序</li></ol><h3 id="1-判断一个数值是不是2的整数次方"><a href="#1-判断一个数值是不是2的整数次方" class="headerlink" title="1. 判断一个数值是不是2的整数次方"></a>1. 判断一个数值是不是2的整数次方</h3><p>解题思路：</p><p>2的整数次方对应的二进制的最高位上只有一个1，如：8，二进制为 1000； 4，二进制为 0100，</p><p>那么将该数字减去1再与该数字进行与运算，减去1 后得到二进制：7，二进制为 0111；3，二进制为 0011，可以看出 8&amp;7 为0，</p><p>4&amp;3 为0</p><p>所以，如果 n 是2的整数次方，那么 n &amp; ( n - 1 )结果一定为0:</p><p>n 的数值要大于 0 </p><h3 id="2-使用位运算交换两个数字【不使用中间变量】"><a href="#2-使用位运算交换两个数字【不使用中间变量】" class="headerlink" title="2. 使用位运算交换两个数字【不使用中间变量】"></a>2. 使用位运算交换两个数字【不使用中间变量】</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.  public class Main {</span><br><span class="line">3.      public static void main(String[] args) {</span><br><span class="line">4.          int n = 8, m = 10;</span><br><span class="line">5.          n ^= m;</span><br><span class="line">6.          m ^= n;</span><br><span class="line">7.          n ^= m;</span><br><span class="line">8.          System.out.println(n + ", " + m);</span><br><span class="line">9.      }</span><br><span class="line">10.  }</span><br></pre></td></tr></tbody></table></figure><p>如： a = 13, b = 6:<br>a的二进制为 13 = 8 + 4 + 1 = 1101(二进制)<br>b的二进制为 6 = 4 + 2 = 110(二进制)</p><ol><li>a ^= b a = 1101 ^ 110 = 1011;</li><li>b ^= a b = 110 ^ 1011 = 1101; 即b == 13</li><li>a ^= b a = 1011 ^ 1101 = 110; 即a == 6</li></ol><p>其他方法，<strong>使用加减法</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.  public class Main {</span><br><span class="line">3.      public static void main(String[] args) {</span><br><span class="line">4.          int n = 8, m = 10;</span><br><span class="line">5.          n = n + m;</span><br><span class="line">6.          m = n - m;</span><br><span class="line">7.          n = n - m;</span><br><span class="line">8.          System.out.println(n + ", " + m);</span><br><span class="line">9.      }</span><br><span class="line">10.  }</span><br></pre></td></tr></tbody></table></figure><h3 id="3-计算在一个-32-位的整数的二进制表示中有多少个-1"><a href="#3-计算在一个-32-位的整数的二进制表示中有多少个-1" class="headerlink" title="3. 计算在一个 32 位的整数的二进制表示中有多少个 1"></a>3. 计算在一个 32 位的整数的二进制表示中有多少个 1</h3><p>循环使用x &amp; (x-1)消去最后一位1，计算总共消去了多少次即可。如：</p><p>13： 1101</p><p>12： 1100</p><p>相与：1100， 消去最后一位</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.  public class Main {</span><br><span class="line">3.      public static void main(String[] args) {</span><br><span class="line">4.          // 计算在一个 32 位的整数的二进制表示中有多少个 1</span><br><span class="line">5.          int m = 13, num = 0;</span><br><span class="line">6.          while (true){</span><br><span class="line">7.              if (m == 0) break;</span><br><span class="line">8.              m &amp;= (m-1); </span><br><span class="line">9.              num ++; </span><br><span class="line">10.          }</span><br><span class="line">11.          System.out.println(num);</span><br><span class="line">12.      }</span><br><span class="line">14.  }</span><br></pre></td></tr></tbody></table></figure><h3 id="4-正数变成负数，或者负数变成正数"><a href="#4-正数变成负数，或者负数变成正数" class="headerlink" title="4. 正数变成负数，或者负数变成正数"></a>4. 正数变成负数，或者负数变成正数</h3><p><strong>变换符号只需要取反后加1即可</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.  public class Main {</span><br><span class="line">3.      public static void main(String[] args) { </span><br><span class="line">5.          int m = -13; </span><br><span class="line">6.          int changeM = ~m + 1; </span><br><span class="line">7.          System.out.println(changeM);</span><br><span class="line">8.      }</span><br><span class="line">10.  }</span><br></pre></td></tr></tbody></table></figure><h3 id="5-判断一个数值的奇偶"><a href="#5-判断一个数值的奇偶" class="headerlink" title="5. 判断一个数值的奇偶"></a>5. 判断一个数值的奇偶</h3><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数，所以只需要与 1 相与。</p><p>因此可以用if ((a &amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.  public class Main {</span><br><span class="line">3.      public static void main(String[] args) {  </span><br><span class="line">4.          int m = -14;</span><br><span class="line">6.          if ((m &amp; 1) == 1){</span><br><span class="line">7.              System.out.println("ji");</span><br><span class="line">8.          }else{</span><br><span class="line">9.              System.out.println("ou"); </span><br><span class="line">10.          }  </span><br><span class="line">11.      }</span><br><span class="line">13.  }</span><br></pre></td></tr></tbody></table></figure><h3 id="6-乘以2-的m次方操作"><a href="#6-乘以2-的m次方操作" class="headerlink" title="6. 乘以2 的m次方操作"></a>6. 乘以2 的m次方操作</h3><p>乘以2的操作，即2的1次方，左移 1 位</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(10&lt;&lt;1);</span><br></pre></td></tr></tbody></table></figure><p>推导扩展，乘以2的m次方：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(10&lt;&lt;2); // 乘以 2的2次方，相当于乘以 4 </span><br></pre></td></tr></tbody></table></figure><h3 id="7-除以2运算-负奇数的运算不可用"><a href="#7-除以2运算-负奇数的运算不可用" class="headerlink" title="7.除以2运算(负奇数的运算不可用)"></a>7.除以2运算(负奇数的运算不可用)</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(10&gt;&gt;1);</span><br></pre></td></tr></tbody></table></figure><h3 id="8-转换成绝对值"><a href="#8-转换成绝对值" class="headerlink" title="8. 转换成绝对值"></a>8. 转换成绝对值</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.  public class Main {</span><br><span class="line">3.      public static void main(String[] args) {  </span><br><span class="line">4.          int n = 12;</span><br><span class="line">6.          System.out.println(0 &gt;&gt; 31); // 0 </span><br><span class="line">7.          System.out.println(10 &gt;&gt; 31);  // 0  </span><br><span class="line">8.          System.out.println(-10 &gt;&gt; 31);  // -1</span><br><span class="line">10.          System.out.println((n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31));  // 12 </span><br><span class="line">12.      }</span><br><span class="line">14.  }</span><br></pre></td></tr></tbody></table></figure><p>1.首先：n&gt;&gt;31 取得n的符号</p><p>若n为正数，n&gt;&gt;31等于0；若n为负数，n&gt;&gt;31等于-1 若n为正数 n^0-0数不变；</p><ol><li>若 n 为负数 n^-1 需要计算 n 和 -1 的补码，异或后再取补码， 结果n变号并且绝对值减1，再减去-1就是绝对值</li></ol><h3 id="9-判断两数符号是否相同"><a href="#9-判断两数符号是否相同" class="headerlink" title="9.判断两数符号是否相同"></a>9.判断两数符号是否相同</h3><p>true 表示 x和y有相同的符号， false表示x，y有相反的符号。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println((a ^ b) &gt; 0);</span><br></pre></td></tr></tbody></table></figure><h3 id="10-求两个整数（int）的平均数"><a href="#10-求两个整数（int）的平均数" class="headerlink" title="10. 求两个整数（int）的平均数"></a>10. 求两个整数（int）的平均数</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println((a+b) &gt;&gt; 1);</span><br></pre></td></tr></tbody></table></figure><h3 id="11-求两个整数的最大值"><a href="#11-求两个整数的最大值" class="headerlink" title="11. 求两个整数的最大值"></a>11. 求两个整数的最大值</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.  int max(int a,int b){</span><br><span class="line">2.      return b &amp; ((a-b) &gt;&gt; 31) | a &amp; (~(a-b) &gt;&gt; 31);</span><br><span class="line">3.      /*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/</span><br><span class="line">4.  }</span><br></pre></td></tr></tbody></table></figure><h3 id="12-求两个整数的最小值"><a href="#12-求两个整数的最小值" class="headerlink" title="12.求两个整数的最小值"></a>12.求两个整数的最小值</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.  int min(int a,int b){</span><br><span class="line">2.      return a &amp; ((a-b) &gt;&gt; 31) | b &amp; (~(a-b) &gt;&gt; 31);</span><br><span class="line">3.      /*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/</span><br><span class="line">4.  }</span><br></pre></td></tr></tbody></table></figure><h3 id="13-两个整数的加法运算"><a href="#13-两个整数的加法运算" class="headerlink" title="13. 两个整数的加法运算"></a>13. <strong>两个整数的加法运算</strong></h3><p>使用 <code>^</code> 和 <code>&amp;</code> 将两个整数相加</p><ol><li>两个数异或：相当于两个数相加，而不考虑进位；</li><li>两个数相与，并左移一位：相当于求得进位；</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">13+11 = ？;</span><br><span class="line">13 的二进制      1 1 0 1                     -----a        13</span><br><span class="line">11 的二进制      1 0 1 1                     -----b        11  </span><br><span class="line"> (a&amp;b) &lt;&lt;1  -&gt;   1 0 0 1 0                         -----d         18</span><br><span class="line">          a^b  -&gt;     0 1 1 0                   -----e          6</span><br><span class="line"> (d&amp;e) &lt;&lt;1  -&gt;   0 0 1 0 0                       ------f         4</span><br><span class="line">          d^e  -&gt;  1 0 1 0 0                  -----g        20</span><br><span class="line"> (f&amp;g) &lt;&lt;1  -&gt;   0 1 0 0 0                       ------h        8</span><br><span class="line">          f^g  -&gt;  1 0 0 0 0                   ------i           16</span><br><span class="line"> (h&amp;i) &lt;&lt;1  -&gt;   0 0 0 0 0                      ------h        0       ---- -------- 没有进位了， 则退出循环</span><br><span class="line">          h^i  -&gt;  1 1 0 0 0                  ------i           24</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.  private static int getSum(int a, int b) {</span><br><span class="line">2.      if (a == 0) return b;</span><br><span class="line">3.      if (b == 0) return a;</span><br><span class="line">4.      while (b != 0) {</span><br><span class="line">5.          int carry = a &amp; b; // 得到有进位的位置</span><br><span class="line">6.          a = a ^ b; // 直接相加，但是没有进位</span><br><span class="line">7.          b = carry &lt;&lt; 1; // 得到进位</span><br><span class="line">8.      }</span><br><span class="line">9.      return a;</span><br><span class="line">10.  }</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>doxygen教程</title>
      <link href="/2022/04/24/doxygen%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/24/doxygen%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>doxygen教程</p><p><strong>一．什么是Doxygen?</strong></p><p>​        Doxygen 是一个程序的文件产生工具，可将程序中的特定批注转换成为说明文件。通常我们在写程序时，或多或少都会写上批注，但是对于其它人而言，要直接探索程序里的批注，与打捞泰坦尼克号同样的辛苦。大部分有用的批注都是属于针对函式，类别等等的说明。所以，如果能依据程序本身的结构，将批注经过处理重新整理成为一个纯粹的参考手册，对于后面利用您的程序代码的人而言将会减少许多的负担。不过，反过来说，整理文件的工作对于您来说，就是沉重的负担。Doxygen 就是在您写批注时，稍微<strong>按照一些它所制订的规则</strong>。接着，他就可以帮您产生出漂亮的文档了。</p><p>​        因此，Doxygen 的使用可分为两大部分。首先是<strong>特定格式的批注撰写</strong>，第二便是<strong>利用Doxygen的工具来产生文档。</strong></p><p>​        目前Doxygen可处理的程序语言包含：C/C++、 Java、IDL (Corba, Microsoft及KDE-DCOP类型)  ，而可产生出来的文档格式有：HTML、XML、LaTeX、RTF、Unix Man Page。而其中还可衍生出不少其它格式。HTML可以打包成<strong>CHM格式</strong>，而LaTeX可以透过一些工具产生出<strong>PS或是PDF文档</strong>。</p><p><strong>二．安装Doxygen</strong></p><p>1.1 安装 Doxygen  </p><p>1.2 安装 graphviz  —&gt;</p><p>​        graphviz 是一个由AT&amp;T实验室启动的开源工具包，用于绘制DOT语言脚本描述的图形。Doxygen 使用 graphviz 自动生成类之间和文件之间的调用关系图，如不需要此功能可不安装该工具包。</p><p>1.3 安装 Windows Help Workshop  —&gt; </p><p>​        Doxygen 使用这个工具可以生成 CHM 格式的文档。</p><p><strong>三．Doxygen的配置</strong></p><p>​        Doxygen 产生文档可以分为三个步骤。一是在程序代码中加上符合Doxygen所定义批注格式。二是使用Doxywizard进行配置。三是使用Doxygen来产生批注文档。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Base64的编码原理</title>
      <link href="/2022/04/24/Base64%E7%9A%84%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/"/>
      <url>/2022/04/24/Base64%E7%9A%84%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Base64的编码原理"><a href="#Base64的编码原理" class="headerlink" title="Base64的编码原理"></a><strong>Base64的编码原理</strong></h2><h3 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h3><ul><li><p>将待转换的字符串每三个字节分为一组，每个字节占8bit，那么共有24个二进制位。</p></li><li><p>将上面的24个二进制位每6个一组，共分为4组。</p></li><li><p>在每组前面添加两个0，每组由6个变为8个二进制位，总共32个二进制位，即四个字节。</p></li></ul><h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><h4 id="1-示例"><a href="#1-示例" class="headerlink" title="1.示例"></a>1.示例</h4><ul><li><p>“M”、“a”、”n”对应的ASCII码值分别为77，97，110，对应的二进制值是01001101、01100001、01101110。如图第二三行所示，由此组成一个24位的二进制字符串。</p></li><li><p>如图红色框，将24位每6位二进制位一组分成四组。</p></li><li><p>在上面每一组前面补两个0，扩展成32个二进制位，此时变为四个字节：00010011、00010110、00000101、00101110。分别对应的值（Base64编码索引）为：19、22、5、46。</p></li><li><p>用上面的值在Base64编码表中进行查找，分别对应：T、W、F、u。因此“Man”Base64编码之后就变为：TWFu。</p></li></ul><p><img src="/2022/04/24/Base64%E7%9A%84%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/base64_2.png" alt="img"></p><h4 id="2-位数不足情况"><a href="#2-位数不足情况" class="headerlink" title="2.位数不足情况"></a>2.<strong>位数不足情况</strong></h4><p>​        一个字节：一个字节共8个二进制位，依旧按照规则进行分组。此时共8个二进制位，每6个一组，则第二组缺少4位，用0补齐，得到两个Base64编码，而后面两组没有对应数据，都用“=”补上。因此，上图中“A”转换之后为“QQ==”；        </p><p>​        两个字节：两个字节共16个二进制位，依旧按照规则进行分组。此时总共16个二进制位，每6个一组，则第三组缺少2位，用0补齐，得到三个Base64编码，第四组完全没有数据则用“=”补上。因此，上图中“BC”转换之后为“QKM=”；</p><p><img src="/2022/04/24/Base64%E7%9A%84%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/base64_2.png" alt="img"></p><h4 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.<strong>注意事项</strong></h4><p>​        大多数编码都是由字符串转化成二进制的过程，而Base64的编码则是从二进制转换为字符串。与常规恰恰相反，Base64编码主要用在传输、存储、表示二进制领域，不能算得上加密，只是无法直接看到明文。也可以通过打乱Base64编码来进行加密。中文有多种编码（比如：utf-8、gb2312、gbk等），不同编码对应Base64编码结果都不一样。</p><h4 id="4-延伸"><a href="#4-延伸" class="headerlink" title="4.延伸"></a>4.<strong>延伸</strong></h4><p>​        上面我们已经看到了Base64就是用6位（2的6次幂就是64）表示字符，因此成为Base64。同理，Base32就是用5位，Base16就是用4位。大家可以按照上面的步骤进行演化一下。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CMakeLists语法</title>
      <link href="/2022/04/24/CMakeLists%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/04/24/CMakeLists%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="CMakeLists-txt-语法"><a href="#CMakeLists-txt-语法" class="headerlink" title="CMakeLists.txt 语法"></a>CMakeLists.txt 语法</h1><h2 id="一、Cmake-示例"><a href="#一、Cmake-示例" class="headerlink" title="一、Cmake 示例"></a>一、Cmake 示例</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.16)</span><br><span class="line">project(easylogging)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line"></span><br><span class="line">MESSAGE(STATUS "This is make for easylogging++ lib " ${PROJECT_BINARY_DIR})</span><br><span class="line"></span><br><span class="line">set(LIB_DIR ${PROJECT_SOURCE_DIR}/SDK/lib/easylogging++)</span><br><span class="line"></span><br><span class="line">include_directories(${LIB_DIR})</span><br><span class="line">include_directories(SDK/include/CRC)</span><br><span class="line">include_directories(mongoose)</span><br><span class="line">include_directories(SDK/include)</span><br><span class="line"></span><br><span class="line">set(SRC_LIST</span><br><span class="line">        mongoose/mongoose.c</span><br><span class="line">#        test.cpp</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">add_executable(${PROJECT_NAME} main.cpp ${SRC_LIST})</span><br><span class="line"></span><br><span class="line"># link the new hello_library target with the hello_binary target</span><br><span class="line">target_link_libraries( ${PROJECT_NAME}</span><br><span class="line">        PRIVATE</span><br><span class="line">        ${LIB_DIR}/libeasylogging.a</span><br><span class="line">        ws2_32</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">##########################Install##################################</span><br><span class="line">set(BUILD_DIR ${PROJECT_SOURCE_DIR}/../bin)</span><br><span class="line"></span><br><span class="line"># Binaries</span><br><span class="line">install (TARGETS ${PROJECT_NAME} DESTINATION ${BUILD_DIR})</span><br><span class="line"></span><br><span class="line"># Header files</span><br><span class="line">install(DIRECTORY ${PROJECT_BINARY_DIR}/tinyxml2 DESTINATION ${BUILD_DIR}/include)</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a><strong>二、常用命令</strong></h2><h4 id="1-指定-cmake-的最小版本"><a href="#1-指定-cmake-的最小版本" class="headerlink" title="1.指定 cmake 的最小版本"></a>1.指定 cmake 的最小版本</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.4</span><span class="number">.1</span>)</span><br></pre></td></tr></tbody></table></figure><p>​        这行命令是可选的，我们可以不写这句话，但在有些情况下，如果 CMakeLists.txt 文件中使用了一些高版本 cmake 特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行 cmake。</p><h4 id="2-设置项目名称"><a href="#2-设置项目名称" class="headerlink" title="2.设置项目名称"></a>2.设置项目名称</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project(demo VERSION 1.0.0 LANGUAGES C CXX)</span><br></pre></td></tr></tbody></table></figure><p>​        这个命令不是强制性的，但最好都加上。它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。</p><p>​        第一个字段是项目名称；通过<code>VERSION</code>指定版本号，格式为<code>main.minor.patch.tweak</code>，并且CMake会将对应的值分别赋值给以下变量（如果没有设置，则为空字符串）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PROJECT_VERSION, &lt;PROJECT-NAME&gt;_VERSION</span><br><span class="line">PROJECT_VERSION_MAJOR, &lt;PROJECT-NAME&gt;_VERSION_MAJOR</span><br><span class="line">PROJECT_VERSION_MINOR, &lt;PROJECT-NAME&gt;_VERSION_MINOR</span><br><span class="line">PROJECT_VERSION_PATCH, &lt;PROJECT-NAME&gt;_VERSION_PATCH</span><br><span class="line">PROJECT_VERSION_TWEAK, &lt;PROJECT-NAME&gt;_VERSION_TWEAK</span><br></pre></td></tr></tbody></table></figure><h4 id="3-指定编程语言版本"><a href="#3-指定编程语言版本" class="headerlink" title="3.指定编程语言版本"></a>3.指定编程语言版本</h4><p>为了在不同机器上编译更加统一，最好指定语言的版本，比如声明C使用<code>c99</code>标准，C++使用<code>c++11</code>标准：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_C_STANDARD 99)</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br></pre></td></tr></tbody></table></figure><h4 id="4-配置编译选项"><a href="#4-配置编译选项" class="headerlink" title="4.配置编译选项"></a>4.配置编译选项</h4><p>通过命令<code>add_compile_options</code>命令可以为所有编译器配置编译选项（同时对多个编译器生效）； 通过设置变量<code>CMAKE_C_FLAGS</code>可以配置c编译器的编译选项； 而设置变量<code>CMAKE_CXX_FLAGS</code>可配置针对c++编译器的编译选项。 比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_compile_options(-Wall -Wextra -pedantic -Werror)</span><br><span class="line">set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -pipe -std=c99")</span><br><span class="line">set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pipe -std=c++11")</span><br></pre></td></tr></tbody></table></figure><h4 id="3-设置编译类型"><a href="#3-设置编译类型" class="headerlink" title="3.设置编译类型"></a>3.设置编译类型</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_BUILD_TYPE Debug)</span><br><span class="line">add_executable(demo demo.cpp) # 生成可执行文件</span><br><span class="line">add_library(common STATIC util.cpp) # 生成静态库</span><br><span class="line">add_library(common SHARED util.cpp) # 生成动态库或共享库</span><br></pre></td></tr></tbody></table></figure><p>通过设置变量<code>CMAKE_BUILD_TYPE</code>来配置编译类型，可设置为：<code>Debug</code>、<code>Release</code>、<code>RelWithDebInfo</code>、<code>MinSizeRel</code>等，比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_BUILD_TYPE Debug)</span><br></pre></td></tr></tbody></table></figure><p>可以针对不同的编译类型设置不同的编译选项，比如对于<code>Debug</code>版本，开启调试信息，不进行代码优化：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -g -O0")</span><br><span class="line">set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -O0")</span><br></pre></td></tr></tbody></table></figure><p>对于<code>Release</code>版本，不包含调试信息，优化等级设置为2：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -O2")</span><br><span class="line">set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O2")</span><br></pre></td></tr></tbody></table></figure><p>add_library 默认生成是静态库，通过以上命令生成文件名字，<br>在 Linux 下是：<br>demo<br>libcommon.a<br>libcommon.so<br>在 Windows 下是：<br>demo.exe<br>common.lib<br>common.dll</p><h4 id="4-指定编译包含的源文件"><a href="#4-指定编译包含的源文件" class="headerlink" title="4.指定编译包含的源文件"></a>4.指定编译包含的源文件</h4><h5 id="4-1-明确指定包含哪些源文件"><a href="#4-1-明确指定包含哪些源文件" class="headerlink" title="4.1 明确指定包含哪些源文件"></a>4.1 明确指定包含哪些源文件</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_library(demo demo.cpp test.cpp util.cpp)</span><br></pre></td></tr></tbody></table></figure><h5 id="4-2-搜索所有的-cpp-文件"><a href="#4-2-搜索所有的-cpp-文件" class="headerlink" title="4.2 搜索所有的 cpp 文件"></a>4.2 搜索所有的 cpp 文件</h5><p>aux_source_directory(dir VAR) 发现一个目录下所有的源代码文件并将列表存储在一个变量中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(. SRC_LIST) # 搜索当前目录下的所有.cpp文件</span><br><span class="line">add_library(demo ${SRC_LIST})</span><br></pre></td></tr></tbody></table></figure><h5 id="4-3-自定义搜索规则"><a href="#4-3-自定义搜索规则" class="headerlink" title="4.3 自定义搜索规则"></a>4.3 自定义搜索规则</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB SRC_LIST "*.cpp" "protocol/*.cpp")</span><br><span class="line">add_library(demo ${SRC_LIST})</span><br><span class="line"># 或者</span><br><span class="line">file(GLOB SRC_LIST "*.cpp")</span><br><span class="line">file(GLOB SRC_PROTOCOL_LIST "protocol/*.cpp")</span><br><span class="line">add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})</span><br><span class="line"># 或者</span><br><span class="line">file(GLOB_RECURSE SRC_LIST "*.cpp") #递归搜索</span><br><span class="line">FILE(GLOB SRC_PROTOCOL RELATIVE "protocol" "*.cpp") # 相对protocol目录下搜索</span><br><span class="line">add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})</span><br><span class="line"># 或者</span><br><span class="line">aux_source_directory(. SRC_LIST)</span><br><span class="line">aux_source_directory(protocol SRC_PROTOCOL_LIST)</span><br><span class="line">add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})</span><br></pre></td></tr></tbody></table></figure><h4 id="5-查找指定的库文件"><a href="#5-查找指定的库文件" class="headerlink" title="5.查找指定的库文件"></a>5.查找指定的库文件</h4><p>​        find_library(VAR name path)查找到指定的预编译库，并将它的路径存储在变量中。默认的搜索路径为 cmake 包含的系统库，因此如果是 NDK 的公共库只需要指定库的 name 即可。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_library( # Sets the name of the path variable.</span><br><span class="line">              log-lib</span><br><span class="line"> </span><br><span class="line">              # Specifies the name of the NDK library that</span><br><span class="line">              # you want CMake to locate.</span><br><span class="line">              log )</span><br></pre></td></tr></tbody></table></figure><p>类似的命令还有 find_file()、find_path()、find_program()、find_package()。</p><h4 id="6-设置包含的目录"><a href="#6-设置包含的目录" class="headerlink" title="6.设置包含的目录"></a>6.设置包含的目录</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">include_directories(</span><br><span class="line">    ${CMAKE_CURRENT_SOURCE_DIR}</span><br><span class="line">    ${CMAKE_CURRENT_BINARY_DIR}</span><br><span class="line">    ${CMAKE_CURRENT_SOURCE_DIR}/include</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>Linux 下还可以通过如下方式设置包含的目录</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -I${CMAKE_CURRENT_SOURCE_DIR}")</span><br></pre></td></tr></tbody></table></figure><h4 id="7-设置链接库搜索目录"><a href="#7-设置链接库搜索目录" class="headerlink" title="7.设置链接库搜索目录"></a>7.设置链接库搜索目录</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">link_directories(</span><br><span class="line">    ${CMAKE_CURRENT_SOURCE_DIR}/libs</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>Linux 下还可以通过如下方式设置包含的目录</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -L${CMAKE_CURRENT_SOURCE_DIR}/libs")</span><br></pre></td></tr></tbody></table></figure><h4 id="8-设置-target-需要链接的库"><a href="#8-设置-target-需要链接的库" class="headerlink" title="8.设置 target 需要链接的库"></a>8.设置 target 需要链接的库</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries( # 目标库</span><br><span class="line">                       demo</span><br><span class="line"> </span><br><span class="line">                       # 目标库需要链接的库</span><br><span class="line">                       # log-lib 是上面 find_library 指定的变量名</span><br><span class="line">                       ${log-lib} )</span><br></pre></td></tr></tbody></table></figure><p>​        在 Windows 下，系统会根据链接库目录，搜索xxx.lib 文件，Linux 下会搜索 xxx.so 或者 xxx.a 文件，如果都存在会优先链接动态库（so 后缀）。</p><h5 id="8-1-指定链接动态库或静态库"><a href="#8-1-指定链接动态库或静态库" class="headerlink" title="8.1 指定链接动态库或静态库"></a>8.1 指定链接动态库或静态库</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(demo libface.a) # 链接libface.a</span><br><span class="line">target_link_libraries(demo libface.so) # 链接libface.so</span><br></pre></td></tr></tbody></table></figure><h5 id="8-2-指定全路径"><a href="#8-2-指定全路径" class="headerlink" title="8.2 指定全路径"></a>8.2 指定全路径</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.a)</span><br><span class="line">target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.so)</span><br></pre></td></tr></tbody></table></figure><h5 id="8-3-指定链接多个库"><a href="#8-3-指定链接多个库" class="headerlink" title="8.3 指定链接多个库"></a>8.3 指定链接多个库</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(demo</span><br><span class="line">    ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.a</span><br><span class="line">    boost_system.a</span><br><span class="line">    boost_thread</span><br><span class="line">    pthread)</span><br></pre></td></tr></tbody></table></figure><h4 id="9-设置变量"><a href="#9-设置变量" class="headerlink" title="9.设置变量"></a>9.设置变量</h4><h5 id="9-1-set-直接设置变量的值"><a href="#9-1-set-直接设置变量的值" class="headerlink" title="9.1 set 直接设置变量的值"></a>9.1 set 直接设置变量的值</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(SRC_LIST main.cpp test.cpp)</span><br><span class="line">add_executable(demo ${SRC_LIST})</span><br></pre></td></tr></tbody></table></figure><h5 id="9-2-set-追加设置变量的值"><a href="#9-2-set-追加设置变量的值" class="headerlink" title="9.2 set 追加设置变量的值"></a>9.2 set 追加设置变量的值</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(SRC_LIST main.cpp)</span><br><span class="line">set(SRC_LIST ${SRC_LIST} test.cpp)</span><br><span class="line">add_executable(demo ${SRC_LIST})</span><br></pre></td></tr></tbody></table></figure><h5 id="9-3-list-追加或者删除变量的值"><a href="#9-3-list-追加或者删除变量的值" class="headerlink" title="9.3 list 追加或者删除变量的值"></a>9.3 list 追加或者删除变量的值</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set(SRC_LIST main.cpp)</span><br><span class="line">list(APPEND SRC_LIST test.cpp)</span><br><span class="line">list(REMOVE_ITEM SRC_LIST main.cpp)</span><br><span class="line">add_executable(demo ${SRC_LIST})</span><br></pre></td></tr></tbody></table></figure><h4 id="10-条件控制"><a href="#10-条件控制" class="headerlink" title="10.条件控制"></a>10.条件控制</h4><h5 id="10-1-if…elseif…else…endif"><a href="#10-1-if…elseif…else…endif" class="headerlink" title="10.1 if…elseif…else…endif"></a>10.1 if…elseif…else…endif</h5><p><strong>逻辑判断和比较：</strong><br>if (expression)：expression 不为空（0,N,NO,OFF,FALSE,NOTFOUND）时为真<br>if (not exp)：与上面相反<br>if (var1 AND var2)<br>if (var1 OR var2)<br>if (COMMAND cmd)：如果 cmd 确实是命令并可调用为真<br>if (EXISTS dir) if (EXISTS file)：如果目录或文件存在为真<br>if (file1 IS_NEWER_THAN file2)：当 file1 比 file2 新，或 file1/file2 中有一个不存在时为真，文件名需使用全路径<br>if (IS_DIRECTORY dir)：当 dir 是目录时为真<br>if (DEFINED var)：如果变量被定义为真<br>if (var MATCHES regex)：给定的变量或者字符串能够匹配正则表达式 regex 时为真，此处 var 可以用 var 名，也可以用 ${var}<br>if (string MATCHES regex)</p><p><strong>数字比较：</strong><br>if (variable LESS number)：LESS 小于<br>if (string LESS number)<br>if (variable GREATER number)：GREATER 大于<br>if (string GREATER number)<br>if (variable EQUAL number)：EQUAL 等于<br>if (string EQUAL number)</p><p><strong>字母表顺序比较：</strong><br>if (variable STRLESS string)<br>if (string STRLESS string)<br>if (variable STRGREATER string)<br>if (string STRGREATER string)<br>if (variable STREQUAL string)<br>if (string STREQUAL string)</p><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">if(MSVC)</span><br><span class="line">    set(LINK_LIBS common)</span><br><span class="line">else()</span><br><span class="line">    set(boost_thread boost_log.a boost_system.a)</span><br><span class="line">endif()</span><br><span class="line">target_link_libraries(demo ${LINK_LIBS})</span><br><span class="line"># 或者</span><br><span class="line">if(UNIX)</span><br><span class="line">    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -fpermissive -g")</span><br><span class="line">else()</span><br><span class="line">    add_definitions(-D_SCL_SECURE_NO_WARNINGS</span><br><span class="line">    D_CRT_SECURE_NO_WARNINGS</span><br><span class="line">    -D_WIN32_WINNT=0x601</span><br><span class="line">    -D_WINSOCK_DEPRECATED_NO_WARNINGS)</span><br><span class="line">endif()</span><br><span class="line"> </span><br><span class="line">if(${CMAKE_BUILD_TYPE} MATCHES "debug")</span><br><span class="line">    ...</span><br><span class="line">else()</span><br><span class="line">    ...</span><br><span class="line">endif()</span><br></pre></td></tr></tbody></table></figure><h5 id="10-2-while…endwhile"><a href="#10-2-while…endwhile" class="headerlink" title="10.2 while…endwhile"></a>10.2 while…endwhile</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(condition)</span><br><span class="line">    ...</span><br><span class="line">endwhile()</span><br></pre></td></tr></tbody></table></figure><h5 id="10-3-foreach…endforeach"><a href="#10-3-foreach…endforeach" class="headerlink" title="10.3 foreach…endforeach"></a>10.3 foreach…endforeach</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach(loop_var RANGE start stop [step])</span><br><span class="line">    ...</span><br><span class="line">endforeach(loop_var)</span><br></pre></td></tr></tbody></table></figure><pre><code>start 表示起始数，stop 表示终止数，step 表示步长，示例：</code></pre><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreach(i RANGE 1 9 2)</span><br><span class="line">    message(${i})</span><br><span class="line">endforeach(i)</span><br><span class="line"># 输出：13579</span><br></pre></td></tr></tbody></table></figure><h4 id="11-打印信息"><a href="#11-打印信息" class="headerlink" title="11.打印信息"></a>11.打印信息</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message(${PROJECT_SOURCE_DIR})</span><br><span class="line">message("build with debug mode")</span><br><span class="line">message(WARNING "this is warnning message")</span><br><span class="line">message(FATAL_ERROR "this build has many error") # FATAL_ERROR 会导致编译失败</span><br></pre></td></tr></tbody></table></figure><h4 id="12-包含其它-cmake-文件"><a href="#12-包含其它-cmake-文件" class="headerlink" title="12.包含其它 cmake 文件"></a>12.包含其它 cmake 文件</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include(./common.cmake) # 指定包含文件的全路径</span><br><span class="line">include(def) # 在搜索路径中搜索def.cmake文件</span><br><span class="line">set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake) # 设置include的搜索路径</span><br></pre></td></tr></tbody></table></figure><h2 id="三、常用变量"><a href="#三、常用变量" class="headerlink" title="三、常用变量"></a>三、常用变量</h2><h4 id="1-预定义变量"><a href="#1-预定义变量" class="headerlink" title="1.预定义变量"></a>1.预定义变量</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PROJECT_SOURCE_DIR：工程的根目录</span><br><span class="line">PROJECT_BINARY_DIR：运行 cmake 命令的目录，通常是 ${PROJECT_SOURCE_DIR}/build</span><br><span class="line">PROJECT_NAME：返回通过 project 命令定义的项目名称</span><br><span class="line">CMAKE_CURRENT_SOURCE_DIR：当前处理的 CMakeLists.txt 所在的路径</span><br><span class="line">CMAKE_CURRENT_BINARY_DIR：target 编译目录</span><br><span class="line">CMAKE_CURRENT_LIST_DIR：CMakeLists.txt 的完整路径</span><br><span class="line">CMAKE_CURRENT_LIST_LINE：当前所在的行</span><br><span class="line">CMAKE_MODULE_PATH：定义自己的 cmake 模块所在的路径，SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)，然后可以用INCLUDE命令来调用自己的模块</span><br><span class="line">EXECUTABLE_OUTPUT_PATH：重新定义目标二进制可执行文件的存放位置</span><br><span class="line">LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的存放位置</span><br></pre></td></tr></tbody></table></figure><h4 id="2-环境变量"><a href="#2-环境变量" class="headerlink" title="2.环境变量"></a>2.环境变量</h4><p>使用环境变量</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ENV{Name}</span><br></pre></td></tr></tbody></table></figure><p>写入环境变量</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(ENV{Name} value) # 这里没有“$”符号</span><br></pre></td></tr></tbody></table></figure><h4 id="3-系统信息"><a href="#3-系统信息" class="headerlink" title="3.系统信息"></a>3.系统信息</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CMAKE_MAJOR_VERSION：cmake 主版本号，比如 3.4.1 中的 3</span><br><span class="line">CMAKE_MINOR_VERSION：cmake 次版本号，比如 3.4.1 中的 4</span><br><span class="line">CMAKE_PATCH_VERSION：cmake 补丁等级，比如 3.4.1 中的 1</span><br><span class="line">CMAKE_SYSTEM：系统名称，比如 Linux-2.6.22</span><br><span class="line">CMAKE_SYSTEM_NAME：不包含版本的系统名，比如 Linux</span><br><span class="line">CMAKE_SYSTEM_VERSION：系统版本，比如 2.6.22</span><br><span class="line">CMAKE_SYSTEM_PROCESSOR：处理器名称，比如 i686</span><br><span class="line">UNIX：在所有的类 UNIX 平台下该值为 TRUE，包括 OS X 和 cygwin</span><br><span class="line">WIN32：在所有的 win32 平台下该值为 TRUE，包括 cygwin</span><br></pre></td></tr></tbody></table></figure><h4 id="4-主要开关选项"><a href="#4-主要开关选项" class="headerlink" title="4.主要开关选项"></a>4.主要开关选项</h4><p>​        BUILD_SHARED_LIBS：这个开关用来控制默认的库编译方式，如果不进行设置，使用 add_library 又没有指定库类型的情况下，默认编译生成的库都是静态库。如果 set(BUILD_SHARED_LIBS ON) 后，默认生成的为动态库<br>CMAKE_C_FLAGS：设置 C 编译选项，也可以通过指令 add_definitions() 添加<br>CMAKE_CXX_FLAGS：设置 C++ 编译选项，也可以通过指令 add_definitions() 添加</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_definitions(-DENABLE_DEBUG -DABC) # 参数之间用空格分隔</span><br></pre></td></tr></tbody></table></figure><h4 id="5-自定义编译选项"><a href="#5-自定义编译选项" class="headerlink" title="5.自定义编译选项"></a>5.自定义编译选项</h4><p>​        cmake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。例如，可以将 MathFunctions 库设为一个可选的库，如果该选项为 ON ，就使用该库定义的数学函数来进行运算，否则就调用标准库中的数学函数库。修改根目录下的 CMakeLists.txt 文件如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo)</span><br><span class="line"># 加入一个配置头文件，用于处理 CMake 对源码的设置</span><br><span class="line">configure_file (</span><br><span class="line">    "${PROJECT_SOURCE_DIR}/config.h.in"</span><br><span class="line">    "${PROJECT_BINARY_DIR}/config.h"</span><br><span class="line">    )</span><br><span class="line"># 是否使用自己的 MathFunctions 库</span><br><span class="line">option (USE_MYMATH</span><br><span class="line">        "Use provided math implementation" ON)</span><br><span class="line"># 是否加入 MathFunctions 库</span><br><span class="line">if (USE_MYMATH)</span><br><span class="line">    include_directories ("${PROJECT_SOURCE_DIR}/math")</span><br><span class="line">    add_subdirectory (math)</span><br><span class="line">    set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)</span><br><span class="line">endif (USE_MYMATH)</span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo ${DIR_SRCS})</span><br><span class="line">target_link_libraries (Demo ${EXTRA_LIBS})</span><br></pre></td></tr></tbody></table></figure><ul><li>configure_file 命令用于加入一个配置头文件 config.h ，这个文件由 cmake 从 config.h.in 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。</li><li>option 命令添加了一个 USE_MYMATH 选项，并且默认值为 ON 。根据 USE_MYMATH 变量的值来决定是否使用我们自己编写的 MathFunctions 库。修改 main.cc 文件，让其根据 USE_MYMATH 的预定义值来决定是否调用标准库还是MathFunctions 库：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include "config.h"</span><br><span class="line">#ifdef USE_MYMATH</span><br><span class="line">    #include "math/MathFunctions.h"</span><br><span class="line">#else</span><br><span class="line">    #include &lt;math.h&gt;</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">{</span><br><span class="line">    if (argc &lt; 3){</span><br><span class="line">        printf("Usage: %s base exponent \n", argv[0]);</span><br><span class="line">        return 1;</span><br><span class="line">    }</span><br><span class="line">    double base = atof(argv[1]);</span><br><span class="line">    int exponent = atoi(argv[2]);</span><br><span class="line"> </span><br><span class="line">#ifdef USE_MYMATH</span><br><span class="line">    printf("Now we use our own Math library. \n");</span><br><span class="line">    double result = power(base, exponent);</span><br><span class="line">#else</span><br><span class="line">    printf("Now we use the standard library. \n");</span><br><span class="line">    double result = pow(base, exponent);</span><br><span class="line">#endif</span><br><span class="line">    printf("%g ^ %d is %g\n", base, exponent, result);</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编写 config.h.in 文件<br>        注意 main.cc 的第一行，这里引用了一个 config.h 文件，这个文件预定义了 USE_MYMATH 的值。但我们并不直接编写这个文件，为了方便从 CMakeLists.txt 中导入配置，我们编写一个 config.h.in 文件，内容如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#cmakedefine USE_MYMATH</span><br></pre></td></tr></tbody></table></figure><p>这样 cmake 会自动根据 CMakeLists.txt 配置文件中的设置自动生成 config.h 文件。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>note hexo</title>
      <link href="/2022/04/24/note-hexo/"/>
      <url>/2022/04/24/note-hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="一、常用命令"><a href="#一、常用命令" class="headerlink" title="一、常用命令"></a>一、常用命令</h2><h3 id="hexo-init"><a href="#hexo-init" class="headerlink" title="hexo init"></a>hexo init</h3><p><code>hexo init</code> 命令用于初始化本地文件夹为网站的根目录</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></tbody></table></figure><h3 id="Hexo-s"><a href="#Hexo-s" class="headerlink" title="Hexo s"></a>Hexo s</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure><p>启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/">http://localhost:4000/</a></p><ul><li>hexo s 是 hexo server 的缩写，命令效果一致；</li><li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</li><li>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。</li></ul><h3 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a><strong>hexo new</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new "学习笔记  六"  //hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></tbody></table></figure><p>新建一篇标题为 学习笔记 六 的文章，因为标题里有空格，所以加上了引号。</p><ul><li>文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。</li><li><code>layout</code>指定文章的布局，默认<code>Post</code> ，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局</li><li>此命令会在/source/_posts下创建一个文件名 <code>title.md</code>文件，然后就可以使用<code>markdown</code>编辑器开始写自己的博客了。</li></ul><h3 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a><strong>hexo d</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></tbody></table></figure><p>自动生成网站静态文件，并部署到设定的仓库（<a href="https://moomq.github.io/%EF%BC%89%E3%80%82">https://moomq.github.io/）。</a></p><ul><li>hexo d 是 hexo deploy 的缩写，命令效果一致。</li></ul><h3 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a><strong>hexo clean</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></tbody></table></figure><p>清除缓存文件 db.json 和已生成的静态文件 public 。</p><ul><li>网站显示异常时可以执行这条命令试试。</li></ul><h3 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a><strong>hexo g</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></tbody></table></figure><p>生成网站静态文件到默认设置的 public 文件夹。</p><ul><li>便于查看网站生成的静态文件或者手动部署网站；</li><li>如果使用自动部署，不需要先执行该命令；</li><li>hexo g 是 hexo generate 的缩写，命令效果一致。</li></ul><h3 id="hexo-new-page"><a href="#hexo-new-page" class="headerlink" title="hexo new page"></a><strong>hexo new page</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page aboutme</span><br></pre></td></tr></tbody></table></figure><p>新建一个标题为 aboutme 的页面，默认链接地址为 主页地址/aboutme/</p><ul><li>标题可以为中文，但一般习惯用英文；</li><li>页面标题和文章一样可以随意修改；</li><li>页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。</li></ul><h3 id="hexo-–safe"><a href="#hexo-–safe" class="headerlink" title="hexo –safe"></a>hexo –safe</h3><p><code>hexo --safe</code> 表示安全模式，用于禁用加载插件和脚本，<strong>安装新插件时遇到问题可尝试此操作</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></tbody></table></figure><h3 id="hexo-–debug"><a href="#hexo-–debug" class="headerlink" title="hexo –debug"></a>hexo –debug</h3><p><code>hexo --debug</code> 表示调试模式，用于将消息详细记录到终端和 <code>debug.log</code> 文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></tbody></table></figure><h3 id="hexo-–silent"><a href="#hexo-–silent" class="headerlink" title="hexo –silent"></a>hexo –silent</h3><p><code>hexo --silent</code> 表示静默模式，用于静默输出到终端</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></tbody></table></figure><h2 id="二、Hexo图片显示"><a href="#二、Hexo图片显示" class="headerlink" title="二、Hexo图片显示"></a>二、Hexo图片显示</h2><p>1.安装依赖</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></tbody></table></figure><p>2.config配置</p><p>​        把_config.yml中的post_asset_folder设为true，这个配置的意思是每次new post一个博客，会增加一个和博客同名的文件夹。</p><p>3.图片拷贝和引用</p><p>将图片拷贝到与博客同名的文件夹，然后按如下相对路径引用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片描述]（./博客名/NO.01.001.jpg）</span><br></pre></td></tr></tbody></table></figure><p>4.保存和generator</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp; hexo g &amp; hexo s</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my first blog</title>
      <link href="/2021/10/27/my-first-blog/"/>
      <url>/2021/10/27/my-first-blog/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/24/hello-world/"/>
      <url>/2021/10/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
