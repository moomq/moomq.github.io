<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ThreadPool</title>
      <link href="/2022/04/28/threadpool/"/>
      <url>/2022/04/28/threadpool/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h1><h3 id="一、背景："><a href="#一、背景：" class="headerlink" title="一、背景："></a><strong>一、背景：</strong></h3><p>​        手动创建多个线程，会消耗过多内存且耗时长，最重要的是，频繁创建线程，在任务执行完毕之后被回收，对GC也有一定的压力。</p><p>​        线程池：创建线程变成了从线程池获取空闲的线程，关闭线程变成了向池子中归还线程。合理地使用线程池能够带来三个好处：</p><p>(1)降低内存资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>(2)提高响应速度。在线程池中的线程都是已经被创建好的，我们的任务直接获取一个空闲的线程就能够被执行了。</p><p>(3)提高线程的可管理性。使用线程池可以进行统一分配、调优和监控。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性。</p><h3 id="二、进程和线程"><a href="#二、进程和线程" class="headerlink" title="二、进程和线程"></a>二、<strong>进程和线程</strong></h3><p><strong>进程</strong>：在操作系统中能够独立运行，并且作为资源分配的基本单位，是应用程序的可执行单元(*.exe文件)  。一个应用程序可以有多个进程,每个进程都有独立的运行内存空间。系统运行一个应用程序就是一个进程从创建、运行到消亡的过程。</p><p><strong>线程</strong>：是一个比进程更小的执行单位，<strong>是进程的可执行单元</strong>, 也被称为轻量级进程。</p><p>一个进程可以有多个线程,每个线程都有独立的运行内存空间</p><h3 id="三、并行和并发"><a href="#三、并行和并发" class="headerlink" title="三、并行和并发"></a>三、<strong>并行和并发</strong></h3><p><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（<strong>同时执行</strong>）。</p><p><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生(<strong>交替执行</strong>)。</p><h3 id="四、线程池Thread-Pool"><a href="#四、线程池Thread-Pool" class="headerlink" title="四、线程池Thread Pool"></a>四、线程池Thread Pool</h3><p>​        线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后 启动这些任务，如果线程数量超过了最大数量   超出数量的线程排队等候   ，等其它线程执行完毕， 再从队列中取出任务来执行。  </p><p>   他的主要特点为：线程复用；控制最大并发数；管理线程   。  </p><p>  一般的线程池主要分为以下 4 个组成部分： </p><ol><li>线程池管理器：用于创建并管理线程池  </li><li>工作线程：线程池中的线程  </li><li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行  </li><li>任务队列：用于存放待处理的任务，提供一种缓冲机制 </li></ol><p>线程池作用：限制系统中执行线程的数量</p><h3 id="五、线程池作用"><a href="#五、线程池作用" class="headerlink" title="五、线程池作用"></a>五、线程池作用</h3><p>线程池主要作用为限制系统中执行线程的数量</p><ol><li><strong>降低资源消耗</strong>。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 </li></ol><h3 id="六、线程池工作的四种情况"><a href="#六、线程池工作的四种情况" class="headerlink" title="六、线程池工作的四种情况"></a><strong>六、线程池工作的四种情况</strong></h3><h4 id="1-主程序当前没有任务要执行，线程池中的任务队列为空闲状态"><a href="#1-主程序当前没有任务要执行，线程池中的任务队列为空闲状态" class="headerlink" title="1.主程序当前没有任务要执行，线程池中的任务队列为空闲状态"></a>1.<strong>主程序当前没有任务要执行，线程池中的任务队列为空闲状态</strong></h4><p>此情况下所有工作线程处于空闲的等待状态，任务缓冲队列为空</p><p><img src="./ThreadPool/1.png"></p><h4 id="2、主程序添加小于等于线程池中线程数量的任务"><a href="#2、主程序添加小于等于线程池中线程数量的任务" class="headerlink" title="2、主程序添加小于等于线程池中线程数量的任务."></a>2、主程序添加小于等于线程池中线程数量的任务.</h4><p>此情况基于情形1，所有工作线程已处在等待状态，主线程开始添加三个任务，添加后通知(notif())唤醒线程池中的线程开始取(take())任务执行. 此时的任务缓冲队列还是空。</p><p><img src="./ThreadPool/2.png"></p><h4 id="3、主程序添加任务数量大于当前线程池中线程数量的任务"><a href="#3、主程序添加任务数量大于当前线程池中线程数量的任务" class="headerlink" title="3、主程序添加任务数量大于当前线程池中线程数量的任务."></a>3、主程序添加任务数量大于当前线程池中线程数量的任务.</h4><p>此情况发生情形2后面，所有工作线程都在工作中，主线程开始添加第四个任务，添加后发现现在线程池中的线程用完了,于是存入任务缓冲队列。工作线程空闲后主动从任务队列取任务执行.</p><p><img src="./ThreadPool/3.png"></p><h4 id="4、主程序添加任务数量大于当前线程池中线程数量的任务-且任务缓冲队列已满"><a href="#4、主程序添加任务数量大于当前线程池中线程数量的任务-且任务缓冲队列已满" class="headerlink" title="4、主程序添加任务数量大于当前线程池中线程数量的任务,且任务缓冲队列已满."></a>4、主程序添加任务数量大于当前线程池中线程数量的任务,且任务缓冲队列已满.</h4><p>此情况发生情形3且设置了任务缓冲队列大小后面，主程序添加第N个任务，添加后发现池子中的线程用完了，任务缓冲队列也满了，于是进入等待状态、等待任务缓冲队列中的任务腾空通知。<br>但是要注意这种情形会阻塞主线程,本篇暂不限制任务队列大小,必要时再来优化.</p><p><img src="./ThreadPool/4.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadPool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/28/ic-it-gai-nian/"/>
      <url>/2022/04/28/ic-it-gai-nian/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">title: IC&amp;IT概念date: 2022-04-08 16:22:20author: qqmoimg:categories: 编程笔记tags:  - 概念<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="IC-amp-IT概念"><a href="#IC-amp-IT概念" class="headerlink" title="IC&amp;IT概念"></a>IC&amp;IT概念</h2><ol><li><p><strong>操作系统</strong>（Operating System，OS）：是管理计算机硬件与软件资源的系统软件，同时也是计算机系统的内核与基石。操作系统需要处理管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p></li><li><p><strong>shell</strong>：它是一个程序，可从键盘获取命令并将其提供给操作系统以执行。在过去，它是类似 Unix 的系统上唯一可用的用户界面。如今，除了命令行界面（CLI）外，我们还具有图形用户界面（GUI）。</p></li><li><p><strong>GUI</strong> (Graphical User Interface)：是一种用户界面，允许用户通过图形图标和音频指示符与电子设备进行交互。</p></li><li><p><strong>内核模式</strong>（kernel mode）: 通常也被称为 超级模式（supervisor mode），在内核模式下，正在执行的代码具有对底层硬件的完整且不受限制的访问。它可以执行任何 CPU 指令并引用任何内存地址。内核模式通常保留给操作系统的最低级别，最受信任的功能。内核模式下的崩溃是灾难性的；他们将停止整个计算机。超级用户模式是计算机开机时选择的自动模式。</p></li><li><p><strong>用户模式</strong>（user node）：当操作系统运行用户应用程序（例如处理文本编辑器）时，系统处于用户模式。当应用程序请求操作系统的帮助或发生中断或系统调用时，就会发生从用户模式到内核模式的转换。在用户模式下，模式位设置为1。从用户模式切换到内核模式时，它从1更改为0。</p></li><li><p><strong>计算机架构</strong>(computer architecture) ：在计算机工程中，计算机体系结构是描述计算机系统功能，组织和实现的一组规则和方法。它主要包括指令集、内存管理、I/O 和总线结构。</p></li><li><p><strong>SATA</strong>(Serial ATA)：串行 ATA (Serial Advanced Technology Attachment)，它是一种电脑总线，负责主板和大容量存储设备（如硬盘及光盘驱动器）之间的数据传输，主要用于个人电脑。</p></li><li><p><strong>复用</strong>(multiplexing)：也称为共享，在操作系统中主要指示了时间和空间的管理。对资源进行复用时，不同的程序或用户轮流使用它。他们中的第一个开始使用资源，然后再使用另一个，依此类推。</p></li><li><p><strong>大型机</strong>(mainframes)：大型机是一类计算机，通常以其大尺寸，存储量，处理能力和高度的可靠性而著称。它们主要由大型组织用于需要大量数据处理的关键任务应用程序。</p></li><li><p><strong>批处理</strong>(batch system): 批处理操作系统的用户不直接与计算机进行交互。每个用户都在打孔卡等脱机设备上准备工作，并将其提交给计算机操作员。为了加快处理速度，将具有类似需求的作业一起批处理并成组运行。程序员将程序留给操作员，然后操作员将具有类似要求的程序分批处理。</p></li><li><p><strong>OS/360</strong>：OS/360，正式称为IBM System / 360操作系统，是由 IBM 为 1964 年发布的其当时新的System/360 大型机开发的已停产的批处理操作系统。</p></li><li><p><strong>多处理系统</strong>(Computer multitasking)：是指计算机同时运行多个程序的能力。多任务的一般方法是运行第一个程序的一段代码，保存工作环境；再运行第二个程序的一段代码，保存环境；……恢复第一个程序的工作环境，执行第一个程序的下一段代码。</p></li><li><p><strong>分时系统</strong>(Time-sharing)：在计算中，分时是通过多程序和多任务同时在许多用户之间共享计算资源的一种系统</p></li><li><p><strong>相容分时系统</strong>(Compatible Time-Sharing System)：最早的分时操作系统，由美国麻省理工学院计算机中心设计与实作。</p></li><li><p><strong>云计算</strong>(cloud computing)：云计算是计算机系统资源（尤其是数据存储和计算能力）的按需可用性，而无需用户直接进行主动管理。这个术语通常用于描述 Internet 上可供许多用户使用的数据中心。如今占主导地位的大型云通常具有从中央服务器分布在多个位置的功能。如果与用户的连接相对较近，则可以将其指定为边缘服务器。</p></li><li><p><strong>UNIX 操作系统</strong>：UNIX 操作系统，是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统。</p></li><li><p><strong>UNIX System V</strong>：是 UNIX 操作系统的一个分支。</p></li><li><p><strong>BSD</strong>(Berkeley Software Distribution)：UNIX 的衍生系统。</p></li><li><p><strong>POSIX</strong>：可移植操作系统接口，是 IEEE 为要在各种 UNIX 操作系统上运行软件，而定义API的一系列互相关联的标准的总称。</p></li><li><p><strong>MINIX</strong>：Minix，是一个迷你版本的类 UNIX 操作系统。</p></li><li><p><strong>Linux</strong>：终于到了大名鼎鼎的 Linux 操作系统了，太强大了，不予以解释了，大家都懂。</p></li><li><p><strong>DOS</strong> (Disk Operating System)：磁盘操作系统（缩写为DOS）是可以使用磁盘存储设备（例如软盘，硬盘驱动器或光盘）的计算机操作系统。</p></li><li><p><strong>MS-DOS</strong>(MicroSoft Disk Operating System) ：一个由美国微软公司发展的操作系统，运行在Intel x86个人电脑上。它是DOS操作系统家族中最著名的一个，在Windows 95以前，DOS是IBM PC及兼容机中的最基本配备，而MS-DOS则是个人电脑中最普遍使用的DOS操作系统。</p></li><li><p><strong>MacOS X</strong>，怎能少的了苹果操作系统？macOS 是苹果公司推出的基于图形用户界面操作系统，为 Macintosh 的主操作系统。</p></li><li><p><strong>Windows NT</strong>(Windows New Technology)：是美国微软公司 1993 年推出的纯 32 位操作系统核心。</p></li><li><p><strong>Service Pack</strong>(SP)：是程序的更新、修复和（或）增强的集合，以一个独立的安装包的形式发布。许多公司，如微软或Autodesk，通常在为某一程序而做的修补程序达到一定数量时，就发布一个Service Pack。</p></li><li><p><strong>数字版权管理</strong>（DRM）：他是工具或技术保护措施（TPM）是一组访问控制技术，用于限制对专有硬件和受版权保护的作品的使用。</p></li><li><p><strong>x86</strong>：x86是一整套指令集体系结构，由 Intel 最初基于 Intel 8086 微处理器及其 8088 变体开发。采用内存分段作为解决方案，用于处理比普通 16 位地址可以覆盖的更多内存。32 位是 x86 默认的位数，除此之外，还有一个 x86-64 位，是x86架构的 64 位拓展，向后兼容于 16 位及 32 位的 x86架构。</p></li><li><p><strong>FreeBSD</strong>：FreeBSD 是一个类 UNIX 的操作系统，也是 FreeBSD 项目的发展成果。</p></li><li><p><strong>X Window System</strong>：X 窗口系统（X11，或简称X）是用于位图显示的窗口系统，在类 UNIX 操作系统上很常见。</p></li><li><p><strong>Gnome</strong>：GNOME 是一个完全由自由软件组成的桌面环境。它的目标操作系统是Linux，但是大部分的 BSD 系统亦支持 GNOME。</p></li><li><p><strong>网络操作系统</strong>(network operating systems)：网络操作系统是用于网络设备（如路由器，交换机或防火墙）的专用操作系统。</p></li><li><p><strong>分布式网络系统</strong>(distributed operating systems)：分布式操作系统是在独立，网络，通信和物理上独立计算节点的集合上的软件。它们处理由多个CPU服务的作业。每个单独的节点都拥有全局集合操作系统的特定软件的一部分。</p></li><li><p><strong>程序计数器</strong>(Program counter)：程序计数器 是一个 CPU 中的寄存器，用于指示计算机在其程序序列中的位置。</p></li><li><p><strong>堆栈寄存器</strong>(stack pointer)：堆栈寄存器是计算机 CPU 中的寄存器，其目的是跟踪调用堆栈。</p></li><li><p><strong>程序状态字</strong>(Program Status Word): 它是由操作系统维护的8个字节（或64位）长的数据的集合。它跟踪系统的当前状态。</p></li><li><p><strong>流水线</strong>(Pipeline): 在计算世界中，管道是一组串联连接的数据处理元素，其中一个元素的输出是下一个元素的输入。流水线的元素通常以并行或按时间分割的方式执行。通常在元素之间插入一定数量的缓冲区存储。</p></li><li><p><strong>超标量</strong>(superscalar)：超标量 CPU 架构是指在一颗处理器内核中实行了指令级并发的一类并发运算。这种技术能够在相同的CPU主频下实现更高的 CPU 流量。</p></li><li><p><strong>系统调用</strong>(system call):  指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态运行。如设备 IO 操作或者进程间通信。</p></li><li><p><strong>多线程</strong>(multithreading)：是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因为有硬件支持而能够在同一时间执行多个线程，进而提升整体处理性能。</p></li><li><p><strong>CPU 核心</strong>(core)：它是 CPU 的大脑，它接收指令，并执行计算或运算以满足这些指令。一个 CPU 可以有多个内核。</p></li><li><p><strong>图形处理器</strong>(Graphics Processing Unit)：又称显示核心、视觉处理器、显示芯片或绘图芯片；它是一种专门在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上运行绘图运算工作的微处理器。</p></li><li><p><strong>存储体系结构</strong>：顶层的存储器速度最高，但是容量最小，成本非常高，层级结构越向下，其访问效率越慢，容量越大，但是造价也就越便宜。</p></li><li><p><strong>高速缓存行</strong>(cache lines)：其实就是把高速缓存分割成了固定大小的块，其大小是以突发读或者突发写周期的大小为基础的。</p></li></ol><p><img src="./IC&amp;IT%E6%A6%82%E5%BF%B5/1.png" alt="1"></p><ol start="45"><li><strong>缓存命中</strong>(cache hit)：当应用程序或软件请求数据时，会首先发生缓存命中。首先，中央处理单元（CPU）在其最近的内存位置（通常是主缓存）中查找数据。如果在缓存中找到请求的数据，则将其视为缓存命中。</li></ol><p><img src=".%5CIC&amp;IT%E6%A6%82%E5%BF%B5%5C2.png" alt="2"></p><ol start="46"><li><p><strong>L1 cache</strong>：一级缓存是 CPU 芯片中内置的存储库。L1缓存也称为主缓存，是计算机中最快的内存，并且最接近处理器。</p></li><li><p><strong>L2 cache</strong>: 二级缓存存储库，内置在 CPU 芯片中，包装在同一模块中，或者建在主板上。L2 高速缓存提供给 L1 高速缓存，后者提供给处理器。L2 内存比 L1 内存慢。</p></li><li><p><strong>L3 cache</strong>: 三级缓存内置在主板上或CPU模块内的存储库。L3 高速缓存为 L2 高速缓存提供数据，其内存通常比 L2 内存慢，但比主内存快。L3 高速缓存提供给 L2 高速缓存，后者又提供给 L1 高速缓存，后者又提供给处理器。</p></li><li><p><strong>RAM</strong>(Random Access Memory)：随机存取存储器，也叫主存，是与 CPU 直接交换数据的内部存储器。它可以随时读写，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质。RAM工作时可以随时从任何一个指定的地址写入（存入）或读出（取出）信息。它与 ROM 的最大区别是数据的易失性，即一旦断电所存储的数据将随之丢失。RAM 在计算机和数字系统中用来暂时存储程序、数据和中间结果。</p></li><li><p><strong>ROM</strong> (Read Only Memory)：只读存储器是一种半导体存储器，其特性是一旦存储数据就无法改变或删除，且内容不会因为电源关闭而消失。在电子或电脑系统中，通常用以存储不需经常变更的程序或数据。</p></li><li><p><strong>EEPROM</strong> (Electrically Erasable PROM)：电可擦除可编程只读存储器，是一种可以通过电子方式多次复写的半导体存储设备。</p></li><li><p><strong>闪存</strong>(flash memory)：是一种电子式可清除程序化只读存储器的形式，允许在操作中被多次擦或写的存储器。这种科技主要用于一般性数据存储，以及在电脑与其他数字产品间交换传输数据，如储存卡与U盘。</p></li><li><p><strong>SSD</strong>(Solid State Disks)：固态硬盘，是一种主要以闪存作为永久性存储器的电脑存储设备。</p></li><li><p><strong>虚拟地址</strong>(virtual memory)：虚拟内存是计算机系统内存管理的一种机制。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。</p></li><li><p><strong>MMU</strong> (Memory Management Unit)：内存管理单元，有时称作分页内存管理单元。它是一种负责处理中央处理器（CPU）的内存访问请求的计算机硬件。它的功能包括虚拟地址到物理地址的转换（即虚拟内存管理）、内存保护、中央处理器高速缓存的控制等。</p></li><li><p><strong>context switch</strong>：上下文切换，又称环境切换。是一个存储和重建 CPU 状态的机制。要交换 CPU 上的进程时，必须先行存储当前进程的状态，然后再将进程状态读回 CPU 中。</p></li><li><p><strong>驱动程序</strong>(device driver)：设备驱动程序，简称驱动程序（driver），是一个允许高级别电脑软件与硬件交互的程序，这种程序创建了一个硬件与硬件，或硬件与软件沟通的接口，经由主板上的总线或其它沟通子系统与硬件形成连接的机制，这样使得硬件设备上的数据交换成为可能。</p></li></ol><p>\58. <strong>忙等</strong>(busy waiting)：在软件工程中，忙碌等待也称自旋，是一种以进程反复检查一个条件是否为真的条件，这种机制可能为检查键盘输入或某个锁是否可用。</p><ol start="59"><li><p><strong>中断</strong>(Interrupt)：通常，在接收到来自外围硬件（相对于中央处理器和内存）的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件／软件处理。发出这样的信号称为进行中断请求（interrupt request，IRQ）。硬件中断导致处理器通过一个运行信息切换（context switch）来保存执行状态（以程序计数器和程序状态字等寄存器信息为主）；软件中断则通常作为 CPU 指令集中的一个指令，以可编程的方式直接指示这种运行信息切换，并将处理导向一段中断处理代码。中断在计算机多任务处理，尤其是即时系统中尤为有用。</p></li><li><p><strong>中断向量</strong>(interrupt vector)：中断向量位于中断向量表中。中断向量表（IVT）是将中断处理程序列表与中断向量表中的中断请求列表相关联的数据结构。中断向量表的每个条目（称为中断向量）都是中断处理程序的地址。</p></li><li><p><strong>DMA</strong> (Direct Memory Access)：直接内存访问，直接内存访问是计算机科学中的一种内存访问技术。它允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，而不需中央处理器（CPU）介入处理 。</p></li></ol><p>\62. <strong>总线</strong>(Bus)：总线（Bus）是指计算机组件间规范化的交换数据的方式，即以一种通用的方式为各组件提供数据传送和控制逻辑。</p><ol start="63"><li><p><strong>PCIe</strong> (Peripheral Component Interconnect Express)：官方简称PCIe，是计算机总线的一个重要分支，它沿用现有的PCI编程概念及信号标准，并且构建了更加高速的串行通信系统标准。</p></li><li><p><strong>DMI</strong> (Direct Media Interface)：直接媒体接口，是英特尔专用的总线，用于电脑主板上南桥芯片和北桥芯片之间的连接。</p></li><li><p><strong>USB</strong>(Universal Serial Bus)：是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范，被广泛地应用于个人电脑和移动设备等信息通讯产品，并扩展至摄影器材、数字电视（机顶盒）、游戏机等其它相关领域。</p></li><li><p><strong>BIOS</strong>(Basic Input Output System)：是在通电引导阶段运行硬件初始化，以及为操作系统提供运行时服务的固件。它是开机时运行的第一个软件。</p></li><li><p><strong>硬实时系统</strong>(hard real-time system)：硬实时性意味着你必须绝对在每个截止日期前完成任务。很少有系统有此要求。例如核系统，一些医疗应用（例如起搏器），大量国防应用，航空电子设备等。</p></li><li><p><strong>软实时系统</strong>(soft real-time system)：软实时系统可能会错过某些截止日期，但是如果错过太多，最终性能将下降。一个很好的例子是计算机中的声音系统。</p></li><li><p><strong>进程</strong>(Process)：程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。若进程有可能与同一个程序相关系，且每个进程皆可以同步（循序）或异步的方式独立运行。</p></li><li><p><strong>地址空间</strong>(address space)：地址空间是内存中可供程序或进程使用的有效地址范围。也就是说，它是程序或进程可以访问的内存。存储器可以是物理的也可以是虚拟的，用于执行指令和存储数据。</p></li><li><p><strong>进程表</strong>(process table)：进程表是操作系统维护的数据结构，该表中的每个条目（通常称为上下文块）均包含有关进程的信息，例如进程名称和状态，优先级，寄存器以及它可能正在等待的信号灯。</p></li><li><p><strong>命令行界面</strong>(command-line interpreter)：是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。</p></li><li><p><strong>进程间通信</strong>(interprocess communication)：指至少两个进程或线程间传送数据或信号的一些技术或方法。</p></li><li><p><strong>超级用户</strong>(superuser)：也被称为管理员帐户，在计算机操作系统领域中指一种用于进行系统管理的特殊用户，其在系统中的实际名称也因系统而异，如 root、administrator 与supervisor。</p></li><li><p><strong>目录</strong>(directory):  在计算机或相关设备中，一个目录或文件夹就是一个装有数字文件系统的虚拟容器。在它里面保存着一组文件和其它一些目录。</p></li><li><p><strong>路径</strong>(path name)：路径是一种电脑文件或目录的名称的通用表现形式，它指向文件系统上的一个唯一位置。</p></li><li><p><strong>根目录</strong>(root directory)：根目录指的就是计算机系统中的顶层目录，比如 Windows 中的 C 盘和 D 盘，Linux 中的 /。</p></li><li><p><strong>工作目录</strong>(Working directory)：它是一个计算机用语。用户在操作系统内所在的目录，用户可在此目录之下，用相对文件名访问文件。</p></li><li><p><strong>文件描述符</strong>(file descriptor)：文件描述符是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p></li><li><p><strong>inode</strong>：索引节点的缩写，索引节点是 UNIX 系统中包含的信息，其中包含有关每个文件的详细信息，例如节点，所有者，文件，文件位置等。</p></li><li><p><strong>共享库</strong>(shared library)：共享库是一个包含目标代码的文件，执行过程中多个 a.out 文件可能会同时使用该目标代码。</p></li><li><p><strong>DLLs</strong> (Dynamic-Link Libraries)：动态链接库，它是微软公司在操作系统中实现共享函数库概念的一种实现方式。这些库函数的扩展名是 .DLL、.OCX（包含ActiveX控制的库）或者.DRV（旧式的系统驱动程序）。</p></li><li><p><strong>客户端</strong>(clients)：客户端是访问服务器提供的服务的计算机硬件或软件。</p></li><li><p><strong>服务端</strong>(servers)：在计算中，服务器是为其他程序或设备提供功能的计算机程序或设备，称为服务端</p></li><li><p><strong>主从架构</strong>(client-server)：主从式架构也称客户端/服务器架构、C/S 架构，是一种网络架构，它把客户端与服务器区分开来。每一个客户端软件的实例都可以向一个服务器或应用程序服务器发出请求。有很多不同类型的服务器，例如文件服务器、游戏服务器等。</p></li><li><p><strong>虚拟机</strong>(Virtual Machines)：在计算机科学中的体系结构里，是指一种特殊的软件，可以在计算机平台和终端用户之间创建一种环境，而终端用户则是基于虚拟机这个软件所创建的环境来操作其它软件。</p></li><li><p><strong>Java 虚拟机</strong>(Java virtual Machines)：Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p></li><li><p><strong>目标文件</strong>(object file)：目标文件是包含目标代码的文件，这意味着通常无法直接执行的可重定位格式的机器代码。目标文件有多种格式，相同的目标代码可以打包在不同的目标文件中。目标文件也可以像共享库一样工作。</p></li><li><p><strong>C preprocessor</strong>：C 预处理器是 C 语言、C++ 语言的预处理器。用于在编译器处理程序之前预扫描源代码，完成头文件的包含, 宏扩展, 条件编译, 行控制等操作。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows下使用MinGW编译boost库</title>
      <link href="/2022/04/15/windows-xia-shi-yong-mingw-bian-yi-boost-ku/"/>
      <url>/2022/04/15/windows-xia-shi-yong-mingw-bian-yi-boost-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows下使用MinGW编译boost库"><a href="#Windows下使用MinGW编译boost库" class="headerlink" title="Windows下使用MinGW编译boost库"></a>Windows下使用MinGW编译boost库</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>​        解压并打开boost源码目录，</p><pre class="line-numbers language-none"><code class="language-none">call .\build.bat 改成 call .\build.bat gccSET TOOLSET=msvc 改成 SET TOOLSET=gcc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        执行bootstrap.bat批处理文件，会在目录内产生一个b2.exe文件。在目录文件夹，按住shift键+鼠标右键，选择“在此处打开PowerShell窗口”（或“在此处打开控制台窗口”），执行指令：</p><pre class="line-numbers language-none"><code class="language-none">./b2.exe --help <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会列出关于boost的编译选项，其主要选项如下：</p><pre class="line-numbers language-none"><code class="language-none">--prefix=&lt;PREFIX&gt;   编译后安装路径，默认C:\Boost--build-type=&lt;type&gt; 编译类型，可选minimal（最小）、complete（完整），默认minimal。--with-&lt;library&gt;    加入此参数，代表只编译的库。--without-&lt;library&gt; 加入此参数，代表忽略编译的库。toolset             编译器，win下默认msvc，用MinGW则选择gcc。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此编译参数可设置为：</p><pre class="line-numbers language-none"><code class="language-none">./b2.exe install --prefix=E:\boost\boost_1_76_0_mingw --build-type=complete toolset=gcc threading=multi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数解析：完整编译（会编译包含/不包含运行时库的debug/release的动态/静态库），编译器选择MinGW（gcc），多线程，编译完成后将库和头文件复制到D:\boost\boost_1.65.1_mingw路径。</p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> boost </tag>
            
            <tag> MinGW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread.sleep(0)的作用</title>
      <link href="/2022/04/14/thread.sleep-0-de-zuo-yong/"/>
      <url>/2022/04/14/thread.sleep-0-de-zuo-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Thread-sleep-0-的作用"><a href="#Thread-sleep-0-的作用" class="headerlink" title="Thread.sleep(0)的作用"></a>Thread.sleep(0)的作用</h1><p>我们可能经常会用到 Thread.Sleep 函数来吧使线程挂起一段时间。那么你有没有正确的理解这个函数的用法呢？<br>思考下面这两个问题：</p><p>假设现在是 2008-4-7 12:00:00.000，如果我调用一下 Thread.Sleep(1000) ，在 2008-4-7 12:00:01.000 的时候，这个线程会不会被唤醒？</p><p>某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？</p><p>我们先回顾一下操作系统原理。</p><p>操作系统中，CPU竞争有很多种策略。Unix系统使用的是时间片算法，而Windows则属于抢占式的。</p><p>在时间片算法中，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程 序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。</p><p>所谓抢占式操作系统，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。因此可以看出，在抢 占式操作系统中，操作系统假设所有的进程都是“人品很好”的，会主动退出 CPU 。</p><p>在抢占式操作系统中，假设有若干进程，操作系统会根据他们的优先级、饥饿时间（已经多长时间没有使用过 CPU 了），给他们算出一 个总的优先级来。操作系统就会把 CPU 交给总优先级最高的这个进程。当进程执行完毕或者自己主动挂起后，操作系统就会重新计算一 次所有进程的总优先级，然后再挑一个优先级最高的把 CPU 控制权交给他。</p><p>我们用分蛋糕的场景来描述这两种算法。假设有源源不断的蛋糕（源源不断的时间），一副刀叉（一个CPU），10个等待吃蛋糕的人（10 个进程）。</p><p>如果是 Unix操作系统来负责分蛋糕，那么他会这样定规矩：每个人上来吃 1 分钟，时间到了换下一个。最后一个人吃完了就再从头开始。于是，不管这10个人是不是优先级不同、饥饿程度不同、饭量不同，每个人上来的时候都可以吃 1 分钟。当然，如果有人本来不太饿，或者饭量小，吃了30秒钟之后就吃饱了，那么他可以跟操作系统说：我已经吃饱了（挂起）。于是操作系统就会让下一个人接着来。</p><p>如果是 Windows 操作系统来负责分蛋糕的，那么场面就很有意思了。他会这样定规矩：我会根据你们的优先级、饥饿程度去给你们每个人计算一个优先级。优先级最高的那个人，可以上来吃蛋糕——吃到你不想吃为止。等这个人吃完了，我再重新根据优先级、饥饿程度来计算每个人的优先级，然后再分给优先级最高的那个人。</p><p>这样看来，这个场面就有意思了——可能有些人是PPMM，因此具有高优先级，于是她就可以经常来吃蛋糕。可能另外一个人是个丑男，而去很ws，所以优先级特别低，于是好半天了才轮到他一次（因为随着时间的推移，他会越来越饥饿，因此算出来的总优先级就会越来越高，因此总有一天会轮到他的）。而且，如果一不小心让一个大胖子得到了刀叉，因为他饭量大，可能他会霸占着蛋糕连续吃很久很久，导致旁边的人在那里咽口水。。。</p><p>而且，还可能会有这种情况出现：操作系统现在计算出来的结果，5号PPMM总优先级最高，而且高出别人一大截。因此就叫5号来吃蛋糕。5号吃了一小会儿，觉得没那么饿了，于是说“我不吃了”（挂起）。，因此操作系统就会重新计算所有人的优先级。</p><p>因为5号刚刚吃过，因此她的饥饿程度变小了，于是总优先级变小了；而其他人因为多等了一会儿，饥饿程度都变大了，所以总优先级也变大了。不过这时候仍然有可能5号的优先级比别的都高，只不过现在只比其他的高一点点——但她仍然是总优先级最高的啊。因此操作系统就会说：5号mm上来吃蛋糕……（5号mm心里郁闷，这不刚吃过嘛……人家要减肥……谁叫你长那么漂亮，获得了那么高的优先级）。</p><p>那么，Thread.Sleep 函数是干吗的呢？还用刚才的分蛋糕的场景来描述。上面的场景里面，5号MM在吃了一次蛋糕之后，觉得已经有8分饱了，她觉得在未来的半个小时之内都不想再来吃蛋糕了，那么她就会跟操作系统说：在未来的半个小时之内不要再叫我上来吃蛋糕了。</p><p>这样，操作系统在随后的半个小时里面重新计算所有人总优先级的时候，就会忽略5号mm。Sleep函数就是干这事的，他告诉操作系统“在未来的多少毫秒内我不参与CPU竞争”。</p><p>看完了 Thread.Sleep 的作用，我们再来想想文章开头的两个问题。</p><p>对于第一个问题，答案是：不一定。因为你只是告诉操作系统：在未来的1000毫秒内我不想再参与到CPU竞争。那么1000毫秒过去之后，这时候也许另外一个线程正在使用CPU，那么这时候操作系统是不会重新分配CPU的，直到那个线程挂起或结束；况且，即使这个时候恰巧轮到操作系统进行CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU还是可能被其他线程抢占去。</p><p>与此相似的，Thread有个Resume函数，是用来唤醒挂起的线程的。好像上面所说的一样，这个函数只是“告诉操作系统我从现在起开始参与CPU竞争了”，这个函数的调用并不能马上使得这个线程获得CPU控制权。</p><p>对于第二个问题，答案是：有，而且区别很明显。假设我们刚才的分蛋糕场景里面，有另外一个PPMM 7号，她的优先级也非常非常高（因为非常非常漂亮），所以操作系统总是会叫道她来吃蛋糕。而且，7号也非常喜欢吃蛋糕，而且饭量也很大。不过，7号人品很好，她很善良，她没吃几口就会想：如果现在有别人比我更需要吃蛋糕，那么我就让给他。</p><p>因此，她可以每吃几口就跟操作系统说：我们来重新计算一下所有人的总优先级吧。不过，操作系统不接受这个建议——因为操作系统不提供这个接口。于是7号mm就换了个说法：“在未来的0毫秒之内不要再叫我上来吃蛋糕了”。这个指令操作系统是接受的，于是此时操作系统就会重新计算大家的总优先级——注意这个时候是连7号一起计算的，因为“0毫秒已经过去了”嘛。因此如果没有比7号更需要吃蛋糕的人出现，那么下一次7号还是会被叫上来吃蛋糕。</p><p>因此，Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。这也是我们在大循环里面经常会写一句Thread.Sleep(0) ，因为这样就给了其他线程比如Paint线程获得CPU控制权的权力，这样界面就不会假死在那里。</p><p>另外，虽然上面提到说“除非它自己放弃使用 CPU ，否则将完全霸占 CPU”，但这个行为仍然是受到制约的——操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。至于我们的大循环造成程序假死，并不是因为这个线程一直在霸占着CPU。</p><p>实际上在这段时间操作系统已经进行过多次CPU竞争了，只不过其他线程在获得CPU控制权之后很短时间内马上就退出了，于是就又轮到了这个线程继续执行循环，于是就又用了很久才被操作系统强制挂起。。。因此反应到界面上，看起来就好像这个线程一直在霸占着CPU一样。</p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sleep(0) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Protocol Buffers</title>
      <link href="/2022/04/13/protocol-bian-yi-an-zhuang/"/>
      <url>/2022/04/13/protocol-bian-yi-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="Protocol-Buffers-Google’s-data-interchange-format"><a href="#Protocol-Buffers-Google’s-data-interchange-format" class="headerlink" title="Protocol Buffers - Google’s data interchange format"></a>Protocol Buffers - Google’s data interchange format</h1><p>Copyright 2008 Google Inc.</p><p><a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p><h2 id="C-Installation-Unix"><a href="#C-Installation-Unix" class="headerlink" title="C++ Installation - Unix"></a>C++ Installation - Unix</h2><p>To build protobuf from source, the following tools are needed:</p><ul><li>autoconf</li><li>automake</li><li>libtool</li><li>make</li><li>g++</li><li>unzip</li></ul><p>On Ubuntu/Debian, you can install them with:</p><pre><code>sudo apt-get install autoconf automake libtool curl make g++ unzip</code></pre><p>On other platforms, please use the corresponding package managing tool to<br>install them before proceeding.</p><p>To get the source, download one of the release .tar.gz or .zip packages in the<br>release page:</p><pre><code>https://github.com/protocolbuffers/protobuf/releases/latest</code></pre><p>For example: if you only need C++, download <code>protobuf-cpp-[VERSION].tar.gz</code>; if<br>you need C++ and Java, download <code>protobuf-java-[VERSION].tar.gz</code> (every package<br>contains C++ source already); if you need C++ and multiple other languages,<br>download <code>protobuf-all-[VERSION].tar.gz</code>.</p><p>You can also get the source by “git clone” our git repository. Make sure you<br>have also cloned the submodules and generated the configure script (skip this<br>if you are using a release .tar.gz or .zip package):</p><pre><code>git clone https://github.com/protocolbuffers/protobuf.gitcd protobufgit submodule update --init --recursive./autogen.sh</code></pre><p>To build and install the C++ Protocol Buffer runtime and the Protocol<br>Buffer compiler (protoc) execute the following:</p><pre><code> ./configure make make check sudo make install sudo ldconfig # refresh shared library cache.</code></pre><p>If “make check” fails, you can still install, but it is likely that<br>some features of this library will not work correctly on your system.<br>Proceed at your own risk.</p><p>For advanced usage information on configure and make, please refer to the<br>autoconf documentation:</p><pre><code>http://www.gnu.org/software/autoconf/manual/autoconf.html#Running-configure-Scripts</code></pre><p><strong>Hint on install location</strong></p><p>By default, the package will be installed to /usr/local.  However,<br>on many platforms, /usr/local/lib is not part of LD_LIBRARY_PATH.<br>You can add it, but it may be easier to just install to /usr<br>instead.  To do this, invoke configure as follows:</p><pre><code>./configure --prefix=/usr</code></pre><p>If you already built the package with a different prefix, make sure<br>to run “make clean” before building again.</p><p><strong>Compiling dependent packages</strong></p><p>To compile a package that uses Protocol Buffers, you need to pass<br>various flags to your compiler and linker.  As of version 2.2.0,<br>Protocol Buffers integrates with pkg-config to manage this.  If you<br>have pkg-config installed, then you can invoke it to get a list of<br>flags like so:</p><pre><code>pkg-config --cflags protobuf         # print compiler flagspkg-config --libs protobuf           # print linker flagspkg-config --cflags --libs protobuf  # print both</code></pre><p>For example:</p><pre><code>c++ my_program.cc my_proto.pb.cc `pkg-config --cflags --libs protobuf`</code></pre><p>Note that packages written prior to the 2.2.0 release of Protocol<br>Buffers may not yet integrate with pkg-config to get flags, and may<br>not pass the correct set of flags to correctly link against<br>libprotobuf.  If the package in question uses autoconf, you can<br>often fix the problem by invoking its configure script like:</p><pre><code>configure CXXFLAGS="$(pkg-config --cflags protobuf)" \          LIBS="$(pkg-config --libs protobuf)"</code></pre><p>This will force it to use the correct flags.</p><p>If you are writing an autoconf-based package that uses Protocol<br>Buffers, you should probably use the PKG_CHECK_MODULES macro in your<br>configure script like:</p><pre><code>PKG_CHECK_MODULES([protobuf], [protobuf])</code></pre><p>See the pkg-config man page for more info.</p><p>If you only want protobuf-lite, substitute “protobuf-lite” in place<br>of “protobuf” in these examples.</p><p><strong>Note for Mac users</strong></p><p>For a Mac system, Unix tools are not available by default. You will first need<br>to install Xcode from the Mac AppStore and then run the following command from<br>a terminal:</p><pre><code>sudo xcode-select --install</code></pre><p>To install Unix tools, you can install “port” following the instructions at<br><a href="https://www.macports.org/">https://www.macports.org</a> . This will reside in /opt/local/bin/port for most<br>Mac installations.</p><pre><code>sudo /opt/local/bin/port install autoconf automake libtool</code></pre><p>Then follow the Unix instructions above.</p><p><strong>Note for cross-compiling</strong></p><p>The makefiles normally invoke the protoc executable that they just<br>built in order to build tests.  When cross-compiling, the protoc<br>executable may not be executable on the host machine.  In this case,<br>you must build a copy of protoc for the host machine first, then use<br>the –with-protoc option to tell configure to use it instead.  For<br>example:</p><pre><code>./configure --with-protoc=protoc</code></pre><p>This will use the installed protoc (found in your $PATH) instead of<br>trying to execute the one built during the build process.  You can<br>also use an executable that hasn’t been installed.  For example, if<br>you built the protobuf package for your host machine in ../host,<br>you might do:</p><pre><code>./configure --with-protoc=../host/src/protoc</code></pre><p>Either way, you must make sure that the protoc executable you use<br>has the same version as the protobuf source code you are trying to<br>use it with.</p><p><strong>Note for Solaris users</strong></p><p>Solaris 10 x86 has a bug that will make linking fail, complaining<br>about libstdc++.la being invalid.  We have included a work-around<br>in this package.  To use the work-around, run configure as follows:</p><pre><code>./configure LDFLAGS=-L$PWD/src/solaris</code></pre><p>See src/solaris/libstdc++.la for more info on this bug.</p><p><strong>Note for HP C++ Tru64 users</strong></p><p>To compile invoke configure as follows:</p><pre><code>./configure CXXFLAGS="-O -std ansi -ieee -D__USE_STD_IOSTREAM"</code></pre><p>Also, you will need to use gmake instead of make.</p><p><strong>Note for AIX users</strong></p><p>Compile using the IBM xlC C++ compiler as follows:</p><pre><code>./configure CXX=xlC</code></pre><p>Also, you will need to use GNU <code>make</code> (<code>gmake</code>) instead of AIX <code>make</code>.</p><h2 id="C-Installation-Windows"><a href="#C-Installation-Windows" class="headerlink" title="C++ Installation - Windows"></a>C++ Installation - Windows</h2><p>If you only need the protoc binary, you can download it from the release<br>page:</p><pre><code>https://github.com/protocolbuffers/protobuf/releases/latest</code></pre><p>In the downloads section, download the zip file protoc-$VERSION-win32.zip.<br>It contains the protoc binary as well as public proto files of protobuf<br>library.</p><p>Protobuf and its dependencies can be installed directly by using <code>vcpkg</code>:</p><pre><code>&gt;vcpkg install protobuf protobuf:x64-windows</code></pre><p>If zlib support is desired, you’ll also need to install the zlib feature:</p><pre><code>&gt;vcpkg install protobuf[zlib] protobuf[zlib]:x64-windows</code></pre><p>See <a href="https://github.com/Microsoft/vcpkg">https://github.com/Microsoft/vcpkg</a> for more information.</p><p>To build from source using Microsoft Visual C++, see <a href="../cmake/README.md">cmake/README.md</a>.</p><p>To build from source using Cygwin or MinGW, follow the Unix installation<br>instructions, above.</p><h2 id="Binary-Compatibility-Warning"><a href="#Binary-Compatibility-Warning" class="headerlink" title="Binary Compatibility Warning"></a>Binary Compatibility Warning</h2><p>Due to the nature of C++, it is unlikely that any two versions of the<br>Protocol Buffers C++ runtime libraries will have compatible ABIs.<br>That is, if you linked an executable against an older version of<br>libprotobuf, it is unlikely to work with a newer version without<br>re-compiling.  This problem, when it occurs, will normally be detected<br>immediately on startup of your app.  Still, you may want to consider<br>using static linkage.  You can configure this package to install<br>static libraries only using:</p><pre><code>./configure --disable-shared</code></pre><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>The complete documentation for Protocol Buffers is available via the<br>web at:</p><p><a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Protocol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo</title>
      <link href="/2022/04/12/note-hexo/"/>
      <url>/2022/04/12/note-hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="一、常用命令"><a href="#一、常用命令" class="headerlink" title="一、常用命令"></a>一、常用命令</h2><h3 id="hexo-init"><a href="#hexo-init" class="headerlink" title="hexo init"></a>hexo init</h3><p><code>hexo init</code> 命令用于初始化本地文件夹为网站的根目录</p><pre class="line-numbers language-none"><code class="language-none">$ hexo init [folder]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Hexo-s"><a href="#Hexo-s" class="headerlink" title="Hexo s"></a>Hexo s</h3><pre class="line-numbers language-none"><code class="language-none">$ hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/">http://localhost:4000/</a></p><ul><li>hexo s 是 hexo server 的缩写，命令效果一致；</li><li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</li><li>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。</li></ul><h3 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a><strong>hexo new</strong></h3><pre class="line-numbers language-none"><code class="language-none">$ hexo new "学习笔记  六"  //hexo new [layout] &lt;title&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建一篇标题为 学习笔记 六 的文章，因为标题里有空格，所以加上了引号。</p><ul><li>文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。</li><li><code>layout</code>指定文章的布局，默认<code>Post</code> ，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局</li><li>此命令会在/source/_posts下创建一个文件名 <code>title.md</code>文件，然后就可以使用<code>markdown</code>编辑器开始写自己的博客了。</li></ul><h3 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a><strong>hexo d</strong></h3><pre class="line-numbers language-none"><code class="language-none">$ hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>自动生成网站静态文件，并部署到设定的仓库（<a href="https://moomq.github.io/%EF%BC%89%E3%80%82">https://moomq.github.io/）。</a></p><ul><li>hexo d 是 hexo deploy 的缩写，命令效果一致。</li></ul><h3 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a><strong>hexo clean</strong></h3><pre class="line-numbers language-none"><code class="language-none">$ hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>清除缓存文件 db.json 和已生成的静态文件 public 。</p><ul><li>网站显示异常时可以执行这条命令试试。</li></ul><h3 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a><strong>hexo g</strong></h3><pre class="line-numbers language-none"><code class="language-none">$ hexo g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成网站静态文件到默认设置的 public 文件夹。</p><ul><li>便于查看网站生成的静态文件或者手动部署网站；</li><li>如果使用自动部署，不需要先执行该命令；</li><li>hexo g 是 hexo generate 的缩写，命令效果一致。</li></ul><h3 id="hexo-new-page"><a href="#hexo-new-page" class="headerlink" title="hexo new page"></a><strong>hexo new page</strong></h3><pre class="line-numbers language-none"><code class="language-none">$ hexo new page aboutme<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建一个标题为 aboutme 的页面，默认链接地址为 主页地址/aboutme/</p><ul><li>标题可以为中文，但一般习惯用英文；</li><li>页面标题和文章一样可以随意修改；</li><li>页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。</li></ul><h3 id="hexo-–safe"><a href="#hexo-–safe" class="headerlink" title="hexo –safe"></a>hexo –safe</h3><p><code>hexo --safe</code> 表示安全模式，用于禁用加载插件和脚本，<strong>安装新插件时遇到问题可尝试此操作</strong></p><pre class="line-numbers language-none"><code class="language-none">$ hexo --safe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="hexo-–debug"><a href="#hexo-–debug" class="headerlink" title="hexo –debug"></a>hexo –debug</h3><p><code>hexo --debug</code> 表示调试模式，用于将消息详细记录到终端和 <code>debug.log</code> 文件</p><pre class="line-numbers language-none"><code class="language-none">$ hexo --debug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="hexo-–silent"><a href="#hexo-–silent" class="headerlink" title="hexo –silent"></a>hexo –silent</h3><p><code>hexo --silent</code> 表示静默模式，用于静默输出到终端</p><pre class="line-numbers language-none"><code class="language-none">$ hexo --silent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="二、Hexo图片显示"><a href="#二、Hexo图片显示" class="headerlink" title="二、Hexo图片显示"></a>二、Hexo图片显示</h2><p>1.安装依赖</p><pre class="line-numbers language-none"><code class="language-none">$ npm install https://github.com/CodeFalling/hexo-asset-image --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.config配置</p><p>​        把_config.yml中的post_asset_folder设为true，这个配置的意思是每次new post一个博客，会增加一个和博客同名的文件夹。</p><p>3.图片拷贝和引用</p><p>将图片拷贝到与博客同名的文件夹，然后按如下相对路径引用</p><pre class="line-numbers language-none"><code class="language-none">![图片描述]（./博客名/NO.01.001.jpg）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.保存和generator</p><pre class="line-numbers language-none"><code class="language-none">$ hexo clean &amp; hexo g &amp; hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用指令</title>
      <link href="/2022/04/11/git/"/>
      <url>/2022/04/11/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git常用指令"><a href="#Git常用指令" class="headerlink" title="Git常用指令"></a>Git常用指令</h1><p>[TOC]</p><table><thead><tr><th align="center">name</th><th align="center">名词</th></tr></thead><tbody><tr><td align="center">Workspace</td><td align="center">工作区</td></tr><tr><td align="center">Index / Stage</td><td align="center">暂存区</td></tr><tr><td align="center">Repository</td><td align="center">仓库区（或本地仓库）</td></tr><tr><td align="center">Remote</td><td align="center">远程仓库</td></tr></tbody></table><h3 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a><strong>一、新建代码库</strong></h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;在当前目录新建一个Git代码库$&nbsp;git&nbsp;init#&nbsp;新建一个目录，将其初始化为Git代码库$&nbsp;git&nbsp;init&nbsp;[project-name]#&nbsp;下载一个项目和它的整个代码历史$&nbsp;git&nbsp;clone&nbsp;[url]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a><strong>二、配置</strong></h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)</p><pre class="line-numbers language-none"><code class="language-none">#&nbsp;显示当前的Git配置$&nbsp;git&nbsp;config&nbsp;--list#&nbsp;编辑Git配置文件$&nbsp;git&nbsp;config&nbsp;-e&nbsp;[--global]#&nbsp;设置提交代码时的用户信息$&nbsp;git&nbsp;config&nbsp;[--global]&nbsp;user.name&nbsp;"[name]"$&nbsp;git&nbsp;config&nbsp;[--global]&nbsp;user.email&nbsp;"[email&nbsp;address]"#&nbsp;颜色设置git&nbsp;config&nbsp;--global&nbsp;color.ui&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;git&nbsp;status等命令自动着色git&nbsp;config&nbsp;--global&nbsp;color.status&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;color.diff&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;color.branch&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;color.interactive&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;--unset&nbsp;http.proxy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;remove&nbsp;&nbsp;proxy&nbsp;configuration&nbsp;on&nbsp;gitgit config user.name // 查看git用户名git config user.password //查看git密码git config user.email // 查看git邮箱地址git config --global user.name "xxxx(新的用户名)" // 修改git用户名git config --global user.password "xxxx(新的密码)" // 修改git密码git config --global user.email "xxxx@xxx.com(新的邮箱)" // 修改git邮箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;添加指定文件到暂存区$&nbsp;git&nbsp;add&nbsp;[file1]&nbsp;[file2]&nbsp;...#&nbsp;添加指定目录到暂存区，包括子目录$&nbsp;git&nbsp;add&nbsp;[dir]#&nbsp;添加当前目录的所有文件到暂存区$&nbsp;git&nbsp;add&nbsp;.#&nbsp;添加每个变化前，都会要求确认#&nbsp;对于同一个文件的多处变化，可以实现分次提交$&nbsp;git&nbsp;add&nbsp;-p#&nbsp;删除工作区文件，并且将这次删除放入暂存区$&nbsp;git&nbsp;rm&nbsp;[file1]&nbsp;[file2]&nbsp;...#&nbsp;停止追踪指定文件，但该文件会保留在工作区$&nbsp;git&nbsp;rm&nbsp;--cached&nbsp;[file]#&nbsp;改名文件，并且将这个改名放入暂存区$&nbsp;git&nbsp;mv&nbsp;[file-original]&nbsp;[file-renamed]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a><strong>四、代码提交</strong></h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;提交暂存区到仓库区$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;[message]#&nbsp;提交暂存区的指定文件到仓库区$&nbsp;git&nbsp;commit&nbsp;[file1]&nbsp;[file2]&nbsp;...&nbsp;-m&nbsp;[message]#&nbsp;提交工作区自上次commit之后的变化，直接到仓库区$&nbsp;git&nbsp;commit&nbsp;-a#&nbsp;提交时显示所有diff信息$&nbsp;git&nbsp;commit&nbsp;-v#&nbsp;将add和commit合为一步$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'message'#&nbsp;使用一次新的commit，替代上一次提交#&nbsp;如果代码没有任何新变化，则用来改写上一次commit的提交信息$&nbsp;git&nbsp;commit&nbsp;--amend&nbsp;-m&nbsp;[message]#&nbsp;重做上一次commit，并包括指定文件的新变化$&nbsp;git&nbsp;commit&nbsp;--amend&nbsp;[file1]&nbsp;[file2]&nbsp;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a><strong>五、分支</strong></h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;列出所有本地分支$&nbsp;git&nbsp;branch#&nbsp;列出所有远程分支$&nbsp;git&nbsp;branch&nbsp;-r#&nbsp;列出所有本地分支和远程分支$&nbsp;git&nbsp;branch&nbsp;-a#&nbsp;新建一个分支，但依然停留在当前分支$&nbsp;git&nbsp;branch&nbsp;[branch-name]#&nbsp;新建一个分支，并切换到该分支$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;[branch]#&nbsp;新建一个分支，指向指定commit$&nbsp;git&nbsp;branch&nbsp;[branch]&nbsp;[commit]#&nbsp;新建一个分支，与指定的远程分支建立追踪关系$&nbsp;git&nbsp;branch&nbsp;--track&nbsp;[branch]&nbsp;[remote-branch]#&nbsp;切换到指定分支，并更新工作区$&nbsp;git&nbsp;checkout&nbsp;[branch-name]#&nbsp;切换到上一个分支$&nbsp;git&nbsp;checkout&nbsp;-#&nbsp;建立追踪关系，在现有分支与指定的远程分支之间$&nbsp;git&nbsp;branch&nbsp;--set-upstream&nbsp;[branch]&nbsp;[remote-branch]#&nbsp;合并指定分支到当前分支$&nbsp;git&nbsp;merge&nbsp;[branch]#&nbsp;选择一个commit，合并进当前分支$&nbsp;git&nbsp;cherry-pick&nbsp;[commit]#&nbsp;删除分支$&nbsp;git&nbsp;branch&nbsp;-d&nbsp;[branch-name]#&nbsp;删除远程分支$&nbsp;git&nbsp;push&nbsp;origin&nbsp;--delete&nbsp;[branch-name]$&nbsp;git&nbsp;branch&nbsp;-dr&nbsp;[remote/branch]#&nbsp;检出版本v2.0$&nbsp;git&nbsp;checkout&nbsp;v2.0#&nbsp;从远程分支develop创建新本地分支devel并检出$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;devel&nbsp;origin/develop#&nbsp;检出head版本的README文件（可用于修改错误回退）git&nbsp;checkout&nbsp;--&nbsp;README <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;列出所有tag$&nbsp;git&nbsp;tag#&nbsp;新建一个tag在当前commit$&nbsp;git&nbsp;tag&nbsp;[tag]#&nbsp;新建一个tag在指定commit$&nbsp;git&nbsp;tag&nbsp;[tag]&nbsp;[commit]#&nbsp;删除本地tag$&nbsp;git&nbsp;tag&nbsp;-d&nbsp;[tag]#&nbsp;删除远程tag$&nbsp;git&nbsp;push&nbsp;origin&nbsp;:refs/tags/[tagName]#&nbsp;查看tag信息$&nbsp;git&nbsp;show&nbsp;[tag]#&nbsp;提交指定tag$&nbsp;git&nbsp;push&nbsp;[remote]&nbsp;[tag]#&nbsp;提交所有tag$&nbsp;git&nbsp;push&nbsp;[remote]&nbsp;--tags#&nbsp;新建一个分支，指向某个tag$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;[branch]&nbsp;[tag]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;显示有变更的文件$&nbsp;git&nbsp;status#&nbsp;显示当前分支的版本历史$&nbsp;git&nbsp;log#&nbsp;显示commit历史，以及每次commit发生变更的文件$&nbsp;git&nbsp;log&nbsp;--stat#&nbsp;搜索提交历史，根据关键词$&nbsp;git&nbsp;log&nbsp;-S&nbsp;[keyword]#&nbsp;显示某个commit之后的所有变动，每个commit占据一行$&nbsp;git&nbsp;log&nbsp;[tag]&nbsp;HEAD&nbsp;--pretty=format:%s#&nbsp;显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件$&nbsp;git&nbsp;log&nbsp;[tag]&nbsp;HEAD&nbsp;--grep&nbsp;feature#&nbsp;显示某个文件的版本历史，包括文件改名$&nbsp;git&nbsp;log&nbsp;--follow&nbsp;[file]$&nbsp;git&nbsp;whatchanged&nbsp;[file]#&nbsp;显示指定文件相关的每一次diff$&nbsp;git&nbsp;log&nbsp;-p&nbsp;[file]#&nbsp;显示过去5次提交$&nbsp;git&nbsp;log&nbsp;-5&nbsp;--pretty&nbsp;--oneline#&nbsp;显示所有提交过的用户，按提交次数排序$&nbsp;git&nbsp;shortlog&nbsp;-sn#&nbsp;显示指定文件是什么人在什么时间修改过$&nbsp;git&nbsp;blame&nbsp;[file]#&nbsp;显示暂存区和工作区的差异$&nbsp;git&nbsp;diff#&nbsp;显示暂存区和上一个commit的差异$&nbsp;git&nbsp;diff&nbsp;--cached&nbsp;[file]#&nbsp;显示工作区与当前分支最新commit之间的差异$&nbsp;git&nbsp;diff&nbsp;HEAD#&nbsp;显示两次提交之间的差异$&nbsp;git&nbsp;diff&nbsp;[first-branch]...[second-branch]#&nbsp;显示今天你写了多少行代码$&nbsp;git&nbsp;diff&nbsp;--shortstat&nbsp;"@{0&nbsp;day&nbsp;ago}"#&nbsp;显示某次提交的元数据和内容变化$&nbsp;git&nbsp;show&nbsp;[commit]#&nbsp;显示某次提交发生变化的文件$&nbsp;git&nbsp;show&nbsp;--name-only&nbsp;[commit]#&nbsp;显示某次提交时，某个文件的内容$&nbsp;git&nbsp;show&nbsp;[commit]:[filename]#&nbsp;显示当前分支的最近几次提交$&nbsp;git&nbsp;reflog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a><strong>八、远程同步</strong></h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;下载远程仓库的所有变动$&nbsp;git&nbsp;fetch&nbsp;[remote]#&nbsp;显示所有远程仓库$&nbsp;git&nbsp;remote&nbsp;-v#&nbsp;显示某个远程仓库的信息$&nbsp;git&nbsp;remote&nbsp;show&nbsp;[remote]#&nbsp;增加一个新的远程仓库，并命名$&nbsp;git&nbsp;remote&nbsp;add&nbsp;[shortname]&nbsp;[url]#&nbsp;取回远程仓库的变化，并与本地分支合并$&nbsp;git&nbsp;pull&nbsp;[remote]&nbsp;[branch]#&nbsp;上传本地指定分支到远程仓库$&nbsp;git&nbsp;push&nbsp;[remote]&nbsp;[branch]#&nbsp;强行推送当前分支到远程仓库，即使有冲突$&nbsp;git&nbsp;push&nbsp;[remote]&nbsp;--force#&nbsp;推送所有分支到远程仓库$&nbsp;git&nbsp;push&nbsp;[remote]&nbsp;--all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a><strong>九、撤销</strong></h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;恢复暂存区的指定文件到工作区$&nbsp;git&nbsp;checkout&nbsp;[file]  #&nbsp;恢复某个commit的指定文件到暂存区和工作区$&nbsp;git&nbsp;checkout&nbsp;[commit]&nbsp;[file]  #&nbsp;恢复暂存区的所有文件到工作区$&nbsp;git&nbsp;checkout&nbsp;.     #&nbsp;重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$&nbsp;git&nbsp;reset&nbsp;[file]   #&nbsp;重置暂存区与工作区，与上一次commit保持一致$&nbsp;git&nbsp;reset&nbsp;--hard   #&nbsp;重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$&nbsp;git&nbsp;reset&nbsp;[commit] #&nbsp;重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$&nbsp;git&nbsp;reset&nbsp;--hard&nbsp;[commit] #&nbsp;重置当前HEAD为指定commit，但保持暂存区和工作区不变$&nbsp;git&nbsp;reset&nbsp;--keep&nbsp;[commit]#&nbsp;新建一个commit，用来撤销指定commit,后者的所有变化都将被前者抵消，并且应用到当前分支$&nbsp;git&nbsp;revert&nbsp;[commit] #&nbsp;暂时将未提交的变化移除，稍后再移入$&nbsp;git&nbsp;stash$&nbsp;git&nbsp;stash&nbsp;pop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h3><pre class="line-numbers language-none"><code class="language-none">git&nbsp;init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;初始化本地git仓库（创建新仓库）git&nbsp;config&nbsp;--global&nbsp;user.name&nbsp;"xxx"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;配置用户名git&nbsp;config&nbsp;--global&nbsp;user.email&nbsp;"xxx@xxx.com"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;配置邮件git&nbsp;config&nbsp;--global&nbsp;color.ui&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;git&nbsp;status等命令自动着色git&nbsp;config&nbsp;--global&nbsp;color.status&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;color.diff&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;color.branch&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;color.interactive&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;--unset&nbsp;http.proxy&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;remove&nbsp;&nbsp;proxy&nbsp;configuration&nbsp;on&nbsp;gitgit&nbsp;clone&nbsp;git+ssh://git@192.168.53.168/VT.git&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;clone远程仓库git&nbsp;status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看当前版本状态（是否修改）git&nbsp;add&nbsp;xyz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;添加xyz文件至indexgit&nbsp;add&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;增加当前子目录下所有更改过的文件至indexgit&nbsp;commit&nbsp;-m&nbsp;'xxx'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;提交git&nbsp;commit&nbsp;--amend&nbsp;-m&nbsp;'xxx'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;合并上一次提交（用于反复修改）git&nbsp;commit&nbsp;-am&nbsp;'xxx'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;将add和commit合为一步git&nbsp;rm&nbsp;xxx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;删除index中的文件git&nbsp;rm&nbsp;-r&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;递归删除git&nbsp;log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示提交日志git&nbsp;log&nbsp;-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示1行日志&nbsp;-n为n行git&nbsp;log&nbsp;-5git&nbsp;log&nbsp;--stat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示提交日志及相关变动文件git&nbsp;log&nbsp;-p&nbsp;-mgit&nbsp;show&nbsp;dfb02e6e4f2f7b573337763e5c0013802e392818&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示某个提交的详细内容git&nbsp;show&nbsp;dfb02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;可只用commitid的前几位git&nbsp;show&nbsp;HEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示HEAD提交日志git&nbsp;show&nbsp;HEAD^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示HEAD的父（上一个版本）的提交日志&nbsp;^^为上两个版本&nbsp;^5为上5个版本git&nbsp;tag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示已存在的taggit&nbsp;tag&nbsp;-a&nbsp;v2.0&nbsp;-m&nbsp;'xxx'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;增加v2.0的taggit&nbsp;show&nbsp;v2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示v2.0的日志及详细内容git&nbsp;log&nbsp;v2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示v2.0的日志git&nbsp;diff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有未添加至index的变更git&nbsp;diff&nbsp;--cached&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有已添加index但还未commit的变更git&nbsp;diff&nbsp;HEAD^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;比较与上一个版本的差异git&nbsp;diff&nbsp;HEAD&nbsp;--&nbsp;./lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;比较与HEAD版本lib目录的差异git&nbsp;diff&nbsp;origin/master..master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;比较远程分支master上有本地分支master上没有的git&nbsp;diff&nbsp;origin/master..master&nbsp;--stat&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;只显示差异的文件，不显示具体内容git&nbsp;remote&nbsp;add&nbsp;origin&nbsp;git+ssh://git@192.168.53.168/VT.git&nbsp;#&nbsp;增加远程定义（用于push/pull/fetch）git&nbsp;branch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示本地分支git&nbsp;branch&nbsp;--contains&nbsp;50089&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示包含提交50089的分支git&nbsp;branch&nbsp;-a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有分支git&nbsp;branch&nbsp;-r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有原创分支git&nbsp;branch&nbsp;--merged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有已合并到当前分支的分支git&nbsp;branch&nbsp;--no-merged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有未合并到当前分支的分支git&nbsp;branch&nbsp;-m&nbsp;master&nbsp;master_copy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;本地分支改名git&nbsp;checkout&nbsp;-b&nbsp;master_copy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;从当前分支创建新分支master_copy并检出git&nbsp;checkout&nbsp;-b&nbsp;master&nbsp;master_copy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;上面的完整版git&nbsp;checkout&nbsp;features/performance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;检出已存在的features/performance分支git&nbsp;checkout&nbsp;--track&nbsp;hotfixes/BJVEP933&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git&nbsp;checkout&nbsp;v2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;检出版本v2.0git&nbsp;checkout&nbsp;-b&nbsp;devel&nbsp;origin/develop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;从远程分支develop创建新本地分支devel并检出git&nbsp;checkout&nbsp;--&nbsp;README&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;检出head版本的README文件（可用于修改错误回退）git&nbsp;merge&nbsp;origin/master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;合并远程master分支至当前分支git&nbsp;cherry-pick&nbsp;ff44785404a8e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;合并提交ff44785404a8e的修改git&nbsp;push&nbsp;origin&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;将当前分支push到远程master分支git&nbsp;push&nbsp;origin&nbsp;:hotfixes/BJVEP933&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;删除远程仓库的hotfixes/BJVEP933分支git&nbsp;push&nbsp;--tags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;把所有tag推送到远程仓库git&nbsp;fetch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;获取所有远程分支（不更新本地分支，另需merge）git&nbsp;fetch&nbsp;--prune&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;获取所有原创分支并清除服务器上已删掉的分支git&nbsp;pull&nbsp;origin&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;获取远程分支master并merge到当前分支git&nbsp;mv&nbsp;README&nbsp;README2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;重命名文件README为README2git&nbsp;reset&nbsp;--hard&nbsp;HEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;将当前版本重置为HEAD（通常用于merge失败回退）git&nbsp;rebasegit&nbsp;branch&nbsp;-d&nbsp;hotfixes/BJVEP933&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git&nbsp;branch&nbsp;-D&nbsp;hotfixes/BJVEP933&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;强制删除分支hotfixes/BJVEP933git&nbsp;ls-files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;列出git&nbsp;index包含的文件git&nbsp;show-branch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;图示当前分支历史git&nbsp;show-branch&nbsp;--all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;图示所有分支历史git&nbsp;whatchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示提交历史对应的文件修改git&nbsp;revert&nbsp;dfb02e6e4f2f7b573337763e5c0013802e392818&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git&nbsp;ls-tree&nbsp;HEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;内部命令：显示某个git对象git&nbsp;rev-parse&nbsp;v2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;内部命令：显示某个ref对于的SHA1 HASHgit&nbsp;reflog&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有提交，包括孤立节点git&nbsp;show&nbsp;HEAD@{5}git&nbsp;show&nbsp;master@{yesterday}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示master分支昨天的状态git&nbsp;log&nbsp;--pretty=format:'%h&nbsp;%s'&nbsp;--graph&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;图示提交日志git&nbsp;show&nbsp;HEAD~3git&nbsp;show&nbsp;-s&nbsp;--pretty=raw&nbsp;2be7fcb476git&nbsp;stash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;暂存当前修改，将所有至为HEAD状态git&nbsp;stash&nbsp;list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看所有暂存git&nbsp;stash&nbsp;show&nbsp;-p&nbsp;stash@{0}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;参考第一次暂存git&nbsp;stash&nbsp;apply&nbsp;stash@{0}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;应用第一次暂存git&nbsp;grep&nbsp;"delete&nbsp;from"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;文件中搜索文本“delete&nbsp;from”git&nbsp;grep&nbsp;-e&nbsp;'#define'&nbsp;--and&nbsp;-e&nbsp;SORT_DIRENTgit&nbsp;gcgit&nbsp;fsck                                                  #&nbsp;生成一个可供发布的压缩包git&nbsp;archivegit submodule update --init --recursivegit submodule initgit submodule update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC常用编译选项</title>
      <link href="/2022/04/10/gcc-chang-yong-bian-yi-xuan-xiang/"/>
      <url>/2022/04/10/gcc-chang-yong-bian-yi-xuan-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="GCC常用编译选项"><a href="#GCC常用编译选项" class="headerlink" title="GCC常用编译选项"></a>GCC常用编译选项</h1><p>​        </p><p>[TOC]</p><p>​        GCC有很多编译选项，有一些常用的选项可以作为检查代码质量的辅助手段，有的则可以让编译器对代码和编译目标文件进行优化，还有的是专门为了调试代码设计的，熟悉这些编译选项可以让开发者在使用GCC时更加游刃有余。</p><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">CFLAGS := -Wall -Wundef -Wshadow -Wconversion -Werror=return-type \    -Werror=implicit-function-declaration -Werror=unused-variable \    -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE \    -Wno-trigraphs -Os<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于调试版本，将<code>-Os</code>替换为<code>-g -Og</code>。</p><h2 id="一-警告选项"><a href="#一-警告选项" class="headerlink" title="一 警告选项"></a>一 警告选项</h2><p>​        GCC编译器支持对代码进行诊断，<strong>针对代码本身不是错误但是疑似错误或者可能存在风险的地方发出警告</strong>，而警告编译选项就是用于<strong>控制需要告警的警告类型</strong>的。一般启用特定类型警告的格式为<code>-Wxxx</code>，而排除特定类型的警告的格式则一般为<code>-Wno-xxx</code>。</p><h3 id="1-Wall"><a href="#1-Wall" class="headerlink" title="1 -Wall"></a>1 -Wall</h3><p>​        这是一个非常常用的编译选项，用于启用一批<strong>比较常见且易于修改的警告</strong>，这些选项都是对代码进行基本的检查，比如下面这些：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-Waddress</td><td>检查是否存在可疑的内存地址使用</td></tr><tr><td>-Wformat</td><td>检查标准库函数的使用格式是否正确，比如printf的格式化字符串中的格式符和对应的参数是否匹配</td></tr><tr><td>-Wunused-function</td><td>对已声明但是未定义的静态函数和未被使用的非内联静态函数发出警告</td></tr><tr><td>-Wswitch</td><td>当用switch用于枚举类型时，判断分支是否包含所有枚举值，否则发出警告</td></tr><tr><td>-Wunused-variable</td><td>对声明但未被使用的变量发出警告</td></tr><tr><td>-Wunused-but-set-variable</td><td>对声明且被赋值但未被使用的变量发出警告</td></tr><tr><td>-Warray-bounds=1</td><td>数组越界检查，需启用选项-ftree-vrp</td></tr></tbody></table><p>​        当需要排除某些类型的警告时，记得使用<code>-Wno-xxx</code>, 比如使用<code>-Wall -Wno-unused-variable</code>可以从<code>-Wall</code>中排除<code>-Wunused-variable</code>。</p><p>​        完整的列表参见链接**<a href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html">Warning-Options</a>**。</p><h3 id="2-Wextra"><a href="#2-Wextra" class="headerlink" title="2 -Wextra"></a>2 -Wextra</h3><p>​        单单只有<code>-Wall</code>可能还不够严格，GCC还有<code>-Wextra</code>作为补充，包括另外一些没有被<code>-Wall</code>包含的警告类型，比如笔者比较喜欢的几个：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-Wcast-function-type</td><td>当函数被强转为不兼容的函数指针时发出警告</td></tr><tr><td>-Wempty-body</td><td>当存在空的if、else或者do while语句时发出警告</td></tr><tr><td>-Wunused-parameter</td><td>当函数有未被使用的参数时发出警告，需配合-Wall</td></tr><tr><td>-Wunused-but-set-parameter</td><td>当存在被设置但是未被使用的参数发出警告，需配合-Wall</td></tr><tr><td>-Wsign-compare</td><td>当比较有符号和无符号值时发出警告</td></tr></tbody></table><p>对于不同语言，<code>-Wall</code>和<code>-Wextra</code>启用的选项可能略有差异</p><h3 id="3-Werror"><a href="#3-Werror" class="headerlink" title="3 -Werror"></a>3 -Werror</h3><p><code>-Werror</code>用于将所有警告视为错误。</p><p>​        如果不希望某些类型的警告被视为错误可以使用<code>-Wno-error=&lt;警告类型&gt;</code>，比如<code>-Wno-error=switch</code>；而使用<code>-Werror=&lt;警告类型&gt;</code>则可以将指定警告类型视为错误，比如<code>-Werror=switch</code>。</p><p>​        当代码量变得比较大的时候，同时启用<code>-Wall -Wextra -Werror</code>是比较严苛的，可能存在一些不准确的警告，这时可以将<code>-Werror</code>替换为只将某些警告视为错误，在自动化编译构建的时候提前报错终止提示开发者进行改进。</p><p>​        对于大部分<code>-Wunused-</code>类警告选项，其实都是<strong>让开发者明确知道定义的变量或者参数是不是必须的</strong>，是多余的还是忘记使用了，对于反思代码逻辑和简化代码都是很有帮助的，所以建议将这些警告视为错误。</p><h3 id="4-Wpedantic"><a href="#4-Wpedantic" class="headerlink" title="4 -Wpedantic"></a>4 -Wpedantic</h3><p>对于所有不符合<code>ISO C/ISO C++</code>语言标准的源代码发出警告，等价于<code>-pedantic</code>。</p><pre class="line-numbers language-none"><code class="language-none">-pedantic-errors`参数将这些警告视为错误，等同于`-Werror=pedantic<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-Wshadow"><a href="#5-Wshadow" class="headerlink" title="5 -Wshadow"></a>5 -Wshadow</h3><p>当局部变量屏蔽（shadow）已有已有变量时发出警告。比如以下代码：</p><pre class="line-numbers language-none"><code class="language-none">int ret = 0;for (int i = 0; i &lt; 10; ++i) {    int ret = i;  //  warning: declaration shadows a local variable}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-Wconversion"><a href="#6-Wconversion" class="headerlink" title="6 -Wconversion"></a>6 -Wconversion</h3><p>​        在<strong>隐式转换可能导致值变化的时候</strong>发出警告。在隐式转换的时候，如果值发生变化，那么结果可能就不是预料中的，所以最好使用显式转换。</p><h2 id="二-优化选项"><a href="#二-优化选项" class="headerlink" title="二 优化选项"></a>二 优化选项</h2><p>​        优化选项用于控制编译器对代码的优化等级。比较常用的是<code>-O2</code>和<code>-Os</code>。详细的介绍请查看官网**<a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">Optimize-Options</a>**。</p><h3 id="1-O0-Og"><a href="#1-O0-Og" class="headerlink" title="1 -O0/-Og"></a>1 -O0/-Og</h3><p>​        <code>-O0</code>是默认选项，不执行任何优化。在编译调试版本的时候，一般使用<code>-O0</code>，可以确保调试执行过程完全和代码一致（如果使用优化选项，根据源文件设定的断点和经过优化编译得到的程序可能对不上，所以不能准确停在预期的地方）。</p><p>​        <code>-Og</code>是针对调试的优化选项，它会启用<code>-O1</code>的优化指令，除了那么可能会干扰调试的优化选项，同时可获取到更多的调试信息，提供更好好的编译体验，</p><h3 id="2-O-O1"><a href="#2-O-O1" class="headerlink" title="2 -O/-O1"></a>2 -O/-O1</h3><p>​        执行级别1的优化，尝试减少代码大小和提高性能，但是不包括需要花费大量编译时间的优化选项。</p><p>比如：</p><ol><li><code>-fdce</code>：移除不可能执行到的代码</li><li><code>-fif-conversion</code>：尝试简化if语句。使用更少的分支、转化成标志位等操作</li><li><code>-fmerge-constants</code>：尝试合并相同的常量</li></ol><h3 id="3-O2"><a href="#3-O2" class="headerlink" title="3 -O2"></a>3 -O2</h3><p>​        执行<code>-O1</code>所有优化选项，同时额外执行<strong>几乎全部不需要在空间和性能之间平衡</strong>的优化选项。</p><p>比如：</p><ol><li><code>-fgcse</code>：优化全局公共表达式、常量的传递</li><li><code>-fcode-hoisting</code>：将所有分支都需要执行的表达式尽早执行（对于优化代码大小很有用，同时也提升性能）</li><li><code>-finline-functions</code>：考虑将所有函数变成内联函数（即使没有被声明为inline）</li></ol><h3 id="4-Os"><a href="#4-Os" class="headerlink" title="4 -Os"></a>4 -Os</h3><p>​        这是专门用于优化代码大小的优化级别，执行<code>-O2</code>所有优化选项，排除那些可能导致程序大小增加的优化选项。</p><h3 id="5-O3"><a href="#5-O3" class="headerlink" title="5 -O3"></a>5 -O3</h3><p>​        最高优化等级。该优化级别较高，执行的优化不会很直观，所以可能也会出现一些问题，需要看实际情况选择是否需要使用<code>-O3</code>。在使用<code>-O3</code>优化级别时，<strong>小概率出现代码执行一段时间后出现了一些不符合预期的现象</strong>，在降低优化等级时则没有问题。</p><h3 id="6-ffunction-sections-fdata-sections-Wl-–gc-sections"><a href="#6-ffunction-sections-fdata-sections-Wl-–gc-sections" class="headerlink" title="6 -ffunction-sections/-fdata-sections/-Wl,–gc-sections"></a>6 -ffunction-sections/-fdata-sections/-Wl,–gc-sections</h3><p>​        在开发过程中，可能会实现一些实际并不会用到的函数或者对外有多个接口，并不是所有的接口都需要用到所有的模块和函数，但是默认情况下，GCC会把整个静态库链接到目标可执行文件，所以会增加可执行文件的大小。</p><p>​        GCC在链接的时候以<code>section</code>为单元处理，所以可以尝试使用<code>-ffunction-sections/-fdata-sections</code>将每个函数或者符号创建成独立的<code>section</code>，然后结合选项<code>-Wl,--gc-sections</code>让链接器忽略用不到的<code>section</code>，这样就可以减少目标可执行程序的大小。其中<code>-Wl</code>表示将后面的参数传递给链接器，所以也可以直接设置链接器选项。</p><p>​        注意这个并不是所有的链接器都支持的，大多数支持编译ELF目标文件的工具链都是支持的，<strong>一般嵌入式开发会比较常用</strong>的。</p><h2 id="三-代码生成选项"><a href="#三-代码生成选项" class="headerlink" title="三 代码生成选项"></a>三 代码生成选项</h2><p>​        最常用的就只有<code>-fPIC</code>，该选项用于生成**位置无关代码(PIC，position-independent code)**，主要是为了生成共享库。此类代码通过全局偏移表 (GOT) 访问所有常量地址，在程序启动的时候，动态加载器会确定需要使用的共享库的GOT。</p><p><code>-fPIE</code>和<code>-fPIC</code>是类似的，但<code>-fPIE</code>产生的位置无关代码只能用于链接可执行文件。</p><p>另外可能还会偶尔用到<code>-fpic</code>和<code>-fpie</code>，它们和全大写的区别只在于系统对GOT大小有一定限制。</p><h2 id="四-调试选项"><a href="#四-调试选项" class="headerlink" title="四 调试选项"></a>四 调试选项</h2><p>​        一般情况下是为了能够正常使用调试器调试程序，必须要让编译器给编译目标添加额外的调试信息。最常使用的是<code>-g</code>，一般可以满足需求。但是如果为了提升一些调试程序的性能，可以配合使用针对调试的优化选项<code>-Og</code>。（添加的调试信息可以使用<code>strip</code>工具移除，一般对于需要release的程序代码可以都通过此工具移除一些敏感信息，同时也能够减少目标文件的大小。）</p><p>​        GCC的编译选项还有很多，对于常用的就是上面这一些，在开发阶段，最重要还是通过一些有用的警告选项排查常见的代码bug，提高代码的鲁棒性。</p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc </tag>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>doxygen教程</title>
      <link href="/2022/04/09/doxygen-jiao-cheng/"/>
      <url>/2022/04/09/doxygen-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="doxygen教程"><a href="#doxygen教程" class="headerlink" title="doxygen教程"></a>doxygen教程</h1><h2 id="一．什么是Doxygen"><a href="#一．什么是Doxygen" class="headerlink" title="一．什么是Doxygen?"></a><strong>一．什么是Doxygen?</strong></h2><p>​        Doxygen 是一个程序的文件产生工具，可将程序中的特定批注转换成为说明文件。通常我们在写程序时，或多或少都会写上批注，但是对于其它人而言，要直接探索程序里的批注，与打捞泰坦尼克号同样的辛苦。大部分有用的批注都是属于针对函式，类别等等的说明。所以，如果能依据程序本身的结构，将批注经过处理重新整理成为一个纯粹的参考手册，对于后面利用您的程序代码的人而言将会减少许多的负担。不过，反过来说，整理文件的工作对于您来说，就是沉重的负担。Doxygen 就是在您写批注时，稍微<strong>按照一些它所制订的规则</strong>。接着，他就可以帮您产生出漂亮的文档了。</p><p>​        因此，Doxygen 的使用可分为两大部分。首先是<strong>特定格式的批注撰写</strong>，第二便是<strong>利用Doxygen的工具来产生文档。</strong></p><p>​        目前Doxygen可处理的程序语言包含：C/C++、 Java、IDL (Corba, Microsoft及KDE-DCOP类型)  ，而可产生出来的文档格式有：HTML、XML、LaTeX、RTF、Unix Man Page。而其中还可衍生出不少其它格式。HTML可以打包成<strong>CHM格式</strong>，而LaTeX可以透过一些工具产生出<strong>PS或是PDF文档</strong>。</p><h2 id="二．安装Doxygen"><a href="#二．安装Doxygen" class="headerlink" title="二．安装Doxygen"></a><strong>二．安装Doxygen</strong></h2><h3 id="2-1-安装-Doxygen"><a href="#2-1-安装-Doxygen" class="headerlink" title="2.1 安装 Doxygen"></a>2.1 安装 Doxygen</h3><p>在Linux下可以通过apt install doxygen安装命令行工具，然后用apt install doxygen-gui安装图形界面。对Linux用户来说，命令行工具可以通过doxygen命令运行，而图形界面可以通过doxywizard命令运行。</p><p>Windows 用户的下载地址：</p><h3 id="2-2-安装-graphviz"><a href="#2-2-安装-graphviz" class="headerlink" title="2.2 安装 graphviz"></a>2.2 安装 graphviz</h3><p>​        graphviz 是一个由AT&amp;T实验室启动的开源工具包，用于绘制DOT语言脚本描述的图形。Doxygen 使用 graphviz 自动生成类之间和文件之间的调用关系图，如不需要此功能可不安装该工具包。</p><h3 id="2-3-安装-Windows-Help-Workshop"><a href="#2-3-安装-Windows-Help-Workshop" class="headerlink" title="2.3 安装 Windows Help Workshop"></a>2.3 安装 Windows Help Workshop</h3><p>​        Doxygen 使用这个工具可以生成 CHM 格式的文档。</p><h2 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a><strong>三、基本使用</strong></h2><h3 id="1-基本配置"><a href="#1-基本配置" class="headerlink" title="1.基本配置"></a>1.基本配置</h3><p>图形工具的基本使用如下图所示，有非常多的配置选项，这里我们只填入必要的配置，其它配置都用默认值。</p><p><img src="E:./doxygen教程/1.png" alt="1"></p><p><img src=".%5Cdoxygen%E6%95%99%E7%A8%8B%5C2.png" alt="2"></p><h3 id="2-生成文档"><a href="#2-生成文档" class="headerlink" title="2.生成文档"></a>2.生成文档</h3><p>Doxygen生成的HTML会放到<code>out</code>目录下，生成的HTML如下图所示。</p><p><img src="./doxygen%E6%95%99%E7%A8%8B/3.png" alt="3"></p><h3 id="3、保存配置"><a href="#3、保存配置" class="headerlink" title="3、保存配置"></a><strong>3、保存配置</strong></h3><p>上面我们配置了一些选项，也成功生成了HTML文档。我们希望下次代码改动后能够继续沿用上次配置，那么我们可以把这些配置保存成Doxyfile文件，如下图所示</p><p><img src="./doxygen%E6%95%99%E7%A8%8B/4.png" alt="4"></p><h3 id="4、命令行运行Doxygen"><a href="#4、命令行运行Doxygen" class="headerlink" title="4、命令行运行Doxygen"></a><strong>4、命令行运行Doxygen</strong></h3><p>有了配置文件后我们完全可以通过命令行来生成API文档，假设配置文件名为Doxyfile，那么我们只需要执行doxygen /path/to/Doxyfile即可生成API文档。</p><p>通过命令行生成文档有许多好处，其中最主要的好处就是：能够集成到持续集成之类的自动化系统中。</p><h2 id="四、为代码编写注释"><a href="#四、为代码编写注释" class="headerlink" title="四、为代码编写注释"></a><strong>四、为代码编写注释</strong></h2><h3 id="1-识别的注释"><a href="#1-识别的注释" class="headerlink" title="1.识别的注释"></a>1.识别的注释</h3><p>Doxygen能识别这几种风格的注释：</p><pre class="line-numbers language-none"><code class="language-none">/** * ... text ... *//*! * ... text ... */////// ... text .../////!//!... text ...//!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件的开头必须有文件注释，否则该文件不会被识别：</p><pre class="line-numbers language-none"><code class="language-none">/*! \file math.h */<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-注释怎么写"><a href="#2-注释怎么写" class="headerlink" title="2.注释怎么写"></a><strong>2.注释怎么写</strong></h3><p>建议参考官网例子。</p><pre class="line-numbers language-none"><code class="language-none">https://www.doxygen.nl/manual/doxygen_usage.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-为其它编程语言生成注释"><a href="#3-为其它编程语言生成注释" class="headerlink" title="3.为其它编程语言生成注释"></a>3.<strong>为其它编程语言生成注释</strong></h3><p>Doxygen主要支持C语言，其它语法跟C差不多的语言（如：C++/C#/PHP/Java）也能够支持，我们称这类语言为「C语系语言」。而哪些跟C语法差异较大的语言叫做「非C语系语言」。</p><p>对于大多非C语系语言，Doxygen都是支持的，Doxygen原生支持这些语言：IDL、Java、Javascript、C#、C、C++、D、PHP、Objective-C、Python、Fortran、VHDL。</p><p>更详细的使用教程可以查看官方文档：</p><p><a href="https://www.doxygen.nl/manual/doxygen_usage.html">https://www.doxygen.nl/manual/doxygen_usage.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doxygen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMakeLists语法</title>
      <link href="/2022/04/08/cmakelists-yu-fa/"/>
      <url>/2022/04/08/cmakelists-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="CMakeLists-txt-语法"><a href="#CMakeLists-txt-语法" class="headerlink" title="CMakeLists.txt 语法"></a>CMakeLists.txt 语法</h1><h2 id="一、Cmake-示例"><a href="#一、Cmake-示例" class="headerlink" title="一、Cmake 示例"></a>一、Cmake 示例</h2><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.16)project(easylogging)set(CMAKE_CXX_STANDARD 11)MESSAGE(STATUS "This is make for easylogging++ lib " ${PROJECT_BINARY_DIR})set(LIB_DIR ${PROJECT_SOURCE_DIR}/SDK/lib/easylogging++)include_directories(${LIB_DIR})include_directories(SDK/include/CRC)include_directories(mongoose)include_directories(SDK/include)set(SRC_LIST        mongoose/mongoose.c#        test.cpp        )add_executable(${PROJECT_NAME} main.cpp ${SRC_LIST})# link the new hello_library target with the hello_binary targettarget_link_libraries( ${PROJECT_NAME}        PRIVATE        ${LIB_DIR}/libeasylogging.a        ws2_32        )##########################Install##################################set(BUILD_DIR ${PROJECT_SOURCE_DIR}/../bin)# Binariesinstall (TARGETS ${PROJECT_NAME} DESTINATION ${BUILD_DIR})# Header filesinstall(DIRECTORY ${PROJECT_BINARY_DIR}/tinyxml2 DESTINATION ${BUILD_DIR}/include)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a><strong>二、常用命令</strong></h2><h4 id="1-指定-cmake-的最小版本"><a href="#1-指定-cmake-的最小版本" class="headerlink" title="1.指定 cmake 的最小版本"></a>1.指定 cmake 的最小版本</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">cmake_minimum_required</span><span class="token punctuation">(</span>VERSION <span class="token number">3.4</span><span class="token number">.1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这行命令是可选的，我们可以不写这句话，但在有些情况下，如果 CMakeLists.txt 文件中使用了一些高版本 cmake 特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行 cmake。</p><h4 id="2-设置项目名称"><a href="#2-设置项目名称" class="headerlink" title="2.设置项目名称"></a>2.设置项目名称</h4><pre class="line-numbers language-none"><code class="language-none">project(demo VERSION 1.0.0 LANGUAGES C CXX)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个命令不是强制性的，但最好都加上。它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。</p><p>​        第一个字段是项目名称；通过<code>VERSION</code>指定版本号，格式为<code>main.minor.patch.tweak</code>，并且CMake会将对应的值分别赋值给以下变量（如果没有设置，则为空字符串）：</p><pre class="line-numbers language-none"><code class="language-none">PROJECT_VERSION, &lt;PROJECT-NAME&gt;_VERSIONPROJECT_VERSION_MAJOR, &lt;PROJECT-NAME&gt;_VERSION_MAJORPROJECT_VERSION_MINOR, &lt;PROJECT-NAME&gt;_VERSION_MINORPROJECT_VERSION_PATCH, &lt;PROJECT-NAME&gt;_VERSION_PATCHPROJECT_VERSION_TWEAK, &lt;PROJECT-NAME&gt;_VERSION_TWEAK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-指定编程语言版本"><a href="#3-指定编程语言版本" class="headerlink" title="3.指定编程语言版本"></a>3.指定编程语言版本</h4><p>为了在不同机器上编译更加统一，最好指定语言的版本，比如声明C使用<code>c99</code>标准，C++使用<code>c++11</code>标准：</p><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_C_STANDARD 99)set(CMAKE_CXX_STANDARD 11)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-配置编译选项"><a href="#4-配置编译选项" class="headerlink" title="4.配置编译选项"></a>4.配置编译选项</h4><p>通过命令<code>add_compile_options</code>命令可以为所有编译器配置编译选项（同时对多个编译器生效）； 通过设置变量<code>CMAKE_C_FLAGS</code>可以配置c编译器的编译选项； 而设置变量<code>CMAKE_CXX_FLAGS</code>可配置针对c++编译器的编译选项。 比如：</p><pre class="line-numbers language-none"><code class="language-none">add_compile_options(-Wall -Wextra -pedantic -Werror)set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -pipe -std=c99")set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pipe -std=c++11")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3-设置编译类型"><a href="#3-设置编译类型" class="headerlink" title="3.设置编译类型"></a>3.设置编译类型</h4><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_BUILD_TYPE Debug)add_executable(demo demo.cpp) # 生成可执行文件add_library(common STATIC util.cpp) # 生成静态库add_library(common SHARED util.cpp) # 生成动态库或共享库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过设置变量<code>CMAKE_BUILD_TYPE</code>来配置编译类型，可设置为：<code>Debug</code>、<code>Release</code>、<code>RelWithDebInfo</code>、<code>MinSizeRel</code>等，比如：</p><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_BUILD_TYPE Debug)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以针对不同的编译类型设置不同的编译选项，比如对于<code>Debug</code>版本，开启调试信息，不进行代码优化：</p><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -g -O0")set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -O0")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于<code>Release</code>版本，不包含调试信息，优化等级设置为2：</p><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -O2")set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O2")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>add_library 默认生成是静态库，通过以上命令生成文件名字，<br>在 Linux 下是：<br>demo<br>libcommon.a<br>libcommon.so<br>在 Windows 下是：<br>demo.exe<br>common.lib<br>common.dll</p><h4 id="4-指定编译包含的源文件"><a href="#4-指定编译包含的源文件" class="headerlink" title="4.指定编译包含的源文件"></a>4.指定编译包含的源文件</h4><h5 id="4-1-明确指定包含哪些源文件"><a href="#4-1-明确指定包含哪些源文件" class="headerlink" title="4.1 明确指定包含哪些源文件"></a>4.1 明确指定包含哪些源文件</h5><pre class="line-numbers language-none"><code class="language-none">add_library(demo demo.cpp test.cpp util.cpp)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4-2-搜索所有的-cpp-文件"><a href="#4-2-搜索所有的-cpp-文件" class="headerlink" title="4.2 搜索所有的 cpp 文件"></a>4.2 搜索所有的 cpp 文件</h5><p>aux_source_directory(dir VAR) 发现一个目录下所有的源代码文件并将列表存储在一个变量中。</p><pre class="line-numbers language-none"><code class="language-none">aux_source_directory(. SRC_LIST) # 搜索当前目录下的所有.cpp文件add_library(demo ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="4-3-自定义搜索规则"><a href="#4-3-自定义搜索规则" class="headerlink" title="4.3 自定义搜索规则"></a>4.3 自定义搜索规则</h5><pre class="line-numbers language-none"><code class="language-none">file(GLOB SRC_LIST "*.cpp" "protocol/*.cpp")add_library(demo ${SRC_LIST})# 或者file(GLOB SRC_LIST "*.cpp")file(GLOB SRC_PROTOCOL_LIST "protocol/*.cpp")add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})# 或者file(GLOB_RECURSE SRC_LIST "*.cpp") #递归搜索FILE(GLOB SRC_PROTOCOL RELATIVE "protocol" "*.cpp") # 相对protocol目录下搜索add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})# 或者aux_source_directory(. SRC_LIST)aux_source_directory(protocol SRC_PROTOCOL_LIST)add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-查找指定的库文件"><a href="#5-查找指定的库文件" class="headerlink" title="5.查找指定的库文件"></a>5.查找指定的库文件</h4><p>​        find_library(VAR name path)查找到指定的预编译库，并将它的路径存储在变量中。默认的搜索路径为 cmake 包含的系统库，因此如果是 NDK 的公共库只需要指定库的 name 即可。</p><pre class="line-numbers language-none"><code class="language-none">find_library( # Sets the name of the path variable.              log-lib               # Specifies the name of the NDK library that              # you want CMake to locate.              log )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似的命令还有 find_file()、find_path()、find_program()、find_package()。</p><h4 id="6-设置包含的目录"><a href="#6-设置包含的目录" class="headerlink" title="6.设置包含的目录"></a>6.设置包含的目录</h4><pre class="line-numbers language-none"><code class="language-none">include_directories(    ${CMAKE_CURRENT_SOURCE_DIR}    ${CMAKE_CURRENT_BINARY_DIR}    ${CMAKE_CURRENT_SOURCE_DIR}/include)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Linux 下还可以通过如下方式设置包含的目录</p><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -I${CMAKE_CURRENT_SOURCE_DIR}")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="7-设置链接库搜索目录"><a href="#7-设置链接库搜索目录" class="headerlink" title="7.设置链接库搜索目录"></a>7.设置链接库搜索目录</h4><pre class="line-numbers language-none"><code class="language-none">link_directories(    ${CMAKE_CURRENT_SOURCE_DIR}/libs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Linux 下还可以通过如下方式设置包含的目录</p><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -L${CMAKE_CURRENT_SOURCE_DIR}/libs")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="8-设置-target-需要链接的库"><a href="#8-设置-target-需要链接的库" class="headerlink" title="8.设置 target 需要链接的库"></a>8.设置 target 需要链接的库</h4><pre class="line-numbers language-none"><code class="language-none">target_link_libraries( # 目标库                       demo                        # 目标库需要链接的库                       # log-lib 是上面 find_library 指定的变量名                       ${log-lib} )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在 Windows 下，系统会根据链接库目录，搜索xxx.lib 文件，Linux 下会搜索 xxx.so 或者 xxx.a 文件，如果都存在会优先链接动态库（so 后缀）。</p><h5 id="8-1-指定链接动态库或静态库"><a href="#8-1-指定链接动态库或静态库" class="headerlink" title="8.1 指定链接动态库或静态库"></a>8.1 指定链接动态库或静态库</h5><pre class="line-numbers language-none"><code class="language-none">target_link_libraries(demo libface.a) # 链接libface.atarget_link_libraries(demo libface.so) # 链接libface.so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="8-2-指定全路径"><a href="#8-2-指定全路径" class="headerlink" title="8.2 指定全路径"></a>8.2 指定全路径</h5><pre class="line-numbers language-none"><code class="language-none">target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.a)target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.so)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="8-3-指定链接多个库"><a href="#8-3-指定链接多个库" class="headerlink" title="8.3 指定链接多个库"></a>8.3 指定链接多个库</h5><pre class="line-numbers language-none"><code class="language-none">target_link_libraries(demo    ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.a    boost_system.a    boost_thread    pthread)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="9-设置变量"><a href="#9-设置变量" class="headerlink" title="9.设置变量"></a>9.设置变量</h4><h5 id="9-1-set-直接设置变量的值"><a href="#9-1-set-直接设置变量的值" class="headerlink" title="9.1 set 直接设置变量的值"></a>9.1 set 直接设置变量的值</h5><pre class="line-numbers language-none"><code class="language-none">set(SRC_LIST main.cpp test.cpp)add_executable(demo ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="9-2-set-追加设置变量的值"><a href="#9-2-set-追加设置变量的值" class="headerlink" title="9.2 set 追加设置变量的值"></a>9.2 set 追加设置变量的值</h5><pre class="line-numbers language-none"><code class="language-none">set(SRC_LIST main.cpp)set(SRC_LIST ${SRC_LIST} test.cpp)add_executable(demo ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="9-3-list-追加或者删除变量的值"><a href="#9-3-list-追加或者删除变量的值" class="headerlink" title="9.3 list 追加或者删除变量的值"></a>9.3 list 追加或者删除变量的值</h5><pre class="line-numbers language-none"><code class="language-none">set(SRC_LIST main.cpp)list(APPEND SRC_LIST test.cpp)list(REMOVE_ITEM SRC_LIST main.cpp)add_executable(demo ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="10-条件控制"><a href="#10-条件控制" class="headerlink" title="10.条件控制"></a>10.条件控制</h4><h5 id="10-1-if…elseif…else…endif"><a href="#10-1-if…elseif…else…endif" class="headerlink" title="10.1 if…elseif…else…endif"></a>10.1 if…elseif…else…endif</h5><p><strong>逻辑判断和比较：</strong><br>if (expression)：expression 不为空（0,N,NO,OFF,FALSE,NOTFOUND）时为真<br>if (not exp)：与上面相反<br>if (var1 AND var2)<br>if (var1 OR var2)<br>if (COMMAND cmd)：如果 cmd 确实是命令并可调用为真<br>if (EXISTS dir) if (EXISTS file)：如果目录或文件存在为真<br>if (file1 IS_NEWER_THAN file2)：当 file1 比 file2 新，或 file1/file2 中有一个不存在时为真，文件名需使用全路径<br>if (IS_DIRECTORY dir)：当 dir 是目录时为真<br>if (DEFINED var)：如果变量被定义为真<br>if (var MATCHES regex)：给定的变量或者字符串能够匹配正则表达式 regex 时为真，此处 var 可以用 var 名，也可以用 ${var}<br>if (string MATCHES regex)</p><p><strong>数字比较：</strong><br>if (variable LESS number)：LESS 小于<br>if (string LESS number)<br>if (variable GREATER number)：GREATER 大于<br>if (string GREATER number)<br>if (variable EQUAL number)：EQUAL 等于<br>if (string EQUAL number)</p><p><strong>字母表顺序比较：</strong><br>if (variable STRLESS string)<br>if (string STRLESS string)<br>if (variable STRGREATER string)<br>if (string STRGREATER string)<br>if (variable STREQUAL string)<br>if (string STREQUAL string)</p><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">if(MSVC)    set(LINK_LIBS common)else()    set(boost_thread boost_log.a boost_system.a)endif()target_link_libraries(demo ${LINK_LIBS})# 或者if(UNIX)    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -fpermissive -g")else()    add_definitions(-D_SCL_SECURE_NO_WARNINGS    D_CRT_SECURE_NO_WARNINGS    -D_WIN32_WINNT=0x601    -D_WINSOCK_DEPRECATED_NO_WARNINGS)endif() if(${CMAKE_BUILD_TYPE} MATCHES "debug")    ...else()    ...endif()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="10-2-while…endwhile"><a href="#10-2-while…endwhile" class="headerlink" title="10.2 while…endwhile"></a>10.2 while…endwhile</h5><pre class="line-numbers language-none"><code class="language-none">while(condition)    ...endwhile()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="10-3-foreach…endforeach"><a href="#10-3-foreach…endforeach" class="headerlink" title="10.3 foreach…endforeach"></a>10.3 foreach…endforeach</h5><pre class="line-numbers language-none"><code class="language-none">foreach(loop_var RANGE start stop [step])    ...endforeach(loop_var)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>start 表示起始数，stop 表示终止数，step 表示步长，示例：</code></pre><pre class="line-numbers language-none"><code class="language-none">foreach(i RANGE 1 9 2)    message(${i})endforeach(i)# 输出：13579<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="11-打印信息"><a href="#11-打印信息" class="headerlink" title="11.打印信息"></a>11.打印信息</h4><pre class="line-numbers language-none"><code class="language-none">message(${PROJECT_SOURCE_DIR})message("build with debug mode")message(WARNING "this is warnning message")message(FATAL_ERROR "this build has many error") # FATAL_ERROR 会导致编译失败<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="12-包含其它-cmake-文件"><a href="#12-包含其它-cmake-文件" class="headerlink" title="12.包含其它 cmake 文件"></a>12.包含其它 cmake 文件</h4><pre class="line-numbers language-none"><code class="language-none">include(./common.cmake) # 指定包含文件的全路径include(def) # 在搜索路径中搜索def.cmake文件set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake) # 设置include的搜索路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="三、常用变量"><a href="#三、常用变量" class="headerlink" title="三、常用变量"></a>三、常用变量</h2><h4 id="1-预定义变量"><a href="#1-预定义变量" class="headerlink" title="1.预定义变量"></a>1.预定义变量</h4><pre class="line-numbers language-none"><code class="language-none">PROJECT_SOURCE_DIR：工程的根目录PROJECT_BINARY_DIR：运行 cmake 命令的目录，通常是 ${PROJECT_SOURCE_DIR}/buildPROJECT_NAME：返回通过 project 命令定义的项目名称CMAKE_CURRENT_SOURCE_DIR：当前处理的 CMakeLists.txt 所在的路径CMAKE_CURRENT_BINARY_DIR：target 编译目录CMAKE_CURRENT_LIST_DIR：CMakeLists.txt 的完整路径CMAKE_CURRENT_LIST_LINE：当前所在的行CMAKE_MODULE_PATH：定义自己的 cmake 模块所在的路径，SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)，然后可以用INCLUDE命令来调用自己的模块EXECUTABLE_OUTPUT_PATH：重新定义目标二进制可执行文件的存放位置LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的存放位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-环境变量"><a href="#2-环境变量" class="headerlink" title="2.环境变量"></a>2.环境变量</h4><p>使用环境变量</p><pre class="line-numbers language-none"><code class="language-none">$ENV{Name}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>写入环境变量</p><pre class="line-numbers language-none"><code class="language-none">set(ENV{Name} value) # 这里没有“$”符号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-系统信息"><a href="#3-系统信息" class="headerlink" title="3.系统信息"></a>3.系统信息</h4><pre class="line-numbers language-none"><code class="language-none">CMAKE_MAJOR_VERSION：cmake 主版本号，比如 3.4.1 中的 3CMAKE_MINOR_VERSION：cmake 次版本号，比如 3.4.1 中的 4CMAKE_PATCH_VERSION：cmake 补丁等级，比如 3.4.1 中的 1CMAKE_SYSTEM：系统名称，比如 Linux-2.6.22CMAKE_SYSTEM_NAME：不包含版本的系统名，比如 LinuxCMAKE_SYSTEM_VERSION：系统版本，比如 2.6.22CMAKE_SYSTEM_PROCESSOR：处理器名称，比如 i686UNIX：在所有的类 UNIX 平台下该值为 TRUE，包括 OS X 和 cygwinWIN32：在所有的 win32 平台下该值为 TRUE，包括 cygwin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-主要开关选项"><a href="#4-主要开关选项" class="headerlink" title="4.主要开关选项"></a>4.主要开关选项</h4><p>​        BUILD_SHARED_LIBS：这个开关用来控制默认的库编译方式，如果不进行设置，使用 add_library 又没有指定库类型的情况下，默认编译生成的库都是静态库。如果 set(BUILD_SHARED_LIBS ON) 后，默认生成的为动态库<br>CMAKE_C_FLAGS：设置 C 编译选项，也可以通过指令 add_definitions() 添加<br>CMAKE_CXX_FLAGS：设置 C++ 编译选项，也可以通过指令 add_definitions() 添加</p><pre class="line-numbers language-none"><code class="language-none">add_definitions(-DENABLE_DEBUG -DABC) # 参数之间用空格分隔<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-自定义编译选项"><a href="#5-自定义编译选项" class="headerlink" title="5.自定义编译选项"></a>5.自定义编译选项</h4><p>​        cmake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。例如，可以将 MathFunctions 库设为一个可选的库，如果该选项为 ON ，就使用该库定义的数学函数来进行运算，否则就调用标准库中的数学函数库。修改根目录下的 CMakeLists.txt 文件如下：</p><pre class="line-numbers language-none"><code class="language-none"># CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo)# 加入一个配置头文件，用于处理 CMake 对源码的设置configure_file (    "${PROJECT_SOURCE_DIR}/config.h.in"    "${PROJECT_BINARY_DIR}/config.h"    )# 是否使用自己的 MathFunctions 库option (USE_MYMATH        "Use provided math implementation" ON)# 是否加入 MathFunctions 库if (USE_MYMATH)    include_directories ("${PROJECT_SOURCE_DIR}/math")    add_subdirectory (math)    set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)endif (USE_MYMATH)# 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable(Demo ${DIR_SRCS})target_link_libraries (Demo ${EXTRA_LIBS})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>configure_file 命令用于加入一个配置头文件 config.h ，这个文件由 cmake 从 config.h.in 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。</li><li>option 命令添加了一个 USE_MYMATH 选项，并且默认值为 ON 。根据 USE_MYMATH 变量的值来决定是否使用我们自己编写的 MathFunctions 库。修改 main.cc 文件，让其根据 USE_MYMATH 的预定义值来决定是否调用标准库还是MathFunctions 库：</li></ul><pre class="line-numbers language-none"><code class="language-none">#include "config.h"#ifdef USE_MYMATH    #include "math/MathFunctions.h"#else    #include &lt;math.h&gt;#endif int main(int argc, char *argv[]){    if (argc &lt; 3){        printf("Usage: %s base exponent \n", argv[0]);        return 1;    }    double base = atof(argv[1]);    int exponent = atoi(argv[2]); #ifdef USE_MYMATH    printf("Now we use our own Math library. \n");    double result = power(base, exponent);#else    printf("Now we use the standard library. \n");    double result = pow(base, exponent);#endif    printf("%g ^ %d is %g\n", base, exponent, result);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写 config.h.in 文件<br>        注意 main.cc 的第一行，这里引用了一个 config.h 文件，这个文件预定义了 USE_MYMATH 的值。但我们并不直接编写这个文件，为了方便从 CMakeLists.txt 中导入配置，我们编写一个 config.h.in 文件，内容如下：</p><pre class="line-numbers language-none"><code class="language-none">#cmakedefine USE_MYMATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样 cmake 会自动根据 CMakeLists.txt 配置文件中的设置自动生成 config.h 文件。</p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Base64的编码原理</title>
      <link href="/2022/04/07/base64-de-bian-ma-yuan-li/"/>
      <url>/2022/04/07/base64-de-bian-ma-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="Base64的编码原理"><a href="#Base64的编码原理" class="headerlink" title="Base64的编码原理"></a><strong>Base64的编码原理</strong></h2><h3 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h3><ul><li><p>将待转换的字符串每三个字节分为一组，每个字节占8bit，那么共有24个二进制位。</p></li><li><p>将上面的24个二进制位每6个一组，共分为4组。</p></li><li><p>在每组前面添加两个0，每组由6个变为8个二进制位，总共32个二进制位，即四个字节。</p></li></ul><h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><h4 id="1-示例"><a href="#1-示例" class="headerlink" title="1.示例"></a>1.示例</h4><ul><li><p>“M”、“a”、”n”对应的ASCII码值分别为77，97，110，对应的二进制值是01001101、01100001、01101110。如图第二三行所示，由此组成一个24位的二进制字符串。</p></li><li><p>如图红色框，将24位每6位二进制位一组分成四组。</p></li><li><p>在上面每一组前面补两个0，扩展成32个二进制位，此时变为四个字节：00010011、00010110、00000101、00101110。分别对应的值（Base64编码索引）为：19、22、5、46。</p></li><li><p>用上面的值在Base64编码表中进行查找，分别对应：T、W、F、u。因此“Man”Base64编码之后就变为：TWFu。</p></li></ul><p><img src="./Base64%E7%9A%84%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/base64_2.png" alt="img"></p><h4 id="2-位数不足情况"><a href="#2-位数不足情况" class="headerlink" title="2.位数不足情况"></a>2.<strong>位数不足情况</strong></h4><p>​        一个字节：一个字节共8个二进制位，依旧按照规则进行分组。此时共8个二进制位，每6个一组，则第二组缺少4位，用0补齐，得到两个Base64编码，而后面两组没有对应数据，都用“=”补上。因此，上图中“A”转换之后为“QQ==”；        </p><p>​        两个字节：两个字节共16个二进制位，依旧按照规则进行分组。此时总共16个二进制位，每6个一组，则第三组缺少2位，用0补齐，得到三个Base64编码，第四组完全没有数据则用“=”补上。因此，上图中“BC”转换之后为“QKM=”；</p><p><img src="./Base64%E7%9A%84%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/base64_2.png" alt="img"></p><h4 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.<strong>注意事项</strong></h4><p>​        大多数编码都是由字符串转化成二进制的过程，而Base64的编码则是从二进制转换为字符串。与常规恰恰相反，Base64编码主要用在传输、存储、表示二进制领域，不能算得上加密，只是无法直接看到明文。也可以通过打乱Base64编码来进行加密。中文有多种编码（比如：utf-8、gb2312、gbk等），不同编码对应Base64编码结果都不一样。</p><h4 id="4-延伸"><a href="#4-延伸" class="headerlink" title="4.延伸"></a>4.<strong>延伸</strong></h4><p>​        上面我们已经看到了Base64就是用6位（2的6次幂就是64）表示字符，因此成为Base64。同理，Base32就是用5位，Base16就是用4位。大家可以按照上面的步骤进行演化一下。</p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Base64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2022/04/06/wei-yun-suan/"/>
      <url>/2022/04/06/wei-yun-suan/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>[TOC]</p><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>基本的位操作符有与、或、异或、取反、左移、右移这6种:</p><table><thead><tr><th>符号</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td><td>两个bit都为1，才为1</td></tr><tr><td>|</td><td>或</td><td>两个bit都为0，才为0</td></tr><tr><td>^</td><td>异或</td><td>两个bit相同为0，不同为1</td></tr><tr><td>~</td><td>取反</td><td>0变1，1变0</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>左移若干位，高位丢弃，低位补0</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>右移若干位，无符号数高位补0，有符号数不同编译器处理不同，有的补符号位（算术右移），有的补0（逻辑右移）</td></tr></tbody></table><h2 id="位运算示例操作"><a href="#位运算示例操作" class="headerlink" title="位运算示例操作"></a>位运算示例操作</h2><table><thead><tr><th>位运算</th><th>功能</th><th>示例</th><th></th></tr></thead><tbody><tr><td>x &gt;&gt; 1</td><td>去掉最后一位</td><td>101101-&gt;10110</td><td></td></tr><tr><td>x &lt;&lt; 1</td><td>在最后加一个0</td><td>101101-&gt;1011010</td><td></td></tr><tr><td>x &lt;&lt; 1</td><td>在最后加一个1</td><td>101101-&gt;1011011</td><td></td></tr><tr><td>x\</td><td>1</td><td>把最后一位变成1</td><td>101100-&gt;101101</td></tr><tr><td>x &amp; -2</td><td>把最后一位变成0</td><td>101101-&gt;101100</td><td></td></tr><tr><td>x ^ 1</td><td>最后一位取反</td><td>101101-&gt;101100</td><td></td></tr><tr><td>x \</td><td>(1 &lt;&lt; (k-1))</td><td>把右数第k位变成1</td><td>101001-&gt;101101,k=3</td></tr><tr><td>x &amp; ~ (1 &lt;&lt; (k-1))</td><td>把右数第k位变成0</td><td>101101-&gt;101001,k=3</td><td></td></tr><tr><td>x ^(1 &lt;&lt;(k-1))</td><td>右数第k位取反</td><td>101001-&gt;101101,k=3</td><td></td></tr><tr><td>x &amp; 7</td><td>取末三位</td><td>1101101-&gt;101</td><td></td></tr><tr><td>x &amp; (1 &lt;&lt; k-1)</td><td>取末k位</td><td>1101101-&gt;1101,k=5</td><td></td></tr><tr><td>x &gt;&gt; (k-1) &amp; 1</td><td>取右数第k位</td><td>1101101-&gt;1,k=4</td><td></td></tr><tr><td>x \</td><td>((1 &lt;&lt; k)-1)</td><td>把末k位变成1</td><td>101001-&gt;101111,k=4</td></tr><tr><td>x ^ (1 &lt;&lt; k-1)</td><td>末k位取反</td><td>101001-&gt;100110,k=4</td><td></td></tr><tr><td>x &amp; (x+1)</td><td>把右边连续的1变成0</td><td>100101111-&gt;100100000</td><td></td></tr><tr><td>x \</td><td>(x+1)</td><td>把右起第一个0变成1</td><td>100101111-&gt;100111111</td></tr><tr><td>x \</td><td>(x-1)</td><td>把右边连续的0变成1</td><td>11011000-&gt;11011111</td></tr><tr><td>(x ^ (x+1)) &gt;&gt; 1</td><td>取右边连续的1</td><td>100101111-&gt;1111</td><td></td></tr><tr><td>x &amp; -x</td><td>去掉右起第一个1的左边</td><td>100101000-&gt;1000</td><td></td></tr><tr><td>x&amp;0x7F</td><td>取末7位</td><td>100101000-&gt;101000</td><td></td></tr><tr><td>x&amp; ~0x7F</td><td>是否小于127</td><td>001111111 &amp; ~0x7F-&gt;0</td><td></td></tr><tr><td>x &amp; 1</td><td>判断奇偶</td><td>00000111&amp;1-&gt;1</td><td></td></tr></tbody></table><p>使用位运算的两点注意事项：</p><ol><li>位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。</li><li>位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序</li></ol><h3 id="1-判断一个数值是不是2的整数次方"><a href="#1-判断一个数值是不是2的整数次方" class="headerlink" title="1. 判断一个数值是不是2的整数次方"></a>1. 判断一个数值是不是2的整数次方</h3><p>解题思路：</p><p>2的整数次方对应的二进制的最高位上只有一个1，如：8，二进制为 1000； 4，二进制为 0100，</p><p>那么将该数字减去1再与该数字进行与运算，减去1 后得到二进制：7，二进制为 0111；3，二进制为 0011，可以看出 8&amp;7 为0，</p><p>4&amp;3 为0</p><p>所以，如果 n 是2的整数次方，那么 n &amp; ( n - 1 )结果一定为0:</p><p>n 的数值要大于 0 </p><h3 id="2-使用位运算交换两个数字【不使用中间变量】"><a href="#2-使用位运算交换两个数字【不使用中间变量】" class="headerlink" title="2. 使用位运算交换两个数字【不使用中间变量】"></a>2. 使用位运算交换两个数字【不使用中间变量】</h3><pre class="line-numbers language-none"><code class="language-none">1.  public class Main {3.      public static void main(String[] args) {4.          int n = 8, m = 10;5.          n ^= m;6.          m ^= n;7.          n ^= m;8.          System.out.println(n + ", " + m);9.      }10.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如： a = 13, b = 6:<br>a的二进制为 13 = 8 + 4 + 1 = 1101(二进制)<br>b的二进制为 6 = 4 + 2 = 110(二进制)</p><ol><li>a ^= b a = 1101 ^ 110 = 1011;</li><li>b ^= a b = 110 ^ 1011 = 1101; 即b == 13</li><li>a ^= b a = 1011 ^ 1101 = 110; 即a == 6</li></ol><p>其他方法，<strong>使用加减法</strong></p><pre class="line-numbers language-none"><code class="language-none">1.  public class Main {3.      public static void main(String[] args) {4.          int n = 8, m = 10;5.          n = n + m;6.          m = n - m;7.          n = n - m;8.          System.out.println(n + ", " + m);9.      }10.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-计算在一个-32-位的整数的二进制表示中有多少个-1"><a href="#3-计算在一个-32-位的整数的二进制表示中有多少个-1" class="headerlink" title="3. 计算在一个 32 位的整数的二进制表示中有多少个 1"></a>3. 计算在一个 32 位的整数的二进制表示中有多少个 1</h3><p>循环使用x &amp; (x-1)消去最后一位1，计算总共消去了多少次即可。如：</p><p>13： 1101</p><p>12： 1100</p><p>相与：1100， 消去最后一位</p><pre class="line-numbers language-none"><code class="language-none">1.  public class Main {3.      public static void main(String[] args) {4.          // 计算在一个 32 位的整数的二进制表示中有多少个 15.          int m = 13, num = 0;6.          while (true){7.              if (m == 0) break;8.              m &amp;= (m-1); 9.              num ++; 10.          }11.          System.out.println(num);12.      }14.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-正数变成负数，或者负数变成正数"><a href="#4-正数变成负数，或者负数变成正数" class="headerlink" title="4. 正数变成负数，或者负数变成正数"></a>4. 正数变成负数，或者负数变成正数</h3><p><strong>变换符号只需要取反后加1即可</strong></p><pre class="line-numbers language-none"><code class="language-none">1.  public class Main {3.      public static void main(String[] args) { 5.          int m = -13; 6.          int changeM = ~m + 1; 7.          System.out.println(changeM);8.      }10.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-判断一个数值的奇偶"><a href="#5-判断一个数值的奇偶" class="headerlink" title="5. 判断一个数值的奇偶"></a>5. 判断一个数值的奇偶</h3><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数，所以只需要与 1 相与。</p><p>因此可以用if ((a &amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。</p><pre class="line-numbers language-none"><code class="language-none">1.  public class Main {3.      public static void main(String[] args) {  4.          int m = -14;6.          if ((m &amp; 1) == 1){7.              System.out.println("ji");8.          }else{9.              System.out.println("ou"); 10.          }  11.      }13.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-乘以2-的m次方操作"><a href="#6-乘以2-的m次方操作" class="headerlink" title="6. 乘以2 的m次方操作"></a>6. 乘以2 的m次方操作</h3><p>乘以2的操作，即2的1次方，左移 1 位</p><pre class="line-numbers language-none"><code class="language-none">System.out.println(10&lt;&lt;1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>推导扩展，乘以2的m次方：</p><pre class="line-numbers language-none"><code class="language-none">System.out.println(10&lt;&lt;2); // 乘以 2的2次方，相当于乘以 4 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-除以2运算-负奇数的运算不可用"><a href="#7-除以2运算-负奇数的运算不可用" class="headerlink" title="7.除以2运算(负奇数的运算不可用)"></a>7.除以2运算(负奇数的运算不可用)</h3><pre class="line-numbers language-none"><code class="language-none">System.out.println(10&gt;&gt;1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="8-转换成绝对值"><a href="#8-转换成绝对值" class="headerlink" title="8. 转换成绝对值"></a>8. 转换成绝对值</h3><pre class="line-numbers language-none"><code class="language-none">1.  public class Main {3.      public static void main(String[] args) {  4.          int n = 12;6.          System.out.println(0 &gt;&gt; 31); // 0 7.          System.out.println(10 &gt;&gt; 31);  // 0  8.          System.out.println(-10 &gt;&gt; 31);  // -110.          System.out.println((n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31));  // 12 12.      }14.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.首先：n&gt;&gt;31 取得n的符号</p><p>若n为正数，n&gt;&gt;31等于0；若n为负数，n&gt;&gt;31等于-1 若n为正数 n^0-0数不变；</p><ol><li>若 n 为负数 n^-1 需要计算 n 和 -1 的补码，异或后再取补码， 结果n变号并且绝对值减1，再减去-1就是绝对值</li></ol><h3 id="9-判断两数符号是否相同"><a href="#9-判断两数符号是否相同" class="headerlink" title="9.判断两数符号是否相同"></a>9.判断两数符号是否相同</h3><p>true 表示 x和y有相同的符号， false表示x，y有相反的符号。</p><pre class="line-numbers language-none"><code class="language-none">System.out.println((a ^ b) &gt; 0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="10-求两个整数（int）的平均数"><a href="#10-求两个整数（int）的平均数" class="headerlink" title="10. 求两个整数（int）的平均数"></a>10. 求两个整数（int）的平均数</h3><pre class="line-numbers language-none"><code class="language-none">System.out.println((a+b) &gt;&gt; 1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="11-求两个整数的最大值"><a href="#11-求两个整数的最大值" class="headerlink" title="11. 求两个整数的最大值"></a>11. 求两个整数的最大值</h3><pre class="line-numbers language-none"><code class="language-none">1.  int max(int a,int b){2.      return b &amp; ((a-b) &gt;&gt; 31) | a &amp; (~(a-b) &gt;&gt; 31);3.      /*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/4.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-求两个整数的最小值"><a href="#12-求两个整数的最小值" class="headerlink" title="12.求两个整数的最小值"></a>12.求两个整数的最小值</h3><pre class="line-numbers language-none"><code class="language-none">1.  int min(int a,int b){2.      return a &amp; ((a-b) &gt;&gt; 31) | b &amp; (~(a-b) &gt;&gt; 31);3.      /*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/4.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-两个整数的加法运算"><a href="#13-两个整数的加法运算" class="headerlink" title="13. 两个整数的加法运算"></a>13. <strong>两个整数的加法运算</strong></h3><p>使用 <code>^</code> 和 <code>&amp;</code> 将两个整数相加</p><ol><li>两个数异或：相当于两个数相加，而不考虑进位；</li><li>两个数相与，并左移一位：相当于求得进位；</li></ol><pre class="line-numbers language-none"><code class="language-none">13+11 = ？;13 的二进制      1 1 0 1                     -----a        1311 的二进制      1 0 1 1                     -----b        11   (a&amp;b) &lt;&lt;1  -&gt;   1 0 0 1 0                         -----d         18          a^b  -&gt;     0 1 1 0                   -----e          6 (d&amp;e) &lt;&lt;1  -&gt;   0 0 1 0 0                       ------f         4          d^e  -&gt;  1 0 1 0 0                  -----g        20 (f&amp;g) &lt;&lt;1  -&gt;   0 1 0 0 0                       ------h        8          f^g  -&gt;  1 0 0 0 0                   ------i           16 (h&amp;i) &lt;&lt;1  -&gt;   0 0 0 0 0                      ------h        0       ---- -------- 没有进位了， 则退出循环          h^i  -&gt;  1 1 0 0 0                  ------i           24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">1.  private static int getSum(int a, int b) {2.      if (a == 0) return b;3.      if (b == 0) return a;4.      while (b != 0) {5.          int carry = a &amp; b; // 得到有进位的位置6.          a = a ^ b; // 直接相加，但是没有进位7.          b = carry &lt;&lt; 1; // 得到进位8.      }9.      return a;10.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程的理解</title>
      <link href="/2022/04/05/mian-xiang-dui-xiang-bian-cheng-de-li-jie/"/>
      <url>/2022/04/05/mian-xiang-dui-xiang-bian-cheng-de-li-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h2><h3 id="面向过程思想概述"><a href="#面向过程思想概述" class="headerlink" title="面向过程思想概述"></a>面向过程思想概述</h3><p>面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。</p><h3 id="面向对象思想概述"><a href="#面向对象思想概述" class="headerlink" title="面向对象思想概述"></a>面向对象思想概述</h3><p>当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了，这时就开始思索，能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。面向对象是基于面向过程的编程思想。</p><h2 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h2><ul><li>抽象</li><li>封装</li><li>继承</li><li>多态</li></ul><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>把现实世界中的某一类东西，提取出来，用程序代码表示，抽象出来的一般叫做类或者接口。抽象并不打算了解全部问题，而是选择其中的一部分，暂时不用部分细节。抽象包括两个方面：</p><ul><li>数据抽象：表示世界中一类事物的特征,就是对象的属性.比如鸟有翅膀,羽毛等(类的属性)</li><li>过程抽象：表示世界中一类事物的行为,就是对象的行为.比如鸟会飞,会叫(类的方法)</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。隐藏之后，外部程序就不能接触和改变那些细节，所以不用担心自己的类会受到非法修改，可确保它们不会对其他程序造成影响。</p><h4 id="封装的原则"><a href="#封装的原则" class="headerlink" title="封装的原则"></a>封装的原则</h4><ul><li>将不需要对外提供的内容都隐藏起来</li><li>把属性都隐藏，提供公共方法对其访问</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>一种联结类的层次模型，并且允许和鼓励类的重用，提供一种明确表达共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类(子类)，原始类称为新类的基类(父类)。派生类可以从它的父类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。因此可以说，继承为了重用父类代码，同时为实现多态性作准备。</p><h4 id="继承概念的实现方式"><a href="#继承概念的实现方式" class="headerlink" title="继承概念的实现方式"></a>继承概念的实现方式</h4><ul><li>类继承：类继承是指直接使用基类的属性和方法而无需额外编码。</li><li>接口继承：接口继承是指仅使用属性和方法的名称、但是子类必须提供实现。</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><h4 id="实现多态的方式"><a href="#实现多态的方式" class="headerlink" title="实现多态的方式"></a>实现多态的方式</h4><ul><li>重载</li><li>重写</li><li>实现接口</li></ul><h2 id="面向对象总结"><a href="#面向对象总结" class="headerlink" title="面向对象总结"></a>面向对象总结</h2><p>封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了<strong>代码重用</strong>。而多态则是为了实现另一个目的：<strong>接口重用</strong>！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。</p><h3 id="面向对象开发"><a href="#面向对象开发" class="headerlink" title="面向对象开发"></a>面向对象开发</h3><p>就是不断的创建对象，使用对象，指挥对象做事情。</p><h3 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h3><p>更好的管理和维护对象之间的关系。</p><h3 id="面向对象优点"><a href="#面向对象优点" class="headerlink" title="面向对象优点"></a>面向对象优点</h3><ul><li>更符合我们思想习惯的思想</li><li>将复杂的事情简单化</li><li>将我们从执行者变成了指挥者</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源许可协议 GNU GPL</title>
      <link href="/2022/04/04/kai-yuan-xu-ke-xie-yi-gnu-gpl/"/>
      <url>/2022/04/04/kai-yuan-xu-ke-xie-yi-gnu-gpl/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>​        在开源领域中，许可协议是指开源社区为了维护作者和贡献者的合法权利，保证软件不被一些商业机构或个人窃取，影响软件的发展而开发的协议。其中，GPL是开源许可协议中非常流行的许可协议之一。</p><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a><strong>一、基本概念</strong></h2><p><img src="./%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE-GNU-GPL/GPL.png"></p><p>​                                                                   GPL标志</p><p>​        GNU通用公共许可协议（英语：GNU General Public License，缩写GNU GPL 或 GPL），GPL是由理查德·斯托曼于1989年编写，最初提供给列入GNU项目的一些软件程序所使用。</p><p>​        GPL是自由软件和开源软件的最流行许可证。到2004年4月，GPL已占Freshmeat上所列的自由软件的约75%，SourceForge的约68%。类似的，2001年一项关于Red Hat Linux 7.1的调查显示一般的代码都以GPL发布。</p><h2 id="二、协议特点"><a href="#二、协议特点" class="headerlink" title="二、协议特点"></a><strong>二、协议特点</strong></h2><h3 id="2-1-传染性"><a href="#2-1-传染性" class="headerlink" title="2.1 传染性"></a><strong>2.1 传染性</strong></h3><p>​        GPL协议具有一个很显著的特点“传染性” ：即当具有GPL协议的软件与其它协议的软件相组合或者GPL的衍生产品，必须按照GPL的条款分发。“衍生产品”通常被解释为包含GPL代码或动态链接到GPL库的软件。GPL下所有衍生产品都必须属于GPL，许可证是根据著作权法运行的。</p><h3 id="2-2-可商用"><a href="#2-2-可商用" class="headerlink" title="2.2 可商用"></a><strong>2.2 可商用</strong></h3><p>​        GPL软件可以用于盈利，可以以任何价格出售，可以作为创建专有软件的工具（例如：GPL协议的编译器）。</p><h2 id="三、使用者的自由"><a href="#三、使用者的自由" class="headerlink" title="三、使用者的自由"></a><strong>三、使用者的自由</strong></h2><h3 id="1-自由运行"><a href="#1-自由运行" class="headerlink" title="1. 自由运行"></a><strong>1. 自由运行</strong></h3><p>​    可以按照自己的意愿运行软件；</p><h3 id="2-自由修改"><a href="#2-自由修改" class="headerlink" title="2. 自由修改"></a><strong>2. 自由修改</strong></h3><p>可以按己的意愿修改软件；</p><h3 id="3-自由复制"><a href="#3-自由复制" class="headerlink" title="3. 自由复制"></a><strong>3. 自由复制</strong></h3><p>可以自由分发软件副本；</p><h3 id="4-自由分发"><a href="#4-自由分发" class="headerlink" title="4. 自由分发"></a><strong>4. 自由分发</strong></h3><p>可以将你修改过的软件版本再分发给其他人，从而回馈开源，促进开源；</p><h2 id="四、符合GPL协议的软件"><a href="#四、符合GPL协议的软件" class="headerlink" title="四、符合GPL协议的软件"></a><strong>四、符合GPL协议的软件</strong></h2><p>著名的GPL自由软件包括EMACS，Linux内核（并非所有Linux发行版的内核都是开源的）和<a href="https://so.csdn.net/so/search?q=GCC&amp;spm=1001.2101.3001.7020">GCC</a>。</p><h2 id="五、GPL发展阶段"><a href="#五、GPL发展阶段" class="headerlink" title="五、GPL发展阶段"></a><strong>五、GPL发展阶段</strong></h2><p><strong>GPLv1：</strong>解决了软件经销商只分发软件的二进制，而不提供软件源码的问题；要求符合GPL的软件与其它软件组合后的整体必须以GPLv1条款分发，限制了经销商增加许可证的限制；</p><p><strong>GPLv2：</strong>规定被许可人只有在满足所有许可证的义务下才可以分发包含GPL许可的软件，就算有相互矛盾的义务，许可证的义务也可能不被切断，阻止任何一方使用专利侵权索赔或其他诉讼来损害用户在许可证下的自由；</p><p>**GPLv3提高了与许多开放源代码软件许可证（如Apache许可证版本2.0）和GNU Affero通用公共许可证（GPLv2无法组合）的兼容性；比较有意思的是，林纳斯·托瓦兹（Linux内核的发明人及该计划的合作者）决定不采用GPLv3作为Linux内核的许可协议，仍然使用GPLv2许可。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>GPL 维护了代码所有者的合法权益，保证了代码以及其衍生产品的开源，从而促进了代码的开源，让众多的软件开发者不断地从中收益，同时也不断的回馈开源社区，让开源队伍越来越壮大！</p>]]></content>
      
      
      <categories>
          
          <category> 开源协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几种常见的开源协议介绍</title>
      <link href="/2022/04/03/ji-chong-chang-jian-de-kai-yuan-xie-yi-jie-shao/"/>
      <url>/2022/04/03/ji-chong-chang-jian-de-kai-yuan-xie-yi-jie-shao/</url>
      
        <content type="html"><![CDATA[<h1 id="开源协议介绍"><a href="#开源协议介绍" class="headerlink" title="开源协议介绍"></a>开源协议介绍</h1><p>[TOC]</p><h2 id="一、几种常见的开源协议介绍"><a href="#一、几种常见的开源协议介绍" class="headerlink" title="一、几种常见的开源协议介绍"></a>一、几种常见的开源协议介绍</h2><p>常用的几种开源协议：</p><ul><li><p><strong>GPL （GNU General Public License） ：GNU通用公共许可协议</strong></p></li><li><p><strong>LGPL （GNU Lesser General Public License） ：GNU宽通用公共许可协议</strong></p></li><li><p><strong>BSD (Berkeley Software Distribution) :伯克利软件分发许可协议</strong></p></li><li><p><strong>MIT （Massachusetts Institute of Technology）：MIT许可协议之名源自麻省理工学院，又称“X许可协议”或“X11许可协议”</strong></p></li><li><p><strong>Apache （Apache License） ：Apache许可协议</strong></p></li><li><p><strong>MPL （Mozilla Public License） ：Mozilla公共许可协议</strong></p></li></ul><h3 id="1-BSD协议"><a href="#1-BSD协议" class="headerlink" title="1.BSD协议"></a>1.BSD协议</h3><p>​        BSD开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。但前提是发布使用了BSD协议的代码，或以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： </p><ul><li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li><li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 </li></ul><p>​        BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p><h3 id="2-MIT协议"><a href="#2-MIT协议" class="headerlink" title="2.MIT协议"></a>2.MIT协议</h3><p>​        MIT是和BSD一样宽范的许可协议，源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称X11协议。作者只想保留版权,而无任何其他了限制。MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。<br>​        MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。 </p><ul><li>被授权人有权利使用、复制、修改、合并、出版发行、散布、再授权及贩售软件及软件的副本。</li><li>被授权人可根据程序的需要修改授权条款为适当的内容。</li><li>在软件和软件的所有副本中都必须包含版权声明和许可声明。 </li></ul><p>​        此授权条款并非属copyleft的自由软件授权条款，允许在自由/开放源码软件或非自由软件（proprietary software）所使用。MIT的内容可依照程序著作权者的需求更改内容。此亦为MIT与BSD（The BSD license, 3-clause BSD license）本质上不同处。MIT条款可与其他授权条款并存。另外，MIT条款也是自由软件基金会（FSF）所认可的自由软件授权条款，与GPL兼容。</p><h3 id="3-Apache-协议"><a href="#3-Apache-协议" class="headerlink" title="3.Apache 协议"></a>3.Apache 协议</h3><p>​        Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件： </p><ol><li>需要给代码的用户一份Apache Licence。</li><li>如果修改了代码，需要再被修改的文件中说明。</li><li>在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li><li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。 </li></ol><p>使用这个协议的好处是: </p><ol><li>永久权利：一旦被授权，永久拥有。</li><li>全球范围的权利：在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。</li><li>授权免费：无版税， 前期、后期均无任何费用。</li><li>授权无排他性：任何人都可以获得授权</li><li>授权不可撤消 一旦获得授权，没有任何人可以取消。 </li></ol><p>Apache Licence也是对商业应用友好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。</p><h3 id="4-GPL协议"><a href="#4-GPL协议" class="headerlink" title="4.GPL协议"></a>4.GPL协议</h3><p>GPL（ GNU General Public Licence ）的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。Linux就是采用了GPL协议。</p><ol><li>可自由复制：你可以将软件复制到你的电脑，你客户的电脑，或者任何地方。复制份数没有任何限制。</li><li>可自由分发：在你的网站提供下载，拷贝到U盘送人，或者将源代码打印出来从窗户扔出去（环保起见，请别这样做）。</li><li>可以用来盈利：你可以在分发软件的时候收费，但你必须在收费前向你的客户提供该软件的 GNU GPL 许可协议，以便让他们知道，他们可以从别的渠道免费得到这份软件，以及你收费的理由。</li><li>可自由修改：如果你想添加或删除某个功能，没问题，如果你想在别的项目中使用部分代码，也没问题，唯一的要求是，使用了这段代码的项目也必须使用 GPL 协议。 </li></ol><p>还有一些要求 </p><ol><li>如果你使用了GPL协议的开源代码，将此开源代码用在了你的软件产品里，那么，你的整个软件产品必须开源，而且必须以GPL协议开源。</li><li>如果软件以GPL协议开源，那么源代码必须是面向社会开源的。而且你发布产品的时候源代码也必须一同附上。</li><li>如果软件以GPL协议开源，那么你可以对该软件收取一定的服务费用，但你永远不能对该软件的源代码收费。</li></ol><p>5.LGPL协议<br>        LGPL 是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并 发布和销售。 </p><p>​        但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因 此LGPL协议的开源 代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。 </p><p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p><h3 id="6-MPL"><a href="#6-MPL" class="headerlink" title="6.MPL"></a><strong>6.MPL</strong></h3><p>​        MPL既是得到自由软件基金会承认的自由软件许可证，也是得到开放源代码促进会承认的开源软件许可证。MPL允许在其授权下的源代码与其他授权的文件进行混合，包括私有许可证。但在MPL授权下的代码文件必须保持MPL授权，并且保持开源。这样的条款让MPL既不像MIT和BSD那样允许派生作品完全转化为私有，也不像GPL那样要求所有的派生作品，包括新的组件在内，全部必须保持GPL。通过允许在派生项目中存在私有模块，同时保证核心文件的开源，MPL同时激励了商业及开源社区来参与帮助开发核心软件。</p><p>​        使用MPL授权的软件并不受专利的限制，其可以自由使用，修改，并可自由的重新发布。带有专利代码的版本仍然可以使用，转让，甚至出售，但未经许可则不能修改代码。此外，MPL并不授予用户对于开发者商标的使用权。</p><p>​        为了满足MPL的条款限制，用户必须负担一些“责任”，主要是关于散发使用MPL授权的软件。用户必须确保重新散发的软件所有源代码均以MPL授权，即使是以可执行文件的方式提供或是与其他使用专有软件授权的源代码结合也一样。但若跟以GNU通用公共许可协议、GNU宽通用公共许可证、Affero通用公共许可证授权的源代码结合则是例外。此时开发者则可选用以上三种更加严格的条款来授权。</p><h2 id="二、开源协议选择"><a href="#二、开源协议选择" class="headerlink" title="二、开源协议选择"></a>二、开源协议选择</h2><p>按照使用条件的不同，开源软件许可证可以分为三类（严苛程度递减）。 </p><p>第一类使用该开源软件的代码再散布（redistribute）时，源码也必须以相同许可证公开。代表许可类型 GPL，AGPL。 </p><p>第二类使用该开源软件的代码并且对开源代码有所修改后再散布时，源码必须以相同许可证公开。如LGPL，CPL，CDDL，CPL，MPL等。 </p><p>第三类用该开源软件的代码（包括修改）再散布（redistribute）时，没有特殊限制，只需要明记许可。如ASL，BSD，MIT等。</p><p><img src="./%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 开源协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码整洁之道内容概要</title>
      <link href="/2022/04/02/dai-ma-zheng-ji-zhi-dao-nei-rong-gai-yao/"/>
      <url>/2022/04/02/dai-ma-zheng-ji-zhi-dao-nei-rong-gai-yao/</url>
      
        <content type="html"><![CDATA[<p>读了代码整洁之道，觉得这本书写的很好，所以就将里面自己觉得很经典的内容记录下来，作为自己以后写代码的标准和准则。同时也为那些曾经困惑过的人一点参考吧！</p><h2 id="一、在正式开始之前，我们先思考几个几个问题："><a href="#一、在正式开始之前，我们先思考几个几个问题：" class="headerlink" title="一、在正式开始之前，我们先思考几个几个问题："></a>一、在正式开始之前，我们先思考几个几个问题：</h2><h3 id="1-需求与代码哪个重要？"><a href="#1-需求与代码哪个重要？" class="headerlink" title="1.需求与代码哪个重要？"></a>1.需求与代码哪个重要？</h3><p>答：并不是所有的产品都能提出合理的需求，当你面对一个提出不合理需求的产品的时候，你需要坚持自己的原则，不能妥协。</p><h3 id="2-易读和易懂是一回事吗？"><a href="#2-易读和易懂是一回事吗？" class="headerlink" title="2.易读和易懂是一回事吗？"></a>2.易读和易懂是一回事吗？</h3><p>答：易读的代码和易懂的代码是有区别的，不是易读的代码就是易懂的代码。</p><h3 id="3-什么是测试驱动代码？"><a href="#3-什么是测试驱动代码？" class="headerlink" title="3.什么是测试驱动代码？"></a>3.什么是测试驱动代码？</h3><p>答：测试驱动代码，你写的代码要可以执行单元测试。如果你发现你的代码很难写单元测试，那么你就要思考你的代码是不是已经不整洁了，或者说已经乱成一团了。</p><h3 id="4-什么是简单的代码？"><a href="#4-什么是简单的代码？" class="headerlink" title="4.什么是简单的代码？"></a>4.什么是简单的代码？</h3><p>答：<br>1.能通过所有测试<br>2.没有重复代码<br>3.体现系统中全部设计理念<br>4.包含尽量少的实体，包括，类，函数，方法等</p><p>如果某段代码在程序设计中反复出现，就证明想法在代码中没有很好的体现出来。总之，不要重复代码，只做一件事，表达力，小规模抽象。</p><h2 id="二、第二章-有意义的命名"><a href="#二、第二章-有意义的命名" class="headerlink" title="二、第二章 有意义的命名"></a>二、第二章 有意义的命名</h2><h3 id="1-名副其实"><a href="#1-名副其实" class="headerlink" title="1.名副其实"></a>1.名副其实</h3><p>变量，函数或类的名称应该已经答复了所有的大问题。它应该告诉你，它为什么会存在，它做什么事情，应该怎么用。如果名称需要注释来补充，那么就不算名副其实。</p><h3 id="2-避免误导"><a href="#2-避免误导" class="headerlink" title="2.避免误导"></a>2.避免误导</h3><p>必须避免留下掩藏代码本意的错误线索。</p><h3 id="3-做有意义的区分"><a href="#3-做有意义的区分" class="headerlink" title="3.做有意义的区分"></a>3.做有意义的区分</h3><p>只要体现出有意义的区分，使用a和the这样的前缀就没有错。废话就是冗余。</p><h3 id="4-使用读得出来的名称"><a href="#4-使用读得出来的名称" class="headerlink" title="4.使用读得出来的名称"></a>4.使用读得出来的名称</h3><p>不要用傻乎乎的自造词，而不是恰当的英语词。</p><h3 id="5-使用可搜索的名称"><a href="#5-使用可搜索的名称" class="headerlink" title="5.使用可搜索的名称"></a>5.使用可搜索的名称</h3><p>使用便于搜索的名字。</p><h3 id="6-避免使用编码"><a href="#6-避免使用编码" class="headerlink" title="6.避免使用编码"></a>6.避免使用编码</h3><p>把类型或者作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的代码之外，还要再搞懂另一种编码”语言”。</p><h3 id="7-避免思维映射"><a href="#7-避免思维映射" class="headerlink" title="7.避免思维映射"></a>7.避免思维映射</h3><p>不应当让读者在脑中把你的名称翻译为他们熟知的名称，尤其是在经常出现在选择是使用问题领域术语还是解决方案领域术语的时候。</p><h3 id="8-类名或对象名最好使用名词或者名词短语"><a href="#8-类名或对象名最好使用名词或者名词短语" class="headerlink" title="8.类名或对象名最好使用名词或者名词短语"></a>8.类名或对象名最好使用名词或者名词短语</h3><h3 id="9-方法名最好使用动词或者动词短语"><a href="#9-方法名最好使用动词或者动词短语" class="headerlink" title="9.方法名最好使用动词或者动词短语"></a>9.方法名最好使用动词或者动词短语</h3><h3 id="10-别扮可爱"><a href="#10-别扮可爱" class="headerlink" title="10.别扮可爱"></a>10.别扮可爱</h3><p>命名一定要通俗易懂。</p><h3 id="11-每一个概念对应一个词"><a href="#11-每一个概念对应一个词" class="headerlink" title="11.每一个概念对应一个词"></a>11.每一个概念对应一个词</h3><p>给每个抽象概念选择一个词，并一以贯之</p><h3 id="12-别用双关语词"><a href="#12-别用双关语词" class="headerlink" title="12.别用双关语词"></a>12.别用双关语词</h3><p>避免将同一个词用于不同目的，遵循一词一义的原则</p><h3 id="13-使用解决方案领域名"><a href="#13-使用解决方案领域名" class="headerlink" title="13.使用解决方案领域名"></a>13.使用解决方案领域名</h3><h3 id="14-使用源自所涉领域名"><a href="#14-使用源自所涉领域名" class="headerlink" title="14.使用源自所涉领域名"></a>14.使用源自所涉领域名</h3><h3 id="15-添加有意义的语境"><a href="#15-添加有意义的语境" class="headerlink" title="15.添加有意义的语境"></a>15.添加有意义的语境</h3><p>在一个bean中定义变量名的时候，变量名一定是基于实际使用场景。</p><h3 id="16-不要添加没用的语境"><a href="#16-不要添加没用的语境" class="headerlink" title="16.不要添加没用的语境"></a>16.不要添加没用的语境</h3><h2 id="三、第三章-函数"><a href="#三、第三章-函数" class="headerlink" title="三、第三章 函数"></a>三、第三章 函数</h2><h3 id="1-短小"><a href="#1-短小" class="headerlink" title="1.短小"></a>1.短小</h3><p>函数第一规则是要短小。第二条规则是还要更短小。</p><h3 id="2-只做一件事"><a href="#2-只做一件事" class="headerlink" title="2.只做一件事"></a>2.只做一件事</h3><ul><li>函数应该做一件事。做好这件事。只做一件事。如果可以从你的函数中还能拆分出一个函数，该函数不仅只是单纯地重新诠释其实现，那么你设计的函数就不是一个好的函数。</li><li>函数中的区段，如果函数被切分了多个区段，这就证明该函数做的事情太多了。</li></ul><h3 id="3-每个函数一个抽象层级"><a href="#3-每个函数一个抽象层级" class="headerlink" title="3.每个函数一个抽象层级"></a>3.每个函数一个抽象层级</h3><h3 id="4-switch语句"><a href="#4-switch语句" class="headerlink" title="4.switch语句"></a>4.switch语句</h3><p>确保每个switch都埋藏在较低的抽象层级，而且永远不重复。</p><h3 id="5-使用描述性的名称"><a href="#5-使用描述性的名称" class="headerlink" title="5.使用描述性的名称"></a>5.使用描述性的名称</h3><p>命名方式要保持一致。使用与模块名一脉相承的短语、名词和动词给函数命名。例如：includeSetupPages。</p><h3 id="6-函数参数"><a href="#6-函数参数" class="headerlink" title="6.函数参数"></a>6.函数参数</h3><ul><li>最理想的函数参数的数量是零个，其次是一，再次是二，应尽量避免三。有足够的理由才能用上三个以上的参数。</li><li>如果函数看来需要两个，三个或者三个以上参数，就说明其中一些参数应该封装为类了。</li><li>函数和函数的参数命名一般是动名词比较好。</li></ul><h3 id="7-无副作用"><a href="#7-无副作用" class="headerlink" title="7.无副作用"></a>7.无副作用</h3><h3 id="8-分割指令与查询"><a href="#8-分割指令与查询" class="headerlink" title="8.分割指令与查询"></a>8.分割指令与查询</h3><p>函数要么做什么事，要么回答什么事，但二者不可兼得</p><h3 id="9-使用异常替代返回错误码"><a href="#9-使用异常替代返回错误码" class="headerlink" title="9.使用异常替代返回错误码"></a>9.使用异常替代返回错误码</h3><ul><li>返回错误码的时候，就是在要求调用者立刻处理错误。</li><li>如果使用异常替代返回错误码，错误处理代码就能从住路径代码中分离出来，得到简化。</li><li>抽离try/catch代码块</li></ul><h3 id="10-别重复自己"><a href="#10-别重复自己" class="headerlink" title="10.别重复自己"></a>10.别重复自己</h3><h3 id="11-结构化编程"><a href="#11-结构化编程" class="headerlink" title="11.结构化编程"></a>11.结构化编程</h3><h2 id="四、第四章-注释"><a href="#四、第四章-注释" class="headerlink" title="四、第四章 注释"></a>四、第四章 注释</h2><h3 id="1-如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。"><a href="#1-如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。" class="headerlink" title="1.如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。"></a>1.如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。</h3><h3 id="2-真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？"><a href="#2-真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？" class="headerlink" title="2.真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？"></a>2.真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？</h3><ul><li>法律信息</li><li>提供信息的注释</li><li>提供意图的解释</li><li>阐释</li><li>警告</li><li>TODO注释</li><li>TODO是一种程序要认为应该要做的，但是由于某种原因没有做的</li><li>放大,放大某些看似不合理的地方</li></ul><h2 id="五、第六章-对象和数据结构"><a href="#五、第六章-对象和数据结构" class="headerlink" title="五、第六章 对象和数据结构"></a>五、第六章 对象和数据结构</h2><h3 id="1-得墨忒定律"><a href="#1-得墨忒定律" class="headerlink" title="1.得墨忒定律"></a>1.得墨忒定律</h3><p>模块不应该了解他所操作对象的内部情形。对象隐藏数据曝露操作，这就意味着对象不应该通过存取器曝露其内部结构。</p><h2 id="六、第七章-错误处理"><a href="#六、第七章-错误处理" class="headerlink" title="六、第七章 错误处理"></a>六、第七章 错误处理</h2><h3 id="1-将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。"><a href="#1-将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。" class="headerlink" title="1.将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。"></a>1.将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。</h3><h3 id="2-异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。"><a href="#2-异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。" class="headerlink" title="2.异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。"></a>2.异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。</h3><h2 id="七、第八章-边界"><a href="#七、第八章-边界" class="headerlink" title="七、第八章 边界"></a>七、第八章 边界</h2><h3 id="1-整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。"><a href="#1-整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。" class="headerlink" title="1.整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。"></a>1.整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。</h3><h2 id="八、第九章-单元测试"><a href="#八、第九章-单元测试" class="headerlink" title="八、第九章 单元测试"></a>八、第九章 单元测试</h2><h3 id="1-TDD三定律"><a href="#1-TDD三定律" class="headerlink" title="1.TDD三定律"></a>1.TDD三定律</h3><ul><li>在编写不能通过的单元测试前，不可编写生产代码。</li><li>只可编写刚好无法通过的单元测试，不能编译也算不通过</li><li>只可编写刚好足以通过当前失败测试的生产代码</li></ul><h3 id="2-整洁测试三要素"><a href="#2-整洁测试三要素" class="headerlink" title="2.整洁测试三要素"></a>2.整洁测试三要素</h3><ul><li>可读性</li><li>可读性</li><li>可读性</li></ul><h3 id="3-整洁测试的五条原则："><a href="#3-整洁测试的五条原则：" class="headerlink" title="3.整洁测试的五条原则："></a>3.整洁测试的五条原则：</h3><ul><li>快速，测试应该够快</li><li>独立，测试应该相互独立</li><li>可重复，测试应当可在任何环境中重复通过。</li><li>自足验证，测试应该有布尔值输出，无论测试是成功还是失败，不应该人工通过log来确认测试是否成功或者失败。</li><li>及时，测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，你会发现生产代码难以测试。你可能会认为某些生产代码本身难以测试。你可能不会去设计可测试的代码。</li></ul><h2 id="九、第十章-类"><a href="#九、第十章-类" class="headerlink" title="九、第十章 类"></a>九、第十章 类</h2><h3 id="1-单一权责原则，类或者模块应有且只有一条加以修改的理由。"><a href="#1-单一权责原则，类或者模块应有且只有一条加以修改的理由。" class="headerlink" title="1.单一权责原则，类或者模块应有且只有一条加以修改的理由。"></a>1.单一权责原则，类或者模块应有且只有一条加以修改的理由。</h3><h3 id="2-内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。"><a href="#2-内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。" class="headerlink" title="2.内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。"></a>2.内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。</h3><h2 id="十、第十一章-系统"><a href="#十、第十一章-系统" class="headerlink" title="十、第十一章 系统"></a>十、第十一章 系统</h2><h3 id="1-将系统的构造与使用分开"><a href="#1-将系统的构造与使用分开" class="headerlink" title="1.将系统的构造与使用分开"></a>1.将系统的构造与使用分开</h3><p>软件系统应将起始过程和启始过程之后的运行时逻辑分离开，在起始过程中构建应用对象，也会存在相互缠结的依赖关系。（延迟初始化可以加快程序运行速度）</p><h4 id="1-1分解main"><a href="#1-1分解main" class="headerlink" title="1.1分解main"></a>1.1分解main</h4><p>将程序的构造放到main，并使其与运行时逻辑分开，main只管构造并将构造后的数据对象发送给各个应用，或者被各个应用使用。但是，不参与运行时的任何逻辑控制。</p><h4 id="1-2工厂模式"><a href="#1-2工厂模式" class="headerlink" title="1.2工厂模式"></a>1.2工厂模式</h4><p>使用该模式可以将系统构造和系统运行时逻辑分开。</p><h4 id="1-3依赖注入（需要强化理解）"><a href="#1-3依赖注入（需要强化理解）" class="headerlink" title="1.3依赖注入（需要强化理解）"></a>1.3依赖注入（需要强化理解）</h4><h4 id="1-4扩容"><a href="#1-4扩容" class="headerlink" title="1.4扩容"></a>1.4扩容</h4><p>“一开始就做对系统”纯属神话。反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统，实现新用户的故事。这就是迭代和增量敏捷的精髓所在。测试驱动开发，重构以及他们打造出的整洁的代码。</p><h4 id="1-5测试驱动系统架构"><a href="#1-5测试驱动系统架构" class="headerlink" title="1.5测试驱动系统架构"></a>1.5测试驱动系统架构</h4><p>最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯编程语言对象实现。不同的领域之间用最不具有侵害性的方面或类方面工具结合起来。这种架构就能测试驱动，就像代码一样。(需要关注面向切片编程(POJO))</p><h4 id="1-6优化决策"><a href="#1-6优化决策" class="headerlink" title="1.6优化决策"></a>1.6优化决策</h4><p>模块化和关注面切分成就了分散化管理和决策。在巨大的系统中，不管是一座城市或是一个软件项目，无人能做所有的决策。最好是授权给最有资格的人。拥有模块化关注面的POJO系统提供的敏捷能力，允许我们基于最新的知识做出优化的，时机刚好的决策。决策的复杂性降低了。</p><h2 id="十一、第十二章-迭进"><a href="#十一、第十二章-迭进" class="headerlink" title="十一、第十二章 迭进"></a>十一、第十二章 迭进</h2><h3 id="1-通过迭进设计达到代码整洁的目的："><a href="#1-通过迭进设计达到代码整洁的目的：" class="headerlink" title="1. 通过迭进设计达到代码整洁的目的："></a>1. 通过迭进设计达到代码整洁的目的：</h3><p>通过这几个原则可以让你的设计变简单（DIP，SRP）</p><ul><li>运行所有测试</li><li>不可重复，</li><li>表达了程序员的意图</li><li>尽可能减少类和方法的数量</li><li>以上规则按其重要程度排序</li></ul><h3 id="2-简单设计规则1-运行所有测试"><a href="#2-简单设计规则1-运行所有测试" class="headerlink" title="2. 简单设计规则1:运行所有测试"></a>2. 简单设计规则1:运行所有测试</h3><p>编写的测试越多就越能持续走向编写较易测试的代码，紧耦合的代码很难编写测试。遵循有关编写测试并持续运行测试的简单，明确的规则，系统就会更贴近OO低耦合度，高内聚度的目标。编写测试引致更好的设计。</p><h3 id="3-简单设计规则2-4：重构"><a href="#3-简单设计规则2-4：重构" class="headerlink" title="3. 简单设计规则2-4：重构"></a>3. 简单设计规则2-4：重构</h3><p>在重构过程中，可以应用有关优秀软件设计的一切知识。提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称，如此等等。这也是简单设计原则后三条规则的地方:消除重复，保证表达力，尽可能减少类和方法的数量。</p><h3 id="4-不可重复"><a href="#4-不可重复" class="headerlink" title="4. 不可重复"></a>4. 不可重复</h3><h3 id="5-表达力"><a href="#5-表达力" class="headerlink" title="5. 表达力"></a>5. 表达力</h3><h3 id="6-尽可能少的类和方法"><a href="#6-尽可能少的类和方法" class="headerlink" title="6. 尽可能少的类和方法"></a>6. 尽可能少的类和方法</h3><h2 id="十二、第十三章-并发编程"><a href="#十二、第十三章-并发编程" class="headerlink" title="十二、第十三章 并发编程"></a>十二、第十三章 并发编程</h2><h3 id="1-为什么要并发"><a href="#1-为什么要并发" class="headerlink" title="1. 为什么要并发"></a>1. 为什么要并发</h3><p>并发是一种解耦策略。它帮我们把做什么和何时做分解开。</p><h3 id="2-并发的防御原则"><a href="#2-并发的防御原则" class="headerlink" title="2. 并发的防御原则"></a>2. 并发的防御原则</h3><h3 id="13-1-单一权责原则（SRP）"><a href="#13-1-单一权责原则（SRP）" class="headerlink" title="13.1 单一权责原则（SRP）"></a>13.1 单一权责原则（SRP）</h3><p>并发代码应该从其他代码中分离出来，因为，并发代码相比于其他的代码是很复杂的存在。但是，并发实现细节常常直接嵌入到其他生产代码中。那么下面几个问题需要考虑，</p><ul><li>并发相关代码由自己的开发，修改和调优生命周期</li><li>开发相关代码由自己要对付的挑战，和非并发相关代码不同，而且往往更为困难</li><li>即便没有周边应用程序增加负担，写得不好的并发代码可能的出错方式数量已经足具挑战性。</li></ul><blockquote><p>建议：分离并发相关代码与其他代码。</p></blockquote><h3 id="13-2-限制数据作用域"><a href="#13-2-限制数据作用域" class="headerlink" title="13.2 限制数据作用域"></a>13.2 限制数据作用域</h3><p>两个线程修改共享对象的同一字段时，可能相互干扰，导致未预期的行为。解决方案之一是采用<code>synchronized</code>关键字在代码中保护一块使用共享对象的临界区。限制临界区的数量很重要。更新共享数据的地方越多，就越可能出错。</p><blockquote><p>建议：谨记数据封装，严格限制对可能被共享的数据的访问。</p></blockquote><h3 id="13-3-使用数据副本"><a href="#13-3-使用数据副本" class="headerlink" title="13.3 使用数据副本"></a>13.3 使用数据副本</h3><p>避免共享数据的好方法之一就是一开始就避免共享数据。在某些情况下，有可能复制对象并以只读方式对待。在另外一种情况下，有可能复制对象，从多个线程收集所有副本的结果，并在单个线程中合并这些结果。</p><h3 id="13-4-线程尽可能地独立"><a href="#13-4-线程尽可能地独立" class="headerlink" title="13.4　线程尽可能地独立"></a>13.4　线程尽可能地独立</h3><p>让每个线程在自己的世界中存在，不与其他线程共享数据。每个线程处理一个客户端请求，从不共享的源头接纳所有请求数据，存储为本地变量。</p><p>建议：尝试将数据分解到可被独立线程操作的独立子集。</p><h3 id="13-5-了解执行模型"><a href="#13-5-了解执行模型" class="headerlink" title="13.5 了解执行模型"></a>13.5 了解执行模型</h3><h4 id="13-5-1-生产者－－－消费者模型"><a href="#13-5-1-生产者－－－消费者模型" class="headerlink" title="13.5.1 生产者－－－消费者模型"></a>13.5.1 生产者－－－消费者模型</h4><p>一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。</p><h4 id="13-5-2-读者－－－作者模型"><a href="#13-5-2-读者－－－作者模型" class="headerlink" title="13.5.2 读者－－－作者模型"></a>13.5.2 读者－－－作者模型</h4><p>当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的积累。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的消息，这是一种辛苦的平衡工作。作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题。</p><p>挑战之处在于平衡读者线程和作者线程的需求，实现正确的操作，提供合理的吞吐量，避免线程饥饿。</p><h4 id="13-5-3哲学家问题（故事内容不在这里描述）"><a href="#13-5-3哲学家问题（故事内容不在这里描述）" class="headerlink" title="13.5.3哲学家问题（故事内容不在这里描述）"></a>13.5.3哲学家问题（故事内容不在这里描述）</h4><p>从哲学家问题可以反映出编写并发经常遇到的问题，死锁，活锁，吞吐量和效率降低等问题。那么学习这些基础问题的解决算法可以帮助你解决大多数的并发问题，因为大多的并发问题都是上述问题的变种。</p><h3 id="13-6-警惕同步方法之间的依赖"><a href="#13-6-警惕同步方法之间的依赖" class="headerlink" title="13.6 警惕同步方法之间的依赖"></a>13.6 警惕同步方法之间的依赖</h3><p>同步方法之间的依赖会导致并发代码中的狡猾缺陷。Java语言有synchronized概念，可以用来保护单个方法。然而，如果在同一共享类中由多个同步方法，系统就可能写得不太正确了。</p><blockquote><p>建议：避免使用一个共享对象的多个方法。如果有时必须使用一个共享对象的多个方法。这种情况发生时，有３中写对代码的手段：</p></blockquote><ul><li>基于客户端的锁定－－客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码。</li><li>基于服务端的锁定－－在服务端内创建锁定服务端的方法，调用所有方法，然后解锁。让客户端代码调用新的方法。</li><li>适配服务端－－创建执行锁定的中间层。这是一种基于服务端的锁定例子，但不修改原始服务端代码。</li></ul><h3 id="13-7保持同步区域微小"><a href="#13-7保持同步区域微小" class="headerlink" title="13.7保持同步区域微小"></a>13.7保持同步区域微小</h3><p>应该尽可能少地设计临界区，如果有请尽可能减小同步区域。</p><h3 id="13-8-编写线程需要注意的几点："><a href="#13-8-编写线程需要注意的几点：" class="headerlink" title="13.8　编写线程需要注意的几点："></a>13.8　编写线程需要注意的几点：</h3><h4 id="1-将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。"><a href="#1-将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。" class="headerlink" title="(1). 将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。"></a>(1). 将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。</h4><h4 id="2-先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。"><a href="#2-先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。" class="headerlink" title="(2). 先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。"></a>(2). 先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。</h4><h4 id="3-编写可插拔的线程代码。编写在数个环境下运行的线程代码"><a href="#3-编写可插拔的线程代码。编写在数个环境下运行的线程代码" class="headerlink" title="(3). 编写可插拔的线程代码。编写在数个环境下运行的线程代码"></a>(3). 编写可插拔的线程代码。编写在数个环境下运行的线程代码</h4><ul><li>1.单线程与多线程在执行时不同的情况</li><li>2.线程代码与实物或测试替身互动</li><li>3.用运行速度,缓慢和有变动的测试替身执行</li><li>4.将测试配置为能运行一定数量的迭代</li></ul><blockquote><p>建议：编写可插拔的线程代码，这样就能在不同的配置环境下运行。</p></blockquote><h4 id="4-编写可调整的线程代码"><a href="#4-编写可调整的线程代码" class="headerlink" title="(4). 编写可调整的线程代码"></a>(4). 编写可调整的线程代码</h4><p>在系统运行时允许线程发生变动。允许线程依据吞吐量和使用率自我调整。</p><h4 id="5-运行多余处理器数量的线程"><a href="#5-运行多余处理器数量的线程" class="headerlink" title="(5). 运行多余处理器数量的线程"></a>(5). 运行多余处理器数量的线程</h4><p>任务交换越频繁，越有可能找到错过临界区或导致死锁的代码。</p><h4 id="6-在不同平台上运行"><a href="#6-在不同平台上运行" class="headerlink" title="(6). 在不同平台上运行"></a>(6). 在不同平台上运行</h4><h4 id="7-调整代码并强迫错误发生"><a href="#7-调整代码并强迫错误发生" class="headerlink" title="(7). 调整代码并强迫错误发生"></a>(7). 调整代码并强迫错误发生</h4><h2 id="十三、第14章-逐步改进"><a href="#十三、第14章-逐步改进" class="headerlink" title="十三、第14章 逐步改进"></a>十三、第14章 逐步改进</h2><p>代码并不是一次就能写的很干净的，需要我们不断的迭代和优化。</p><h2 id="十四、第17章-味道与启发"><a href="#十四、第17章-味道与启发" class="headerlink" title="十四、第17章 味道与启发"></a>十四、第17章 味道与启发</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h3><h4 id="1-不恰当的注释信息"><a href="#1-不恰当的注释信息" class="headerlink" title="(1). 不恰当的注释信息"></a>(1). 不恰当的注释信息</h4><p>让注释传达本该更好地在源代码控制系统，问题追踪系统或任何其他记录系统中保存的信息，是不恰当的。例如，修改历史记录只会用大量过时而无趣的文本搞乱源代码文件。注释只应该描述有关代码和设计的技术性信息。</p><h4 id="2-废弃的注释"><a href="#2-废弃的注释" class="headerlink" title="(2). 废弃的注释"></a>(2). 废弃的注释</h4><p>过时，无关或不正确的注释就是废弃的注释。</p><h4 id="3-冗余注释"><a href="#3-冗余注释" class="headerlink" title="(3). 冗余注释"></a>(3). 冗余注释</h4><p>如果注释描述的是某种充分自我描述了的东西，那么注释就是多余的。注释应该谈及代码自身没有提到的东西。</p><h4 id="4-注释要写就要写最好的注释，别画蛇添足"><a href="#4-注释要写就要写最好的注释，别画蛇添足" class="headerlink" title="(4). 注释要写就要写最好的注释，别画蛇添足"></a>(4). 注释要写就要写最好的注释，别画蛇添足</h4><h4 id="5-注释掉的代码，看到注释掉的代码就删。"><a href="#5-注释掉的代码，看到注释掉的代码就删。" class="headerlink" title="(5). 注释掉的代码，看到注释掉的代码就删。"></a>(5). 注释掉的代码，看到注释掉的代码就删。</h4><h3 id="2-环境"><a href="#2-环境" class="headerlink" title="2. 环境"></a>2. 环境</h3><h4 id="1-需要多步才能实现的构建"><a href="#1-需要多步才能实现的构建" class="headerlink" title="(1). 需要多步才能实现的构建"></a>(1). 需要多步才能实现的构建</h4><p>构建系统应该是单步的小操作。不应该从源代码控制系统中一小点一小点签出代码。不应该需要一系列神秘指令或环境依赖脚本来构建单个元素。不应该四出寻找额外的小jar,xml文件和其他系统所需的杂物。你应该能够用单个命令签出系统，并单个指令构建它。</p><h4 id="2-需要多步才能做到测试"><a href="#2-需要多步才能做到测试" class="headerlink" title="(2). 需要多步才能做到测试"></a>(2). 需要多步才能做到测试</h4><p>你应该能够用单个指令就可以运行全部单元测试。能够运行全部测试是如此基础和重要，应该快速，轻易和直接了当地做到。</p><h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h3><ul><li>函数的参数应该少。</li><li>输出参数违反直觉。如果非要修改，那就修改函数所在对象好了。</li><li>标示参数，布尔值参数宣告函数做了不止一件事，应该消灭掉，即函数只做一件事。</li><li>永不被调用的方法应该丢弃。</li></ul><h3 id="4-一般性问题"><a href="#4-一般性问题" class="headerlink" title="4. 一般性问题"></a>4. 一般性问题</h3><p>(1). 如果代码需要有多种语言，那么应该尽力减少源文件中额外语言的数量和范围。</p><p>(2). 明显的行为未被实现，如果明显的行为未被实现，读者和用户就不能再依靠他们对函数名称的直觉。他们不再信任原作者，不得不阅读代码细节。</p><p>(3). 不正确的边界行为，追索每种边界条件，编写测试。</p><p>(4). 忽视安全</p><p>(5). 重复，尽可能找到并消除重复。</p><p>(6). 在错误的抽象层级上的代码，创建分离较高层级一般性概念与较低层级细节概念的抽象模型，这很重要。</p><p>(7). 基类不可多度依赖于派生类，基类应该对派生类一无所知。</p><p>(8). 信息过多，设计良好的模块有着非常小的接口，让你事半功倍。设计良好的接口并不提供许多需要依靠的函数，所以耦合度比较低。</p><p>优秀的软件开发人员学会限制类或模块中暴露的接口数量。类中的方法越少越好。函数知道的变量越少越好。类拥有的实体变量越少越好。隐藏你的数据。隐藏你的工具函数。隐藏你的常量和你的临时变量。不要创建拥有大量方法或大量实体变量的类。不要为子类创建大量受保护变量和函数。尽力保持接口紧凑。通过限制信息来控制耦合度。</p><p>(9). 死代码一定要删除。</p><p>(10). 垂直分隔，变量和函数应该在靠近被使用的地方定义。私有函数应该刚好在其首次被使用的位置下面定义。</p><p>(11). 前后不一致，从一而终即一旦选中，就小心持续遵循。如果在特定函数中用了response的变量来持有HttpServletResponse对象，则在其他用到HttpServletResponse对象的函数中也用同样的变量名。这样会让你的代码更易阅读。</p><p>(12). 混淆视听，没用的变量或者函数直接删掉，以免造成不必要的干扰。</p><p>(13). 人为耦合，不互相依赖的东西不该耦合。一般来说，人为耦合是指两个没有直接目的之间的模块的耦合。其根源是将变量，常量或函数不恰当地放在临时方便的位置。</p><p>(14). 特性依恋，类的方法只应对其所属类中的变量和函数感兴趣，不该垂青其他类中的变量和函数。当方法通过某个其他对象的访问器和修改器来操作该对象内部数据，则它就依恋于该对象所属类的范围。</p><p>(15). 选择算子参数，尽量不要把boolean作为函数参数</p><p>(16). 晦涩意图，代码要尽可能具有表达力。</p><p>(17). 位置错误的权责，我们可以采用最小惊异原则来帮助我们即代码应该放在读者自然而然期待它所在的地方。</p><p>(18). 不恰当的静态方法，对于没有机会打算让它有多态行为的函数可以作为动态函数，否则可选用静态函数。</p><p>(19). 使用解释性变量，命名要有意义。</p><p>(20). 函数名称应该表达其行为</p><p>(21). 理解算法</p><p>(22). 把逻辑依赖改为物理依赖：</p><ul><li>1.逻辑依赖：原始数据和业务逻辑之间的依赖关系。例如：定义的常量和业务逻辑存在着依赖关系或者说被捆绑在了一起，即当业务逻辑发生变化或者存在其他可能性的时候且定义的常量无法满足导致常量需要修改。</li><li>2.物理依赖：函数方法和业务逻辑之间的依赖关系。例如：为了解决逻辑依赖的问题，我们可以通过构造一个方法将数据和业务隔离。</li></ul><p>(23). 用多态替代<code>if/else</code> 或 <code>switch/case</code></p><p>(24). 遵循标准约定</p><p>(25). 用命名常量替代魔术数，魔术数不仅仅指的是数字，也泛指任何不能自我描述的符号。</p><p>(26). 准确，在可以用List的时候，非要把变量声明为ArrayList就过分拘束了。在代码中做决定时，确认自己足够准确。明确自己为何要这么做，如果遇到异常情况如何处理。别懒得理会决定的准确性。代码中的含糊和不准确性要么是意见不同的结果，要么源于懒惰。无论原因是什么，都要消除。</p><p>(27). 结构甚于约定，坚守结构甚于约定的设计决策。</p><p>(28). 封装条件，如果没有if或while语句的上下文，布尔逻辑就难以理解。应该把解释了条件意图的函数抽离出来。</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">shouldBeDeleted</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要好于</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">.</span><span class="token function">hasExpired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timer<span class="token punctuation">.</span><span class="token function">isRecurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(29). 避免否定性条件，尽可能将条件表示为肯定形式。</p><p>(30). 函数只该做一件事</p><p>(31). 掩蔽时序耦合，排列函数参数，好让它们被调用的次序显而易见。</p><p>(32). 别随意，构建代码需要理由，而且理由应于代码结构相契合。</p><p>(33). 封装边界条件，把处理边界条件的代码集中到一处，不要散落于代码中。</p><p>(34). 函数应该只在一个抽象层级上，函数中的语句应该在同意抽象级上，该层级应该是函数名所示操作的下一层。</p><p>(35). 在较高层级放置可配置数据，如果你有个已知并在较高抽象层级的默认常量或配置值，不要将它埋藏到较低层级的函数中。把它作为较高层级函数调用较低层级函数时的一个参数。位于较高层级的配置性常量易于修改。它们向下贯穿应用程序。应用程序的较低层级并不拥有这些常量的值。</p><p>(36). 避免传递浏览，编写害羞代码。</p><p>(37). 不要继承常量</p><h3 id="17-5-测试"><a href="#17-5-测试" class="headerlink" title="17.5 测试"></a>17.5 测试</h3><ol><li>使用覆盖率工具，覆盖率工具能汇报你测试策略中的缺口。使用测试覆盖率工具能更容易地找到不足的模块，类和函数。</li><li>别略过小测试</li><li>被忽略的测试就是对不确定事物的疑问。</li><li>测试边界条件</li><li>全面测试相近的缺陷，缺陷趋向于扎堆。</li><li>测试失败的模式有启发性。</li><li>测试覆盖率的模式有启发性，查看被或未被以通过的测试执行的代码，往往能发现失败的测试为何失败的线索。</li><li>测试应该快速。</li></ol><p>来自：<a href="http://www.uml.org.cn/codeNorms/201701162.asp">代码整洁之道内容概要</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整洁代码 </tag>
            
            <tag> 重构 </tag>
            
            <tag> 测试 </tag>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序内存概念</title>
      <link href="/2022/04/01/cheng-xu-nei-cun-gai-nian/"/>
      <url>/2022/04/01/cheng-xu-nei-cun-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="程序内存概念"><a href="#程序内存概念" class="headerlink" title="程序内存概念"></a>程序内存概念</h1><p><strong>一 预备知识</strong></p><p>​        在区分一个程序的<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E6%A0%88&amp;spm=1001.2101.3001.7020">堆栈</a>、bss、text段、RO、RW、ZI等概念时，首先区分一下程序进程和程序文件，然后了解一下哈弗结构和冯诺依曼结构。</p><p>​        程序进程就是程序运行时的程序，程序文件是编译后生成的可执行程序，比如.bin文件等，这两个概念很好区分，特别强调一下，分开表达主要是怕读者在阅读过程中混淆了。</p><p>​        哈佛结构和冯诺依曼结构的主要区别就是处理器能不能实现取指令和取数据的并发进行。嵌入式芯片中主要是哈佛结构，PC机上是冯诺依曼结构。</p><p><strong>经典的哈佛结构</strong><br>        程序存储器和数据存储器是各自独立的存储器。处理器应该有两套总线，一套是程序存储器的数据和地址总线，一套是数据存储器的数据和地址总线。取指令和取数据能并发进行。51的程序进程的逻辑代码段放在ROM中，而变量部分则放在RAM中，取ROM中的指令和RAM中的变量是两套总线。</p><p><strong>改进型哈佛结构</strong><br>        程序存储器和数据存储器是各自独立的存储器。处理器只有一套总线，分时访问程序存储器和数据存储器，但是在处理器中有icache和dcache将程序和数据分开，所以处理器仍然可以并步执行取指令和取数据。从ARM9开始以后所有的ARM处理器内核都是改进型的哈佛结构。ARM的逻辑代码和变量都是存放在RAM中的，但是，它在内存中划分了两部分的空间，其中一部分放逻辑代码，另一部分存放变量，之间不会相互干扰。</p><p><strong>冯诺依曼结构</strong>：<br>        没有程序存储空间和数据存储空间之分。处理器只有一套总线，取指令和取数据是不能同时进行的。程序进程全部在RAM中，他们之间一般是按照代码的执行顺序依次存储。由于全部在RAM中，运行速度快，所需的RAM多。</p><p><strong>二 程序文件中的分区</strong></p><p>备注：只针对嵌入式，pc程序文件没有探究过。小标题“程序文件中的分区”其实不是很恰当，不知道该如何形容，此部分概念通常出现在一个程序编译完成后的大小统计，请自行理解。</p><p>​    相关概念：Code，RO_data，RW_data，ZI_data，RO，RW，常出现在嵌入式程序编译完成后的统计，例如MDK，IAR，ARM GCC。</p><p>有些技术文章中会直接使用RO，请注意区分RO和RO-data的区别。 </p><p><strong>Code</strong>：即代码域，它指的是编译器生成的机器指令。<br><strong>RO_data</strong>：ReadOnly data，即只读数据域，它指程序中用到的只读数据，全局变量，例如C语言中const关键字定义的全局变量就是典型的RO-data。<br><strong>RW_data</strong>：ReadWrite data，即可读写数据域，它指初始化为“非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。例如全局变量或者静态变量，且定义时赋予“非0值”给该变量进行初始化。<br><strong>ZI_data</strong>：ZeroInitialie data，即0初始化数据，它指初始化为“0值”的可读写数据域，它与RW_data的区别是程序刚运行时这些数据初始值全都为0，而后续运行过程与RW-data的性质一样，它们也常驻在RAM区，因而应用程序可以更改其内容。包括未初始化的全局变量，和初始化为0的全局变量。<br><strong>RO</strong>：只读区域，包括RO_data和code。 </p><p>当程序存储在ROM中时，所占用的大小为Code + RO_data + RW_data 。<br>当程序执行时， RW_data和 ZI_data在RAM中，RO_data和code视cpu架构（51、arm、x86）不同处于ROM或者RAM中。其中ZI_data对应了BSS段，RW_data对应数据段，code对应代码段， RO_data对应数据段。</p><p><strong>三 程序进程中的分区</strong></p><p> <strong>三 程序进程中的分区</strong>：</p><p>相关概念：堆(heap)，栈(stack)，BSS段，数据段(data)，代码段( code /text)，全局静态区，文字常量区，程序代码区。<br> <strong>BSS段</strong>：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。<br> <strong>数据段</strong>：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。<br> <strong>代码段</strong>：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。<br> <strong>堆（heap）</strong>：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。<br> **栈(stack)**：栈又称堆栈，用户存放程序临时创建的局部变量。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场。</p><p> 全局静态区，文字常量区，程序代码区是从内存地址分配的角度来描述的。<br><strong>全局区（静态区）（static）</strong>—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。</p><p><strong>文字常量区</strong>—常量字符串就是放在这里的。<br><strong>程序代码区</strong>—存放函数体的二进制代码。</p><p><img src="./%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5/code_ram.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> RAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my first blog</title>
      <link href="/2021/10/27/my-first-blog/"/>
      <url>/2021/10/27/my-first-blog/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>quick start</title>
      <link href="/2021/10/24/hello-world/"/>
      <url>/2021/10/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
