<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>conan</title>
      <link href="/2023/01/01/conan/"/>
      <url>/2023/01/01/conan/</url>
      
        <content type="html"><![CDATA[<h1 id="conan"><a href="#conan" class="headerlink" title="conan"></a>conan</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>​    Conan 是 C 和 C++ 语言的依赖项和包管理器。它是<a href="https://github.com/conan-io/conan">免费和开源的</a>，适用于所有平台（Windows、Linux、OSX、FreeBSD、Solaris 等），可用于为所有目标开发，包括嵌入式、移动（iOS、Android）和裸机。它还集成了所有构建系统，如 CMake、Visual Studio (MSBuild)、Makefiles、SCons 等，包括专有系统。</p><p>​    它专为加速 C 和 C++ 项目的开发和持续集成而设计和优化。通过完整的二进制管理，它可以为任意数量的包的不同版本创建和重用任意数量的不同二进制文件（针对不同的配置，如体系结构、编译器版本等），在所有平台上使用完全相同的过程。由于它是去中心化的，因此很容易运行您自己的服务器来私下托管您自己的包和二进制文件，而无需共享它们。免费的<a href="https://conan.io/downloads.html">JFrog Artifactory Community Edition (CE)</a>是推荐的 Conan 服务器，用于在您的控制下私下托管您自己的包。</p><p>​    Conan 成熟稳定，坚定地致力于向前兼容（非破坏性政策），并拥有一个完整的团队全职致力于其改进和支持。<a href="https://conan.io/center">它得到了一个伟大社区的支持和使用，从ConanCenter</a>的开源贡献者和包创建者到成千上万使用它的团队和公司。</p><p>​    Conan 是免费和开源的，具有宽松的麻省理工学院许可证。<a href="https://github.com/conan-io/conan">在https://github.com/conan-io/conan</a>查看源代码和问题跟踪（用于问题和支持、报告错误以及建议功能请求和改进）</p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h2><p>​        Conan可以安装在许多操作系统中。它已在 Windows、Linux（不同的发行版）、OSX 中得到广泛使用和测试，并且还在 FreeBSD 和 Solaris SunOS 中得到积极使用。据报道，它还可以在其他几个操作系统上运行。Conan的安装方式有以下三种：</p><ol><li>安装 Conan的首选且<strong>强烈推荐的方法</strong>是使用命令从 PyPI（Python 包索引）中安装<code>pip</code>。</li><li>对于不同的系统还有其他可用的安装程序，它们可能带有捆绑的 python 解释器，因此您不必先安装 python。请注意，其中一些<strong>安装程序可能有一些限制</strong>，尤其是使用 pyinstaller 创建的安装程序（例如 Windows exe 和 Linux deb）。</li><li>从源代码运行柯南。</li></ol><p>使用pip安装conan</p><pre class="line-numbers language-none"><code class="language-none">$ pip install conan<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>确保您的<strong>pip</strong>安装与您的<strong>Python&gt;=3.6</strong>版本匹配。较低的 Python 版本将不起作用。</li><li>在<strong>Linux</strong>中，您可能需要<strong>sudo</strong>权限才能全局安装柯南。</li><li>我们强烈建议对与 Python 相关的所有内容使用<strong>virtualenvs</strong>（virtualenvwrapper 效果很好）。</li><li>在<strong>OSX</strong>中，尤其是可能具有<strong>System Integrity Protection</strong>的最新版本中，pip 可能会失败。尝试使用 virtualenvs，或使用其他用户安装。<code>$ pip install --user conan</code></li><li>一些 Linux 发行版，例如 Linux Mint，安装后需要重启（shell 重启，或者 logout/system 不够用），所以在路径中找到了 Conan。</li></ul><p>pip 的已知安装问题</p><p><strong>当使用pip install –user <username> 安装</username></strong>Conan 时，通常会为其创建一个新目录。但是，该目录不会自动附加到PATH并且<strong>conan</strong>命令不起作用。这通常可以通过重新启动终端会话或运行以下命令来解决：</p><pre class="line-numbers language-none"><code class="language-none">$ source ~/.profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C_C++环境搭建</title>
      <link href="/2022/12/24/c-c-huan-jing-da-jian/"/>
      <url>/2022/12/24/c-c-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="C-C-环境搭建"><a href="#C-C-环境搭建" class="headerlink" title="C_C++环境搭建"></a>C_C++环境搭建</h1><h2 id="1、Visual-Studio-Code"><a href="#1、Visual-Studio-Code" class="headerlink" title="1、Visual Studio Code"></a>1、Visual Studio Code</h2><p>1.1 下载安装</p><pre class="line-numbers language-none"><code class="language-none">https://marketplace.visualstudio.com/vscode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、Clion"><a href="#2、Clion" class="headerlink" title="2、Clion"></a>2、Clion</h2><h2 id="3、Visual-Studio-2019"><a href="#3、Visual-Studio-2019" class="headerlink" title="3、Visual Studio 2019"></a>3、Visual Studio 2019</h2><h2 id="4、Cmake-notepad"><a href="#4、Cmake-notepad" class="headerlink" title="4、Cmake + notepad"></a>4、Cmake + notepad</h2>]]></content>
      
      
      <categories>
          
          <category> template </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/24/template/"/>
      <url>/2022/12/24/template/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> template </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FontCache CPU占用过高</title>
      <link href="/2022/11/27/fontcache-cpu-zhan-yong-guo-gao/"/>
      <url>/2022/11/27/fontcache-cpu-zhan-yong-guo-gao/</url>
      
        <content type="html"><![CDATA[<p>FontCache CPU占用过高</p><p>1.delete FontCache3.0.0.0.dat</p><pre class="line-numbers language-none"><code class="language-none">1.delete C:\Windows\ServiceProfiles\LocalService\AppData\Local\FontCache3.0.0.0.dat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.stop windows presentation Foundation font cache service</p><p>1.打开服务窗口（运行services.msc）</p><p>2.look for windows presentation Foundation font cache 3.0.0.0</p><p>3.Right-click on the service,set the startup type to disable, and click stop.</p><p>4.click apply &gt; ok.</p>]]></content>
      
      
      <categories>
          
          <category> computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb调试</title>
      <link href="/2022/07/26/gdb-diao-shi/"/>
      <url>/2022/07/26/gdb-diao-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>GDB（GNU Debugger）是GCC的调试工具。其功能强大，现描述如下：</p><p>   GDB主要帮忙你完成下面四个方面的功能：</p><p>   1.启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</p><p>   2.可让被调试的程序在你所指定的设置的断点处停住。（断点可以是条件表达式）</p><p>   3.当程序被停住时，可以检查此时你的程序中所发生的事。</p><p>   4.动态的改变你程序的执行环境。</p><h3 id="2-常用指令"><a href="#2-常用指令" class="headerlink" title="2.常用指令"></a>2.常用指令</h3><pre class="line-numbers language-none"><code class="language-none">$ set args           #指定运行时参数，如：set args 10 20 30 40 50$ show args          #查看设置好的运行参数$ gdb appName        #进入调试模式(gdb) file fileName #指定调试文件(gdb) q             #退出调试模式quit(gdb) start         #开始调试，停在第一行代码处(gdb) r             #run,若没有下过断点，则执行完整个程序；否则程序暂停在下一个可用断点处(gdb) s             #单步执行step,进入函数内部(gdb) n             #执行单步调试next，不会进入函数内部(gdb) ni            #汇编单步执行，不会进入函数内部(gdb) si            #汇编单步执行，会进入函数内部(gdb) l             #列出所有源代码list(gdb) b main        #在main函数处打断点break(gdb) b 10          #在第10行位置打断点(gdb) b test:10     #在test文件的第10行位置打断点(gdb) b 0x3400a     #在0x3400a内存位置打断点(gdb) b 10 if i==3  #设置条件断点，i等于3时在第十行位置打断点，适用于循环(gdb) d 3           #delete编号为3的断点，清除时GDB不会给出任何提示(gdb) clear 3       #清除第3行的断点，清除时GDB会给出提示(gdb) disable 3,4   #冻结编号为3和4的断点 多个断点使用逗号分隔(gdb) enable 3,4    #启动编号为3和4的断点 多个断点使用逗号分隔(gdb) info break    #查看断点信息(gdb) tbreak 行号/函数名 #设置临时断点，到达后被自动删除(gdb) awatch/watch a   #当变量a被读出或写入时程序被暂停(gdb) rwatch a         #当变量a被读出时程序被暂停(gdb) c             #运行到断点处continue(gdb) p a           #print打印变量a的值(gdb) x /6cb 0x804835c #打印地址0x804835c起始的内存内容，连续6个字节，以字符格式输出(gdb) call fun      #在当前位置执行函数fun(gdb) display a     #设置需要跟踪的变量a 每次断点到该处就显示该变量的值(gdb) info display  #显示当前所有跟踪的情况(gdb) undisplay 3   #取消对编号为3的跟踪事件(gdb) set i=3       #临时设置变量i的值为3(gdb) show i        #使用 show 指令查看运行时参数(gdb) finish        #退出进入的函数(gdb) help print    #查看print指令的解释说明(gdb) help          #查看所有指令(gdb) info reg      #查看寄存器状态(gdb) info stack    #查看堆栈状态(gdb) shell ls      #运行shell指令ls(gdb) path          #可设定程序的运行路径(gdb) show paths    #查看程序的运行路径(gdb) cd            #相当于shell的cd命令。(gdb) pwd  　       #显示当前的所在目录(gdb) 回车          #重复上一条指令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-编程题"><a href="#3-编程题" class="headerlink" title="3 编程题"></a>3 编程题</h3><h4 id="3-1-C语言字符串加密和解密"><a href="#3-1-C语言字符串加密和解密" class="headerlink" title="3.1 C语言字符串加密和解密"></a>3.1 C语言字符串加密和解密</h4><p>加密的方式：将字符串中每个字符加上它在字符串中的位置和一个偏移值 5。以字符串“mrsoft”为例，第一个字符“m”在字符串中的位置为 0，那么它对应的密文是“’m’+0+5”，即 r。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){    int i;int mode=4;    int count=0;    char Text[128]={'\0'};    char cryptograph[128]={'\0'};    while(1)    {        if(mode==1)        {            printf("请输入要加密的明文：\n");            scanf ("%s",&amp;Text);            count=strlen(Text);            for(i=0;i&lt;count;i++)            {                cryptograph[i]=Text[i]+i+5;            }            cryptograph[i]='\0';            printf("加密后的密文是：%s\n",cryptograph);        }        else if(mode==2)        {            count=strlen(Text);            for(i=0;i&lt;count;i++)            {                Text[i]=cryptograph[i]-i-5;            }            Text[i]='\0';            printf("解密后的明文是：%s\n",Text);        }        else if(mode==3)        {            break;        }        else        {            printf("请输入正确的命令符：\n");        }printf("输入1加密新的明文，输入2对刚加密的密文进行解密，输入3退出系统：\n");        printf("请输入命令符：\n");        scanf("%d",&amp;mode);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-输出等腰三角形"><a href="#3-2-输出等腰三角形" class="headerlink" title="3.2 输出等腰三角形"></a>3.2 输出等腰三角形</h4><p>从键盘输入任意整数 n，通过程序运行输出对应高度为 n 的等腰三角形。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;int trangle(int n){    int i,j;    for(i=0;i&lt;n;i++)    {        for(j=0;j&lt;=n-i;j++)            putchar(' ');        for(j=0;j&lt;=2*i;j++)            putchar('*');        putchar('\n');    }    return 0;}int main(){    int n;    printf("Enter n：");    scanf("%d",&amp;n);    printf("\n");    trangle(n);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-整数逆序输出"><a href="#3-3-整数逆序输出" class="headerlink" title="3.3 整数逆序输出"></a>3.3 整数逆序输出</h4><p>从键盘输入的整数存放到一个数组中，通过程序的运行按照数组中的逆序输出该整数，利用递归的方法解决问题。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;int convert(char s[],int n){    int i;    if((i=n/10)!=0)         convert(s+1,i);    *s=n%10+'0';    return 0;}int main(){    int num;    char str[10]=" "; //char *str = (char *)malloc(10);    printf("input integer data：");    scanf("%d",&amp;num);    convert(str,num);    printf("output string：\n");    puts(str);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-九九乘法表"><a href="#3-4-九九乘法表" class="headerlink" title="3.4 九九乘法表"></a>3.4 九九乘法表</h4><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;int main() {    int i,j;    for(i=1;i&lt;=9;i++){        for(j=1;j&lt;=9;j++){            if(j&lt;i)                //打印八个空格，去掉空格就是左上三角形                 printf("        ");            else                printf("%d*%d=%2d  ",i,j,i*j);        }        printf("\n");      }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dmalloc</title>
      <link href="/2022/07/25/dmalloc/"/>
      <url>/2022/07/25/dmalloc/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="代码检视"><a href="#代码检视" class="headerlink" title="代码检视"></a>代码检视</h2><p>当设备频繁出现崩溃 挂上coredump后发现每次崩溃产生的core文件都不同 这时候需要找到堆内存越界源头问题才能解决。</p><p>如果在linux主机服务器（workstation）上，valgrind工具是首选，但在嵌入式arm-linux平台上，轻量级的dmalloc就是一个不错的选择。</p><h3 id="1-dmalloc"><a href="#1-dmalloc" class="headerlink" title="1 dmalloc"></a>1 dmalloc</h3><h4 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h4><p><em>dmalloc</em>是一个简单易用的<em>C/C++<em>内存</em>leak</em>检查工具，以一个运行库的方式发布。<em>dmalloc</em>能够检查出直到程序运行结束还没有释放的内存，并且能够精确指出在哪个源文件的第几行。</p><p><em>dmalloc</em> 主页：<code>http://dmalloc.com</code></p><p>支持的平台：<code>AIX, BSD/OS, DG/UX, Free/Net/OpenBSD, GNU/Hurd, HPUX, Irix, Linux, MS-DOG, NeXT, OSF, SCO, Solaris, SunOS, Ultrix, Unixware, Windoze, and even Unicos on a Cray T3E</code>.</p><h4 id="1-2-编译-amp-安装"><a href="#1-2-编译-amp-安装" class="headerlink" title="1.2 编译&amp;安装"></a>1.2 编译&amp;安装</h4><p>最新版本下载 <em><a href="http://dmalloc.com/releases/dmalloc-5.6.5.tgz">http://dmalloc.com/releases/dmalloc-5.6.5.tgz</a></em></p><p>configure选项</p><pre class="line-numbers language-none"><code class="language-none">Optional Features:  --disable-option-checking  ignore unrecognized --enable/--with options  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]   --disable-cxx           do not build in C++ support (enabled by default)   --enable-threads        build in thread support (disabled by default)   --enable-shlib          build shared libraries (disabled by default)Some influential environment variables:  CC          C compiler command  CFLAGS      C compiler flags  LDFLAGS     linker flags, e.g. -L&lt;lib dir&gt; if you have libraries in a              nonstandard directory &lt;lib dir&gt;  LIBS        libraries to pass to the linker, e.g. -l&lt;library&gt;  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I&lt;include dir&gt; if              you have headers in a nonstandard directory &lt;include dir&gt;  CXX         C++ compiler command  CXXFLAGS    C++ compiler flags  CPP         C preprocessor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">$tar zxvf dmalloc-5.5.2.Tgz $cd dmalloc-5.5.2  $./configure --prefix=/usr/local CC=gcc CXX=g++$make &amp; make threads &amp; make cxx$sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>/usr/local/bin目录下面生成dmalloc可执行程序。</p><p>/usr/local/lib下面是生成的依赖库libdmalloc.a libdmallocth.a</p><p>/usr/local/include 下面是包含了头文件dmalloc.h</p><p>注：嵌入式板卡环境需要设置对应的交叉编译器，并将编译输出文件拷贝板卡对应目录。</p><pre class="line-numbers language-none"><code class="language-none">$ ./configure --prefix=/usr/local/arm/dmalloc CC=arm-linux-gnueabihf-gcc CXX=arm-linux-gnueabihf-g++ --host=Linux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-3-环境设置"><a href="#1-3-环境设置" class="headerlink" title="1.3 环境设置"></a>1.3 环境设置</h4><p>bash, ksh, and zsh users should add the following to their <code>.bashrc',</code>.profile’, or <code>.zshrc' file respectively (notice the </code>-b’ option for bourne shell output):</p><pre class="line-numbers language-none"><code class="language-none">function dmalloc { eval `command dmalloc -b $*`; }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>then</p><pre class="line-numbers language-none"><code class="language-none">source ~/.bashrc or source ~/.profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可在源文件中添加下面的<em>C</em>代码：</p><pre class="line-numbers language-none"><code class="language-none">#ifdef DMALLOC#include "dmalloc.h"#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>值得注意的是：要在每一个*.C*文件里面添加，而且必须添加在所包含的<strong>头文件最后一行</strong>！</p><h4 id="1-4-使用"><a href="#1-4-使用" class="headerlink" title="1.4 使用"></a>1.4 使用</h4><h5 id="1-4-1-dmalloc常用命令"><a href="#1-4-1-dmalloc常用命令" class="headerlink" title="1.4.1 dmalloc常用命令"></a>1.4.1 dmalloc常用命令</h5><pre class="line-numbers language-none"><code class="language-none">[-b]              or --bourne-shell        set output for bourne shells[-C]              or --c-shell             set output for C-type shells[-g]              or --gdb                 set output for gdb parsing[-R]              or --rc-shell            set output for rc shell[-a address:#]    or --address             stop when malloc sees address[-c]              or --clear               clear all variables not set[-d value]        or --debug-mask          hex flag to set debug mask[-D]              or --debug-tokens        list debug tokens[-e errno]        or --errno               print error string for errno[-f path]         or --file                config if not $HOME/.dmallocrc[-h]              or --help                print help message[-i value]        or --interval            check heap every number times[-k]              or --keep                keep settings (override -r)[-l path]         or --logfile             file to log messages to[-L]              or --long-tokens         set env with tokens not 0x...[-m token(s)]     or --minus               del tokens from current debug[-M value]        or --memory-limit        limit allocations to this amount[-n]              or --no-changes          make no changes to the env[-o number]       or --lock-on             number of times to not lock[-p token(s)]     or --plus                add tokens to current debug[-r]              or --remove              remove other settings if tag[-s file:line]    or --start-file          check heap after this location[-S number]       or --start-iter          check heap after this iteration[--start-size size]                        check heap after this mem size[-t]              or --list-tags           list tags in rc file[-u]              or --usage               print usage messages[-v]              or --verbose             turn on verbose output[-V]              or --very-verbose        turn on very-verbose output[--version]                                display version string[tag]                                      debug token, internal or from rc f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">dmalloc -i 100 -l dmalloc_crash.log low<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>100为次数，100次内存操作进行一次检查 ，值过小检查频率高，性能影响较大。值过大检查频率低  检查延后性大 ，应该调整为适合项目的具体值。</p><p>文件存储路径/tmp/dmalloc_crash.log，也可在代码中调用dmalloc_debug_setup接口设置。</p><h5 id="1-4-2-链接方式"><a href="#1-4-2-链接方式" class="headerlink" title="1.4.2 链接方式"></a>1.4.2 链接方式</h5><p>代码中Makefile修改里面加上链接库<code>-ldmalloch</code>  <code>LD_FLAGS+=libdmallocth.a</code>，重新执行编译链接即可，如：</p><pre class="line-numbers language-none"><code class="language-none">arm-linux-g++ file.c -DDMALLOC -DDMALLOC_FUNC_CHECK -ldmallocgcc -Iinclude -Llib -DDMALLOC main.c -ldmalloc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="1-4-3-两种常用使用方式"><a href="#1-4-3-两种常用使用方式" class="headerlink" title="1.4.3 两种常用使用方式"></a>1.4.3 两种常用使用方式</h5><ul><li><p> 调试程序<strong>只进行dmalloc静态库的编译链接</strong>，这种方式的好处是对于代码量比较大的现有程序，无需要关心每个.c文件的编译细节，只需要将dmalloc静态库放在程序依赖的最后面即可。但缺点是针对不同CPU体系需要了解基本的函数返回地址汇编实现，同时即使得到了泄露源的地址变量，但也需要借助gdb、objdump或map文件等手段得到该泄露源的真正文件/行号或函数范围。</p></li><li><p> 除了使用dmalloc静态库编译链接外，还需要在每个要调试的.c程序文件中加入dmalloc.h文件的引用，这种方式的原理是使用dmalloc.h头文件的宏定义将需要调试的.c程序文件中的<strong>malloc替换为dmalloc_malloc</strong>，这种方式的好处和上面方式正好相反，不需要了解不同CPU体系的汇编，不需要借助gdb等工具，因为编译宏的替换可以直接使用FILE、LINE宏，所以得到的调试信息直接是可以看到的文件名/行号。但缺点也很明显，需要保证所有需要调试的.c程序文件，都要引用了dmalloc.h头文件。</p></li></ul><h4 id="1-5-demo"><a href="#1-5-demo" class="headerlink" title="1.5 demo"></a>1.5 demo</h4><h5 id="1-5-1-测试demo源码"><a href="#1-5-1-测试demo源码" class="headerlink" title="1.5.1 测试demo源码"></a>1.5.1 测试demo源码</h5><pre class="line-numbers language-none"><code class="language-none">1 #include &lt;stdio.h&gt;2 #include &lt;stdlib.h&gt;3 #include &lt;string.h&gt;45 #ifdef DMALLOC6 #include &lt;dmalloc.h&gt;7 #endif8  9 int main(int argc, char *argv[]) {10 #ifdef DMALLOC11 //extern void dmalloc_debug_setup(const char *opions_str);12 char* option = "debug=0x4e48503,inter=1,log=/mnt/h/GitResponsity \13                      /MemCheck/release/0725/dmalloc_crash.log";14 dmalloc_debug_setup(option);15 printf("set log:%s\r\n",option);16 #endif17 18char* buff = (char*)malloc(10);19    printf("dmalloc test\r\n");2021char* data = (char*)malloc(20);22for(int i=0;i&lt;20;i++)23{24data[i] = i;25}26free(data);27    return 0;28 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-5-2-简单的makefile"><a href="#1-5-2-简单的makefile" class="headerlink" title="1.5.2 简单的makefile"></a>1.5.2 简单的makefile</h5><pre class="line-numbers language-none"><code class="language-none">target = testCC = gcc#CC = arm-linux-gnueabihf-gcc$(target):file.c$(CC) -Wall -O2 -g $^ -o $@ -DDMALLOC -DDMALLOC_FUNC_CHECK -L /usr/local/arm/dmalloc/lib -ldmallocclean:rm -rf $(target)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-5-3-dmalloc-crash-log文件"><a href="#1-5-3-dmalloc-crash-log文件" class="headerlink" title="1.5.3 dmalloc_crash.log文件"></a>1.5.3 dmalloc_crash.log文件</h5><pre class="line-numbers language-none"><code class="language-none">1658734748: 4: Dmalloc version '5.6.5' from 'http://dmalloc.com/'1658734748: 4: flags = 0x4e48d03, logfile '/mnt/h/GitResponsity/MemCheck/release/0725/dmalloc_crash.log'1658734748: 4: interval = 1, addr = 0x0, seen # = 0, limit = 01658734748: 4: starting time = 16587347481658734748: 4: process pid = 5001658734748: 4: Dumping Chunk Statistics:1658734748: 4: basic-block 4096 bytes, alignment 8 bytes1658734748: 4: heap address range: 0x7fbb7bf10000 to 0x7fbb7bfa1000, 593920 bytes1658734748: 4:     user blocks: 2 blocks, 7658 bytes (18%)1658734748: 4:    admin blocks: 8 blocks, 32768 bytes (80%)1658734748: 4:    total blocks: 10 blocks, 40960 bytes1658734748: 4: heap checked 51658734748: 4: alloc calls: malloc 3, calloc 0, realloc 0, free 11658734748: 4: alloc calls: recalloc 0, memalign 0, valloc 01658734748: 4: alloc calls: new 0, delete 01658734748: 4:   current memory in use: 522 bytes (2 pnts)1658734748: 4:  total memory allocated: 542 bytes (3 pnts)1658734748: 4:  max in use at one time: 542 bytes (3 pnts)1658734748: 4: max alloced with 1 call: 512 bytes1658734748: 4: max unused memory space: 546 bytes (50%)1658734748: 4: top 10 allocations:1658734748: 4:  total-size  count in-use-size  count  source1658734748: 4:          20      1           0      0  file.c:211658734748: 4:          10      1          10      1  file.c:181658734748: 4:          30      2          10      1  Total of 21658734748: 4: Dumping Not-Freed Pointers Changed Since Start:1658734748: 4:  not freed: '0x7fbb7bf70fe8|s1' (10 bytes) from 'file.c:18'1658734748: 4:  not freed: '0x7fbb7bfa0c08|s1' (512 bytes) from 'unknown'1658734748: 4:  total-size  count  source1658734748: 4:          10      1  file.c:181658734748: 4:          10      1  Total of 11658734748: 4: ending time = 1658734748, elapsed since start = 0:00:00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-6-局限性"><a href="#1-6-局限性" class="headerlink" title="1.6 局限性"></a>1.6 局限性</h4><ul><li><em>dmalloc</em>只能检测堆上内存，对栈内存和静态内存无能为力。</li><li><em>dmalloc</em>只用于利用<em>malloc</em>申请的内存，对使用*sbrk()<em>或</em>mmap()*分配的内存无能为力。</li><li><em>dmalloc</em>不能用于检测读写没有申请的或者没有初始化的内存，也不能检测写只读内存。</li></ul><h5 id="1-7-注意事项"><a href="#1-7-注意事项" class="headerlink" title="1.7 注意事项"></a>1.7 注意事项</h5><p>为了在 C++ 及线程中使用 dmalloc，必须把应用链接成静态。</p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生化分析仪</title>
      <link href="/2022/07/25/sheng-hua-fen-xi-yi/"/>
      <url>/2022/07/25/sheng-hua-fen-xi-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="生化分析仪"><a href="#生化分析仪" class="headerlink" title="生化分析仪"></a>生化分析仪</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>​        <em>生化分析仪</em>又常被称为<em>生化仪</em>，是采用光电比色原理来测量体液中某种特定化学成分的仪器。由于其测量速度快、准确性高、消耗试剂量小，现已在各级医院、防疫站、计划生育服务站得到广泛使用。配合使用可大大提高常规生化检验的效率及收益。</p><p>2 分析方法</p><p>​        生化分析仪常用分析方法共有三大类，分别为终点法、固定时间法和动力学法。</p><p>2.1 终点法</p><p>​        指经过一段时间的反应，反应达到平衡，由于反应的平衡常数很大，可认为全部底物(被测物)转变成产物，反应液的吸光度不再变化，只与被测物的浓度有关。这类方法通常称为“终点”法，更确切地说应称“平衡”法。</p><p><strong>单试剂单波长终点法：</strong>t1时刻加入试剂（体积为V），t2刻加入样本（体积为S），然后搅拌并反应，之后开始测量反应液的吸光度，在t3时刻反应达到终点，t3－t2为测定时间。</p><p><strong>反应度：</strong>R＝At3－At2-1×V/(V＋S)，或R＝At3－ARBLK。</p><p><strong>其中：</strong> Ati为i时刻的吸光度，ARBLK为试剂空白吸光度。</p><p><strong>单试剂双波长终点法：</strong>基本上同“单试剂单波长终点法”，只是对于每一个测定周期，其实际吸光度等于Aλ1－Aλ2。</p><p><strong>双试剂单波长终点法：</strong>t1时刻加入第一试剂(体积为V1)，t2时刻加入样本(体积为S)之后立即搅拌，t3时刻加入第二试剂(体积为V2) 并立即搅拌，t4时刻反应达到终点。t3-t2为孵育时间,t4-t3为测定时间。</p><p> 在项目参数中，如果反应起始时间设为0，则反应度R=A时刻吸光度-双试剂空白吸光度。  如果反应起始时间小于0，则反应度R=At4 -双试剂空白吸光度-t3到t2间设定点的吸光度×（V1＋S）/(V1＋S＋V2)。<strong>双试剂双波长终点法：</strong> 基本上同“双试剂单波长终点法”，只是对于每一个测定周期，其实际吸光度等于Aλ1－Aλ2。</p><p>2.2 固定时间法</p><p>​        又称为一级动力学法、二点动力学法等，指在一定的反应时间内，反应速度与底物浓度的一次方成正比，即v=k[S]。由于底物在不断的消耗，因此整个反应速度在不断的减小，表现为吸光度的变化越来越小。这类反应达到平衡的时间很长，理论上可以在任意时间段进行监测，但由于血清成份复杂，反应刚启动时反应较复杂，杂反应较多，必需经过一段延迟时间才能进入稳定反应期。</p><p>**t1时刻加入试剂(体积为V)**，之后测量试剂空白的吸光度，t2时刻加入样本(体积为S)，t3时刻反应稳定，t4时刻停止对反应进行监测；t2－t3为延迟时间，t3－t4为测定时间。</p><p>单波长反应度（单双试剂相同）：R=At4—At3</p><p><strong>双波长反应度：</strong>R=（t4时刻主波长吸光度－t4时刻次波长吸光度）­－（t3时刻主波长吸光度－t3时刻次波长吸光度）</p><p>3.3 动力学法</p><p>​        又称零级动力学法，指反应速度与底物浓度的零次方成正比，也就是与底物浓度无关。因此，在整个反应过程中，反应物可以匀速地生成某个产物，导致被测定溶液在某一波长下吸光度均匀地减小或增加，减小或增加的速度(ΔA/min)与被测物的活性或浓度成正比。动力学法也被称为连续监测法；主要用于酶活性的测定。</p><p>实际上，由于底物浓度不可能足够大，随着反应的进行，底物消耗到一定程度后，反应速度不再为零级，因此，零级动力学法是针对于特定时间段而言的；同样，由于血清成份复杂，反应刚启动时反应较复杂，杂反应较多，必需经过一段延迟时间才能进入稳定反应期，各试剂商对这两段时间有严格规定。</p><p>t1时刻加入试剂(体积为V)，t2时刻加入样本(体积为S)，t3时刻反应稳定，tn时刻停止对反应进行监测；t3-t2为延迟时间，tn-t3为测定时间。 单波长反应度（单双试剂相同）R＝（n∑AT－∑A∑T）/［n∑T2－（∑T）2］,其中：n＝t3到tn间的数据个数 ，T＝时间 ， A=某一时间的吸光度。双波长反应度基本同单波长，只是某一时间的吸光度等于主波长吸光度减去次波长吸光度。</p><p>1.内存泄漏检测工具dema</p><ol start="2"><li>5个 培训 调试gdb 题目 算法 越界 空指针 </li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 仪器知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 仪器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uml</title>
      <link href="/2022/06/12/uml/"/>
      <url>/2022/06/12/uml/</url>
      
        <content type="html"><![CDATA[<h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><h2 id="1-UML概述"><a href="#1-UML概述" class="headerlink" title="1.UML概述"></a><strong>1.UML概述</strong></h2><h3 id="1-1-什么是UML"><a href="#1-1-什么是UML" class="headerlink" title="1.1 什么是UML"></a><strong>1.1 什么是UML</strong></h3><p>​        UML(United Modeling Language, 统一建模语言)： 是一种基于面向对象的可视化建模语言，可以用来描述、可视化、构造和文档化软件密集型系统的各种工件。采用了一组形象化的图形(如类图)符号作为建模语言，使用这些符号可以形象地描述系统的各个方面,通过建立图形之间的各种关系(如类与类之间的关系)来描述模型。</p><p>​        UML是独立于过程的，它<strong>适用于各种软件开发方法、软件生命周期的各个阶段、各种应用领域以及各种开发工具</strong>。</p><p><img src="/2022/06/12/uml/relation.png"></p><h3 id="1-2-UML的目标"><a href="#1-2-UML的目标" class="headerlink" title="1.2 UML的目标"></a>1.2 <strong>UML的目标</strong></h3><ol><li>为建模者提供可用的、富有表达力的、可视化的<strong>建模语言</strong>，以开发和交换<strong>有意义的模型</strong>。</li><li>提供可扩展性和特殊化机制以延伸核心概念。</li><li>支持<strong>独立于编程语言和开发过程的规范</strong>。</li><li>为理解建模语言提供正式的基础。</li><li>推动<strong>面向对象建模工具</strong>市场的成长。</li><li>支持更高级的开发概念。</li></ol><h3 id="1-3-UML的应用范围"><a href="#1-3-UML的应用范围" class="headerlink" title="1.3 UML的应用范围"></a><strong>1.3 UML的应用范围</strong></h3><p><img src="/2022/06/12/uml/3.png"></p><h3 id="1-4-UML的构造块：事物、关系、图"><a href="#1-4-UML的构造块：事物、关系、图" class="headerlink" title="1.4 UML的构造块：事物、关系、图"></a><strong>1.4 UML的构造块：事物、关系、图</strong></h3><p><img src="/2022/06/12/uml/4.png"></p><h3 id="1-5-基本构件"><a href="#1-5-基本构件" class="headerlink" title="1.5 基本构件"></a>1.5 <strong>基本构件</strong></h3><p><img src="/2022/06/12/uml/1.png" alt="UML结构图"></p><p><img src="/2022/06/12/uml/2.png" alt="UML元素"></p><h2 id="2-用例图"><a href="#2-用例图" class="headerlink" title="2 用例图"></a><strong>2 用例图</strong></h2><h3 id="2-1-用例图基本概念"><a href="#2-1-用例图基本概念" class="headerlink" title="2.1 用例图基本概念"></a><strong>2.1 用例图基本概念</strong></h3><p>​        用例图是用来描述<strong>系统功能</strong>的技术，表示一个系统中<strong>用例</strong>与<strong>参与者</strong>及其<strong>关系</strong>的图，主要用于<strong>需求分析阶段</strong>。用例图的基本组成元素：<strong>参与者、用例、元素之间的关系</strong>。</p><h4 id="2-1-1-使用范围——需求分析"><a href="#2-1-1-使用范围——需求分析" class="headerlink" title="2.1.1 使用范围——需求分析"></a><strong>2.1.1 使用范围——需求分析</strong></h4><ol><li>捕获需求。描述<strong>功能需求、行为需求</strong>（系统要完成什么任务）</li><li>分析需求。明确<strong>类和对象</strong>，建立之间的关系</li></ol><h4 id="2-1-2-基本概念"><a href="#2-1-2-基本概念" class="headerlink" title="2.1.2.基本概念"></a><strong>2.1.2.基本概念</strong></h4><ol><li>用例图是表示一个系统中<strong>用例与参与者关系之间的图</strong>。它描述了<strong>系统中相关的用户和系统</strong>对<strong>不同用户提供的功能和服务</strong>。</li><li>用例图相当于<strong>从用户的视角来描述和建模整个系统</strong>，分析系统的功能与行为。</li><li>用例图中的主要元素包括参与者、用例以及元素之间的关系。此外，用例图<strong>还可以包括注解和约束</strong>，也可以<strong>使用包将图中的元素组合成模块</strong>。</li></ol><h4 id="2-1-3-用例图示例"><a href="#2-1-3-用例图示例" class="headerlink" title="2.1.3.用例图示例"></a><strong>2.1.3.用例图示例</strong></h4><p><img src="/2022/06/12/uml/5.png"></p><h3 id="2-2-参与者"><a href="#2-2-参与者" class="headerlink" title="2.2.参与者"></a><strong>2.2.参与者</strong></h3><h4 id="2-2-1-参与者概念"><a href="#2-2-1-参与者概念" class="headerlink" title="2.2.1.参与者概念"></a>2.2.1.参与者概念</h4><ol><li>参与者是与<strong>系统主体交互的外部实体的类元</strong>，描述了一个或一组与系统产生交互的<strong>外部用户或外部事物</strong>。</li><li>参与者位于系统边界之外，而<strong>不是系统的一部分</strong>。</li><li>参与者是<strong>从现实世界中抽象出来的一种形式</strong>，却不一定确切对应的现实中的某个特定对象</li></ol><p>参与者的表示：</p><p><img src="/2022/06/12/uml/actor.png"></p><h3 id="2-2-2-如何确认参与者"><a href="#2-2-2-如何确认参与者" class="headerlink" title="2.2.2.如何确认参与者"></a>2.2.2.如何确认参与者</h3><p>​        通过对参与者进行关注和分析，我们可以<strong>把重点放在如何与系统交互这一问题上</strong>，便于进一步确定系统的边界。另外，<strong>参与者也决定了系统需求的完整性</strong>。</p><p>确定参与者可以从以下几个角度来考虑：</p><ol><li>为系统提供输入的人或事物</li><li>接收系统输出的人或事物</li><li>需要接入的第三方系统或设备</li><li>时间是否会触发某些事件</li><li>负责支持或维护系统中信息的人</li></ol><h3 id="2-2-3-参与者分类"><a href="#2-2-3-参与者分类" class="headerlink" title="2.2.3. 参与者分类"></a>2.2.3. 参与者分类</h3><ul><li>主要业务参与者：主要从<strong>用例的执行中获得好处的</strong>关联人员。</li><li>主要系统参与者：直接<strong>同系统交互以发起或触发业务或系统事件</strong>的关联人员。</li><li>外部服务参与者：<strong>响应来自用例的请求</strong>的关联人员。</li><li>外部接收参与者：从用例中接收<strong>某些价值或输出</strong>的非主要的关联人员。</li></ul><h3 id="2-2-4-参与者的泛化关系"><a href="#2-2-4-参与者的泛化关系" class="headerlink" title="2.2.4.参与者的泛化关系"></a>2.2.4.参与者的泛化关系</h3><p>​        当系统中的几个参与者既扮演自身的角色，同时也有更一般化的角色时，可以通过建立泛化关系来进行描述。</p><p>​        与类相似，父参与者可以是抽象的，即不能创建一个父参与者的直接实例，这就要求属于抽象父参与者的外部对象一定能够属于其子参与者之一。</p><p><img src="/2022/06/12/uml/actor2.png"></p><h3 id="2-3-用例"><a href="#2-3-用例" class="headerlink" title="2.3.用例"></a><strong>2.3.用例</strong></h3><h3 id="2-3-1-用例的概念"><a href="#2-3-1-用例的概念" class="headerlink" title="2.3.1.用例的概念"></a>2.3.1.用例的概念</h3><p>​        用例是类元提供的一个<strong>内聚的的功能单元</strong>，表明系统与一个或多个参与者之间<strong>信息交换的顺序</strong>，也表明了<strong>系统执行的动作</strong>。</p><p>​        简单来说，用例就是某一个参与者在系统中<strong>做某件事从开始到结束的一系列活动的集合</strong>，以及<strong>结束时应该返回的可观测、有意义的结果</strong>，其中<strong>也包含可能的各种分支情况</strong>。用例与用例图被广泛使用于系统的<strong>需求建模阶段</strong>，<strong>并在系统的整个生命周期中被不断细化</strong>。</p><p>用例表示如下：</p><p><img src="/2022/06/12/uml/instance.png"></p><h3 id="2-3-2-用例与参与者的关系"><a href="#2-3-2-用例与参与者的关系" class="headerlink" title="2.3.2.用例与参与者的关系"></a>2.3.2.用例与参与者的关系</h3><p>​        <strong>一个用例可以隶属一个或多个参与者</strong>，<strong>一个参与者也可以参与一个或多个用例</strong>。用例与参与者之间存在关联关系。</p><p>主参与者与次参与者：通常来说主参与者是用例的重要服务对象，而次参与者处于一种协作地位。</p><p><img src="/2022/06/12/uml/instance_actor.png"></p><h3 id="2-3-4-用例的特征"><a href="#2-3-4-用例的特征" class="headerlink" title="2.3.4.用例的特征"></a>2.3.4.用例的特征</h3><p>用例的特征<strong>保证用例能够正确地捕捉功能性需求</strong>，同时<strong>也是判断用例是否准确的依据</strong>。</p><ol><li>用例是<strong>动宾短语</strong></li><li>用例是<strong>相对独立</strong>的</li><li>用例是****由参与者启动****的</li><li>用例要<strong>有可观测的执行结果</strong></li><li>一个用例是一个单元</li></ol><h2 id="2-4-用例之间的关系"><a href="#2-4-用例之间的关系" class="headerlink" title="2.4.用例之间的关系"></a>2.4.用例之间的关系</h2><p>用例之间的关系有：泛化关系、依赖关系（包含、扩展）</p><h3 id="2-4-1-泛化关系"><a href="#2-4-1-泛化关系" class="headerlink" title="2.4.1.泛化关系"></a>2.4.1.泛化关系</h3><p>​        与参与者的泛化关系相似，<strong>用例的泛化关系将特化的用例与一般化的用例联系起来</strong>。子用例<strong>继承了父用例的属性、操作和行为序列</strong>，并且<strong>可以增加属于自己的附加属性和操作</strong>。父用例同样可以定义为抽象用例。</p><p>用例之间的泛化关系表示为一根实线三角箭头，箭头指向父用例一方。如下图：</p><p><img src="/2022/06/12/uml/fanhua.png"></p><h4 id="2-4-2-依赖关系——包含"><a href="#2-4-2-依赖关系——包含" class="headerlink" title="2.4.2.依赖关系——包含"></a><strong>2.4.2.依赖关系——包含</strong></h4><p>​        包含指的是<strong>一个用例（基用例）可以包含其他用例（包含用例）具有的行为</strong>，<strong>其中包含用例中定义的行为将被插入基用例定义的行为中</strong>。</p><p>包含的两个基本约束：</p><ol><li>基用例可以看到包含用例，并需要依赖于包含用例的执行结果，但是<strong>它对包含用例的内部结构没有了解</strong>；</li><li>基用例一定<strong>会要求包含用例执行</strong>。</li></ol><p> 包含表示为一个虚线箭头附加上《include》的构造型，<strong>箭头从基用例指向包含用例</strong>。</p><p><img src="/2022/06/12/uml/yilai.png"></p><p><img src="/2022/06/12/uml/yilai2.png"></p><h3 id="2-4-3-依赖关系——扩展"><a href="#2-4-3-依赖关系——扩展" class="headerlink" title="2.4.3.依赖关系——扩展"></a>2.4.3.依赖关系——扩展</h3><p>扩展指的是一个用例（扩展用例）对另一个用例（基用例）<strong>行为的增强</strong>。</p><p>扩展使用一个附加了《enxtend》构造型的虚线箭头表示，<strong>箭头指向基用例</strong>。</p><p>注意：<strong>扩展与包含的箭头方向是相反的</strong>，这表明扩展取决于扩展用例而非基用例，扩展用例决定扩展的执行时机，<strong>基用例对此一无所知</strong>。</p><p><img src="/2022/06/12/uml/extend_depened.png"></p><p><img src="/2022/06/12/uml/blog\myblog\source_posts\uml\extend_depened2.png"></p><p>扩展用例的使用包括四个部分：</p><ol><li>基用例：<strong>需要被扩展的用例</strong>，“注册”用例。</li><li>扩展用例：提供所添加的行为序列的用例。</li><li>扩展关系：使用虚线箭头表示，箭头指向基用例。</li><li>扩展点：基用例中的一个或多个位置，表示在该位置会根据某条件来决定是否要中断基用例的执行从而执行扩展用例中的片段。</li></ol><h3 id="2-4-4-包含、扩展的区别"><a href="#2-4-4-包含、扩展的区别" class="headerlink" title="2.4.4.包含、扩展的区别"></a>2.4.4.包含、扩展的区别</h3><p>根本区别，包含是无条件执行，扩展是有条件执行。图的起点不同，终点也不同。</p><table><thead><tr><th><strong>特性</strong></th><th><strong>include</strong></th><th><strong>extend</strong></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>增强基用例的行为</td><td>增强基用例的行为</td></tr><tr><td><strong>执行过程</strong></td><td>包含用例一定会执行</td><td>扩展用例可能被执行</td></tr><tr><td><strong>对基用例的要求</strong></td><td>在没有包含用例的情况下，基用例可以是也可以不是良构的</td><td>在没有扩展用例的情况下，基用例一定是良构的</td></tr><tr><td><strong>表示法</strong></td><td>箭头指向包含用例</td><td>箭头指向基用例</td></tr><tr><td><strong>基用例对增强行为的可见性</strong></td><td>基用例可以看到包含用例，并决定包含用例的执行</td><td>基用例对扩展用例一无所知</td></tr><tr><td><strong>基用例每执行一次，增强行为的执行次数</strong></td><td>只执行一次</td><td>取决于条件（0到多次）</td></tr></tbody></table><h2 id="2-5-用例描述与文档"><a href="#2-5-用例描述与文档" class="headerlink" title="2.5.用例描述与文档"></a>2.5.用例描述与文档</h2><h3 id="2-5-1用例描述概述"><a href="#2-5-1用例描述概述" class="headerlink" title="2.5.1用例描述概述"></a><strong>2.5.1用例描述概述</strong></h3><p>一个完整的用例模型应该不仅仅包括用例图部分，<strong>还要有完整的用例描述部分</strong>。</p><p>一般的用例描述主要包括以下几部分内容：</p><ol><li>用例名称：描述用例的<strong>意图或实现的目标</strong>，一般为动词或动宾短语。</li><li>用例编号：<strong>用例的唯一标识符</strong>，在其他位置可以使用该标识符来引用用例。</li><li>参与者：描述用例的参与者，包括主要参与者和其他参与者。</li><li>用例描述：对用例的一段<strong>简单的概括描述</strong>。</li><li>触发器：<strong>触发用例执行的一个事件</strong>。</li><li>前置条件：用例<strong>执行前系统状态的约束条件</strong>。</li><li>基本事件流（典型过程）：用例的<strong>常规活动序列</strong>，包括参与者发起的动作与系统执行的响应活动。</li><li>扩展事件流（替代过程）：记录<strong>如果典型过程出现异常或变化时的用例行为</strong>，即典型过程以外的其他活动步骤。</li><li>结论：描述用例何时结束。</li><li>后置条件：用例<strong>执行后系统状态的约束条件</strong>。</li><li>补充约束：用例实现时需要考虑的<strong>业务规则、实现约束</strong>等信息。</li></ol><h3 id="2-5-2-前置条件与后置条件"><a href="#2-5-2-前置条件与后置条件" class="headerlink" title="2.5.2.前置条件与后置条件"></a><strong>2.5.2.前置条件与后置条件</strong></h3><p>前置条件指的是<strong>用例执行前系统和参与者应处于的状态</strong>。前置条件是用例的入口限制，它便于我们在进行系统分析及设计的时候注意到，<strong>在何时何地才可以合法地触发这个事件</strong>。</p><p>后置条件是<strong>用例执行完毕后系统处于的状态</strong>。后置条件是对用例执行完毕后系统状况的总结，用来确保用户理解用例执行完毕后的结果，并非其他用例的触发器。</p><p>前置条件与后置条件分别是用例在开始和结束时的<strong>必要条件</strong>。</p><h3 id="2-5-3-事件流"><a href="#2-5-3-事件流" class="headerlink" title="2.5.3.事件流"></a><strong>2.5.3.事件流</strong></h3><p>事件流是对用例在使用场景下的交互动作的抽象，应该包括用例何时以及怎样开始和结束，用例何时与参与者交互，该行为的基本流和可选择的流。</p><p>基本事件流：描述的是用例中最核心的事件流，<strong>是用例大部分时间所进行的场景</strong>。</p><p>扩展事件流：描述的是用例处理过程中的<strong>一些分支或异常情况</strong>。</p><h3 id="2-5-4-补充约束"><a href="#2-5-4-补充约束" class="headerlink" title="2.5.4.补充约束"></a><strong>2.5.4.补充约束</strong></h3><p>补充约束用来描述用例在<strong>系统功能之外的内容</strong>，例如<strong>非功能需求、业务规则</strong>等等。</p><p><strong>数据需求</strong>：与该用例相关的一些数据项的说明。</p><p><strong>业务规则</strong>：与业务相关的<strong>逻辑和操作规则</strong>。</p><p><strong>非功能性需求</strong>：例如性能、支持的并发量等。</p><p><strong>设计约束</strong>：是从多个角度对用例或系统的约定。</p><p><strong>2.6.用例文档实践</strong></p><table><thead><tr><th><strong>用例名称</strong></th><th><strong>提交订单</strong></th></tr></thead><tbody><tr><td><strong>用例编号</strong></td><td>UC002</td></tr><tr><td><strong>参与者</strong></td><td>会员</td></tr><tr><td><strong>用例描述</strong></td><td>该用例描述一个系统会员提交一份订单的行为</td></tr><tr><td><strong>触发器</strong></td><td>当订单被提交时，用例触发。</td></tr><tr><td><strong>前置条件</strong></td><td>提交订单的一方需要完成登录操作</td></tr><tr><td><strong>后置条件</strong></td><td>如果订单中的商品有库存，则发货；否则提示用户当前缺货</td></tr><tr><td><strong>基本事件流</strong></td><td>1 参与者将订单信息提交至系统。 2 系统验证用户信息及订单信息合法后作出响应。 3 对于订单中的每种产品，系统根据订单中的数量检查产品库存数量。 4 系统统计订单中产品的总价格。 5 系统从会员的系统账户余额中扣除相应金额。 6 系统生成并保存订单信息并将订单发送至分销中心。 7 系统生成订单确认页面并发送给会员。</td></tr><tr><td><strong>扩展事件流</strong></td><td>A-2 如果订单信息非法，系统通知会员并提示重新提交订单。 A-3 如果订单中产品数量超过产品库存量，则提示会员库存不足，暂无法购买，取消订单同时终止用例。 A-5 如果会员账户余额不足，系统给出相应提示，取消订单并终止用例。</td></tr><tr><td><strong>结论</strong></td><td>当会员收到系统发送的订单确认页面或其他异常信息时，用例结束。</td></tr><tr><td><strong>数据需求</strong></td><td>D-1 订单信息包括订单号、参与者的会员账户名、商品种类数量、商品种类名称以及每种商品的数量。</td></tr><tr><td><strong>业务规则</strong></td><td>B-1 只有当订单中商品信息确认无误后才能要求会员进行支付。</td></tr></tbody></table><h2 id="2-7-用例图使用要点"><a href="#2-7-用例图使用要点" class="headerlink" title="2.7.用例图使用要点"></a>2.7.用例图使用要点</h2><ol><li>构建结构良好的用例。用例图中应该<strong>只包含对系统而言必不可少的用例与相关的参与者</strong>。</li><li>用例的<strong>名称不应该简化到使读者误解其主要语义的程度</strong>。</li><li>摆放元素时应****尽量减少连接线的交叉****，以提供更好的可视化效果。</li><li>组织元素时应使在语义上接近的用例和参与者在图的位置上也同样接近，便于读者理解用例图。</li><li>可以<strong>使用注解或给元素添加颜色</strong>等方式突出图中相对重要的内容。</li><li>用例图中<strong>不应该有太多的关系种类</strong>。</li></ol><h2 id="2-8-用例图建模技术"><a href="#2-8-用例图建模技术" class="headerlink" title="2.8.用例图建模技术"></a>2.8.用例图建模技术</h2><h3 id="2-8-1-对系统的-语境建模"><a href="#2-8-1-对系统的-语境建模" class="headerlink" title="2.8.1.对系统的*语境建模*"></a><strong>2.8.1.对系统的*<em>语境建模*</em></strong></h3><ul><li>识别系统边界。</li><li>识别参与者。</li><li>如果需要，将具有相同特征的参与者使用泛化关系加以组织。</li><li>如果需要，对某些参与者应用一个构造型以便加深理解。</li><li>将参与者应用到用例图中，并描述参与者与用例间的通信路径。</li></ul><h3 id="2-8-2-对系统的-需求建模"><a href="#2-8-2-对系统的-需求建模" class="headerlink" title="2.8.2.对系统的*需求建模*"></a><strong>2.8.2.对系统的*<em>需求建模*</em></strong></h3><ul><li>识别参与者。</li><li>对于某个参与者，考虑其期望系统提供的行为或与系统的交互。</li><li>将行为提炼成用例。</li><li>完善其他用例。分解用例中的公共行为与扩展行为，放入新的用例中以供其他用例使用。</li><li>创建用例图。</li><li>如果需要，在用例图中添加一些注解或约束来陈述系统的非功能需求。</li></ul><h2 id="2-9-案例——学生选课系统"><a href="#2-9-案例——学生选课系统" class="headerlink" title="2.9.案例——学生选课系统"></a>2.9.案例——学生选课系统</h2><p>某学校的网上选课系统主要包括如下功能：</p><p>管理员通过系统管理界面进入，建立本学期要开的各种课程，将课程信息保存在数据库中并可以对课程进行改动和删除。</p><p>学生通过客户机浏览器根据学号和密码进入选课界面，在这里学生可以进行三种操作：查询已选课程，选课以及付费。</p><p>同样，通过业务层。这些操作结果存入数据库中。</p><p><strong>步骤</strong>：</p><ol><li>确定系统边界</li><li>确定参与者（名词）</li><li>确定用例（动宾结构）</li><li>确定关系（联系）</li></ol><p><strong>参与者</strong>：学生、教务人员、数据库</p><p><strong>用例</strong>：选课、查询、支付课时费用、登陆、修改课程、添加课程、删除课程</p><p><strong>关系</strong>：关联关系、泛化关系</p><p><img src="/2022/06/12/uml/select_class.png"></p><h1 id="3-类图"><a href="#3-类图" class="headerlink" title="3.类图"></a>3.类图</h1><h2 id="3-1-类图简介"><a href="#3-1-类图简介" class="headerlink" title="3.1.类图简介"></a>3.1.类图简介</h2><p> 类图的定义：是显示一组<strong>类、接口、协作以及它们之间关系</strong>的图。</p><p>类图主要包含<strong>7种元素</strong>：类、接口、协作、依赖关系、泛化关系、实现关系、关联关系。</p><p>类图：包、子系统，用来把模型元素聚集成更大的组块。</p><p>类图：约束、注解</p><p> <img src="/2022/06/12/uml/class.png"></p><h2 id="3-2-类"><a href="#3-2-类" class="headerlink" title="3.2.类"></a>3.2.类</h2><ol><li>类是一组拥有<strong>相同的属性、操作、方法、关系和行为</strong>的对象地描述符。</li><li>类定义了一组有着<strong>状态与行为的对象</strong>。类的<strong>状态由属性和关联来描述</strong>，个体行为由操作来描述，对象的生命周期则由附加给类的状态机来描述。</li><li>在UML中，类表达成一个有三个分隔区的矩形。其中顶端显示<strong>类名</strong>，中间显示<strong>类的属性</strong>，尾端显示<strong>类的操作</strong>。</li></ol><p><img src="/2022/06/12/uml/class2.png"></p><h3 id="3-2-1-类——属性"><a href="#3-2-1-类——属性" class="headerlink" title="3.2.1.类——属性"></a>3.2.1.类——属性</h3><p>可见性：描述了该<strong>属性在那些范围内可以被使用</strong>。</p><table><thead><tr><th><strong>可见性</strong></th><th><strong>英文限定符</strong></th><th><strong>UML****标准图示</strong></th><th><strong>Rose****图示</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>公有</strong></td><td>public</td><td>+</td><td></td><td>其他类可以访问</td></tr><tr><td><strong>私有</strong></td><td>private</td><td>-</td><td></td><td>只对本类可见，不能被其他类访问</td></tr><tr><td><strong>保护</strong></td><td>protected</td><td>#</td><td></td><td>对本类及其派生类可见</td></tr></tbody></table><p>类型：属性的数据类型，可以系统固有，也可以用户自定义。属性的类型决定了该属性的所有可能取值的集合。</p><h3 id="3-2-2-类——操作"><a href="#3-2-2-类——操作" class="headerlink" title="3.2.2.类——操作"></a>3.2.2.类——操作</h3><p>可见性：同样描述该操作在那些范围内可以使用，与属性的可见性相同。</p><p>参数列表：是一些按照顺序排列的属性定义了操作的输入。例如：oper(out arg1:int, arg2:double=3.2)</p><p>返回类型即回送调用对象消息的类型。void关键字表示无返回值。</p><p>特性是对操作性质的约束说明。</p><h3 id="3-2-3-类——职责"><a href="#3-2-3-类——职责" class="headerlink" title="3.2.3.类——职责"></a>3.2.3.类——职责</h3><p><strong>职责是类的契约或责任</strong>。当创建一个类时，就声明了这个类的所有对象具有相同种类的状态和相同种类的行为。在较高的抽象层次上，这些相应的属性和操作正式要完成类的职责的特征。</p><p>类的职责是自由形式的文本，在非正式的类图中，可以将职责列在类图操作下的另一分割栏中。</p><h2 id="3-3-接口"><a href="#3-3-接口" class="headerlink" title="3.3 接口"></a>3.3 接口</h2><ol><li>接口是一个<strong>被命名的操作集合</strong>，用于描述类或组件的一个服务。</li><li>接口<strong>不包含属性与方法实现</strong>，但可以有一些操作。接口的所有内容都是公有的。</li><li>接口代表了一份契约，<strong>实现该接口的类元必须履行它</strong>。</li><li>在UML中，接口由一个带名称的小圆圈表示；<strong>也可以表示为带有&lt;<interface>&gt;构造型的类</interface></strong></li></ol><p><img src="/2022/06/12/uml/observe.png"></p><p><img src="/2022/06/12/uml/observe2.png"></p><h2 id="3-4-类图中的关系"><a href="#3-4-类图中的关系" class="headerlink" title="3.4.类图中的关系"></a>3.4.类图中的关系</h2><p>UML中最常用的四种关系，即<strong>关联关系、泛化关系、依赖关系和实现关系</strong>。</p><h3 id="3-4-1-类图中的关系——关联关系"><a href="#3-4-1-类图中的关系——关联关系" class="headerlink" title="3.4.1.类图中的关系——关联关系"></a>3.4.1.类图中的关系——关联关系</h3><ol><li>关联的实例被称为链，每个链由一组有序或无序的对象组成。</li><li>关联关系靠近被关联元素的部分称为关联端，关联的大部分描述都包含在一组关联端的列表里，每个端用来描述关联中类的对象的参与</li><li>二元关联、自关联、N元关联。</li></ol><p><img src="/2022/06/12/uml/class_relation.png"></p><p><strong>注意要点</strong></p><p><strong>关联名称</strong>：放在关联路径的旁边，但远离关联端。</p><p><strong>角色</strong>：放在靠近关联端的部分，表示该关联端连接的类在这一关联关系中担任的角色。角色名上也可使用可见性修饰符号。</p><p><strong>多重性</strong>：放在靠近关联端的部分，表示在关联关系中源端的一个对象可以与目标类的多少个对象之间有关联。</p><p><strong>导航性</strong>：一个布尔值，用来说明运行时刻是否可能穿越一个关联。</p><p><strong>限定符</strong>：是二元关联上的属性组成的列表的插槽，其中的属性值用来从整个对象集合里选择一个唯一的关联对象或者关联对象的集合。</p><p>约束：关联间的约束关系。</p><p><img src="/2022/06/12/uml/array.png"></p><p><strong>现实例子</strong></p><p>比如客户和订单，每个订单对应特定的客户，每个客户对应一些特定的订单；再例如公司和员工，每个公司对应一些特定的员工，每个员工对应一特定的公司。（表示有关联，也可以表示多重性）</p><p><img src="/2022/06/12/uml/company.png"></p><p><strong>派生关联</strong>：属于一种派生元素。它不增加语义信息，只是一种可以由<strong>两个或两个以上的基础关联推算出来的虚拟关联</strong>。 </p><p><img src="/2022/06/12/uml/company2.png"></p><p> 两种特殊的关联关系：<strong>聚合关系</strong>与<strong>组合关系</strong></p><p>1.<strong>聚合关系</strong>：描述“<strong>整体-部分</strong>”的关联关系</p><p>聚合关系没有改变整体与部分之间整个关联的导航含义，也与整体和部分的生命周期无关。（部分与整体相互独立）</p><p><img src="/2022/06/12/uml/jvhe.png"></p><p> 2.<strong>组合关系</strong>：描述“整体-部分”的关联关系</p><p>组合关系中的<strong>部分要完全依赖于整体</strong>。</p><p><img src="/2022/06/12/uml/merge.png"></p><p><strong>关联与聚合的区别</strong></p><ol><li><strong>关联关系</strong>所涉及的<strong>两个对象是处在同一个层次上的</strong>。比如人和自行车就是一种关联关系，而不是聚合关系，因为人不是由自行车组成的。<strong>聚合关系</strong>涉及的<strong>两个对象处于不平等的层次上，一个代表整体，一个代表部分</strong>。比如:电脑和它的显示器、键盘、主板以及内存就是聚集关系，因为主板是电脑的组成部分。</li><li>对于具有<strong>聚集关系（尤其是强聚集关系）的两个对象</strong>，整体对象会制约它的组成对象的生命周期。部分类的对象不能单独存在，它的生命周期依赖于整体类的对象的生命周期，当整体消失，部分也就随之消失。比如张三的电脑被偷了，那么电脑的所有组件也不存在了，除非张三事先把一些电脑的组件（比如硬盘和内存）拆了下来。</li></ol><p><img src="/2022/06/12/uml/jvji.png"></p><p><strong>聚合与组合的区别</strong></p><p>聚合关系：<strong>涉及的两个对象处于不平等的层次</strong>上，一个代表整体，一个代表部分。比如:电脑和它的显示器、键盘、主板以及内存就是聚集关系，因为主板是电脑的组成部分。</p><p>组合关系：<strong>代表整体的对象负责代表部分对象的生命周期</strong>。公司不存在，部门也没有意义了。再例如：人和五脏六腑、四肢的关系。</p><p><img src="/2022/06/12/uml/zehe2.png"></p><h3 id="3-4-2-类图中的关系——泛化关系"><a href="#3-4-2-类图中的关系——泛化关系" class="headerlink" title="3.4.2.类图中的关系——泛化关系"></a>3.4.2.类图中的关系——泛化关系</h3><p><strong>泛化关系</strong>定义为一个较普通的元素与一个较特殊的元素之间的类元关系。其中描述一般的元素称为父，描述特殊的元素称为子。（<strong>子类是父类的继承，则父类就是子类的泛化。</strong>）</p><p>通过泛化对应的继承机制使<strong>子类共享父类的属性和操作</strong>，小了模型的规模，同时也防止了模型的更新所导致的定义不一致的意外。</p><p><strong>泛化关系的特征</strong>：</p><ol><li><strong>传递性</strong>：一个类子类的子类同样继承了这个类的特性。在父方向上经过了一个或几个泛化的元素被称为祖先，在子方向上则被称为后代。</li><li><strong>反对称性</strong>：<strong>泛化关系不能成环</strong>，即一个类不可能是自己的祖先和自己的后代。</li></ol><p><strong>泛化关系的两种情况</strong></p><ol><li>单继承：每个类之多能拥有一个父类。编程语言：C#、Java等</li><li><strong>多重继承</strong>：子类可以有多个父类并继承了所有父类的结构、行为和约束。编程语言：C++等</li></ol><p><img src="/2022/06/12/uml/jicheng.png"></p><p><img src="/2022/06/12/uml/blog\myblog\source_posts\uml\jicheng2.png"></p><h3 id="3-4-3-类图中的关系——依赖关系"><a href="#3-4-3-类图中的关系——依赖关系" class="headerlink" title="3.4.3.类图中的关系——依赖关系"></a>3.4.3.类图中的关系——依赖关系</h3><p>依赖关系表示的是<strong>两个元素之间语义上的连接关系</strong>。对于两个元素X和Y，<strong>如果元素X的变化会引起对另一个元素Y的变化</strong>，则称元素Y依赖于X。其中，X被称为提供者，Y被称为客户。</p><p><strong>现实例子</strong>：</p><p>比如说你要去拧螺丝，你是不是要借助(也就是<strong>依赖)螺丝刀</strong>(Screwdriver)来帮助你完成拧螺丝(screw)的工作。</p><p>对于类图而言，主要有以下<strong>需要使用依赖的情况</strong>：</p><ol><li>客户类向提供者类发送消息。</li><li>提供者类是客户类的属性类型。</li><li>提供者类是客户类操作的参数类型。</li></ol><p><img src="/2022/06/12/uml/yilai3.png"></p><h3 id="3-4-4-类图中的关系——实现关系"><a href="#3-4-4-类图中的关系——实现关系" class="headerlink" title="3.4.4.类图中的关系——实现关系"></a>3.4.4.类图中的关系——实现关系</h3><p>实现关系用来表示规格说明与实现之间的关系。在类图中，实现关系主要用于<strong>接口与实现该接口的类之间</strong>。</p><p><strong>一个类可以实现多个接口，一个接口也可以被多个类实现</strong>。</p><p>实现关系的两种表示法：</p><ol><li>当接口元素<strong>以带构造型的类的方式表示时</strong>，<strong>用虚线三角形箭头表示</strong>。</li><li>当接口元素以小圆圈方式表示时，用实线表示。</li></ol><p><img src="/2022/06/12/uml/shixan.png"></p><p><img src="/2022/06/12/uml/blog\myblog\source_posts\uml\shixian2.png"></p><p> <strong>3.5.综合例子</strong></p><p><img src="/2022/06/12/uml/total.png"></p><p>参考资料</p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu</title>
      <link href="/2022/05/22/ubuntu/"/>
      <url>/2022/05/22/ubuntu/</url>
      
        <content type="html"><![CDATA[<p>ubuntu</p><p>sudo apt install gedit</p><p>sudo apt update</p><p>sudo apt upgrade</p><p>sudo apt-get remove softname1</p><p>1、sudo apt-get remove &amp;&amp; sudo apt-get autoremove<br> 2、dpkg –list //列出已安装的软件<br> 3、sudo apt-get remove virtualbox &amp;&amp; sudo apt-get autoremove</p><p>sudo apt-get purge命令，与上面的命令不同的是，卸载已安装的软件并删除卸载软件的配置文件。</p><p><strong>wget <a href="http://ftp.gnu.org/gnu/gdb/gdb-7.10.1.tar.gz">http://ftp.gnu.org/gnu/gdb/gdb-7.10.1.tar.gz</a></strong></p><p>sudo add-apt-repository ppa:jonathonf/gcc-7.1<br>sudo apt-get update<br>sudo apt-get install gcc-7 g++-7<br>sudo update-alternatives –install /usr/bin/gcc gcc /usr/bin/gcc-7 60 –slave /usr/bin/g++ g++ /usr/bin/g++-7</p><p>sudo add-apt-repository ppa:ubuntu-toolchain-r/ppa<br>sudo apt update<br>sudo apt install gcc-10 g++-10<br>sudo update-alternatives –install /usr/bin/gcc gcc /usr/bin/gcc-10 60 –slave /usr/bin/g++ g++ /usr/bin/g++-10</p><p>sudo apt-get install gdb</p><pre class="line-numbers language-none"><code class="language-none">apt-cache search 软件包名 # 查找软件包apt-cache show 软件包名 # 显示软件包的详细信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装protobuf</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install autoconf automake libtool curl make g++ unzipgit clone https://github.com/google/protobuf.gitcd protobufgit submodule update --init --recursive  # 可能会失败，最好网络代理./autogen.sh./configuremake -j8make checksudo make installsudo ldconfig # refresh shared library cache.protoc --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装CMake</p><pre class="line-numbers language-none"><code class="language-none">#前提必须安装OpenSSLgit clone https://github.com/openssl/openssl.gitcd openssl./config        # --prefix=/usr/local --openssldir=/usr/local/opensslmake -j8sudo make install# 安装cmakegit clone https://github.com/Kitware/CMake.gitcd CMake./bootstrapmake -j8sudo make installcmake --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Windows-下映射-WSL-系统文件为磁盘"><a href="#Windows-下映射-WSL-系统文件为磁盘" class="headerlink" title="Windows 下映射 WSL 系统文件为磁盘"></a>Windows 下映射 WSL 系统文件为磁盘</h3><pre class="line-numbers language-none"><code class="language-none">//方法一，映射为本地磁盘subst Z: C:\Users\moomq\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu22.04LTS_79rhkp1fndgsc\LocalState\rootfs//方法二，映射为网络驱动器\\wsl$\Ubuntu-20.04<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/21/grpc/"/>
      <url>/2022/05/21/grpc/</url>
      
        <content type="html"><![CDATA[<p>RPC</p><p><strong>1、</strong><a href="https://so.csdn.net/so/search?q=RPC&amp;spm=1001.2101.3001.7020">RPC</a><strong>介绍</strong></p><p><strong>RPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。</strong>RPC 是一种技术思想而非一种规范或协议</p><ul><li>gRPC：是 Google 公布的开源软件，基于***的 HTTP 2.0 协议，并支持常见的众多编程语言。RPC 框架是基于 HTTP 协议实现的，底层使用到了 Netty 框架的支持。</li></ul><p><strong>2、完整的 RPC 框架</strong></p><p>在一个典型 RPC 的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中“RPC 协议”就指明了程序如何进行网络传输和序列化。</p><p><img src="/2022/05/21/grpc/1.jpg" alt="RPC框架"></p><p><strong>3、RPC 核心功能</strong> </p><p>RPC 的核心功能是指实现一个 RPC 最重要的功能模块，就是上图中的”RPC 协议”部分：</p><p>一个 RPC 的核心功能主要有 5 个部分组成，分别是：客户端、客户端 Stub、网络传输模块、服务端 Stub、服务端等。 </p><p><strong>下面分别介绍核心 RPC 框架的重要组成：</strong></p><ul><li>客户端(Client)：服务调用方。</li><li>客户端存根(Client Stub)：存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端。</li><li>服务端存根(Server Stub)：接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。</li><li>服务端(Server)：服务的真正提供者。</li><li>Network Service：底层传输，可以是 TCP 或 HTTP。</li></ul><p><strong>一次 RPC 调用流程如下：</strong></p><ul><li>服务消费者(Client 客户端)通过本地调用的方式调用服务。</li><li>客户端存根(Client Stub)接收到调用请求后负责将方法、入参等信息序列化(组装)成能够进行网络传输的消息体。</li><li>客户端存根(Client Stub)找到远程的服务地址，并且将消息通过网络发送给服务端。</li><li>服务端存根(Server Stub)收到消息后进行解码(反序列化操作)。</li><li>服务端存根(Server Stub)根据解码结果调用本地的服务进行相关处理</li><li>服务端(Server)本地服务业务处理。</li><li>处理结果返回给服务端存根(Server Stub)。</li><li>服务端存根(Server Stub)序列化结果。</li><li>服务端存根(Server Stub)将结果通过网络发送至消费方。</li><li>客户端存根(Client Stub)接收到消息，并进行解码(反序列化)。</li><li>服务消费方得到最终结果。</li></ul><p><strong>4、RPC 核心之功能实现</strong></p><p>RPC 的核心功能主要由 5 个模块组成，如果想要自己实现一个 RPC，最简单的方式要实现三个技术点，分别是：</p><ul><li>服务寻址</li><li>数据流的序列化和反序列化</li><li>网络传输</li></ul><h3 id="服务寻址"><a href="#服务寻址" class="headerlink" title="服务寻址"></a><strong>服务寻址</strong></h3><p>服务寻址可以使用 Call ID 映射。在本地调用中，函数体是直接通过函数指针来指定的，但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。</p><p>所以在 RPC 中，所有的函数都必须有自己的一个 ID。这个 ID 在所有进程中都是唯一确定的。</p><p>客户端在做远程过程调用时，必须附上这个 ID。然后我们还需要在客户端和服务端分别维护一个函数和Call ID的对应表。</p><p>当客户端需要进行远程调用时，它就查一下这个表，找出相应的 Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</p><p>实现方式：服务注册中心。</p><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a><strong>序列化和反序列化</strong></h3><p>客户端怎么把参数值传给远程的函数呢?在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。</p><p>但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。</p><p>这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。</p><p>只有二进制数据才能在网络中传输，序列化和反序列化的定义是：</p><ul><li>将对象转换成二进制流的过程叫做序列化</li><li>将二进制流转换成对象的过程叫做反序列化</li></ul><p>这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</p><h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a><strong>网络传输</strong></h3><p>网络传输：远程调用往往用在网络上，客户端和服务端是通过网络连接的。</p><p>所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把 Call ID 和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。</p><p>只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。</p><p>尽管大部分 RPC <a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&amp;spm=1001.2101.3001.7020">框架</a>都使用 TCP 协议，但其实 UDP 也可以，而 gRPC 干脆就用了 HTTP2。</p><p>TCP 的连接是最常见的，简要分析基于 TCP 的连接：通常 TCP 连接可以是按需连接(需要调用的时候就先建立连接，调用结束后就立马断掉)，也可以是长连接(客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效)，多个远程过程调用共享同一个连接。</p><p><strong>所以，要实现一个 RPC 框架，只需要把以下三点实现了就基本完成了：</strong></p><ul><li>Call ID 映射：可以直接使用函数字符串，也可以使用整数 ID。映射表一般就是一个哈希表。</li><li>序列化反序列化：可以自己写，也可以使用 Protobuf 或者 FlatBuffers 之类的。</li><li>网络传输库：可以自己写 Socket，或者用 Asio，ZeroMQ，Netty 之类。</li></ul><h2 id="5、RPC-核心之网络传输协议"><a href="#5、RPC-核心之网络传输协议" class="headerlink" title="5、RPC 核心之网络传输协议"></a><strong>5、RPC 核心之网络传输协议</strong></h2><h3 id="基于-TCP-协议的-RPC-调用"><a href="#基于-TCP-协议的-RPC-调用" class="headerlink" title="基于 TCP 协议的 RPC 调用"></a><strong>基于 TCP 协议的 RPC 调用</strong></h3><p>由服务的调用方与服务的提供方建立 Socket 连接，并由服务的调用方通过 Socket 将需要调用的接口名称、方法名称和参数序列化后传递给服务的提供方，服务的提供方反序列化后再利用反射调用相关的方法。</p><p>***将结果返回给服务的调用方，整个基于 TCP 协议的 RPC 调用大致如此。</p><p>但是在实例应用中则会进行一系列的封装，如 RMI 便是在 TCP 协议上传递可序列化的 Java 对象。</p><h3 id="基于-HTTP-协议的-RPC-调用"><a href="#基于-HTTP-协议的-RPC-调用" class="headerlink" title="基于 HTTP 协议的 RPC 调用"></a><strong>基于 HTTP 协议的 RPC 调用</strong></h3><p>该方法更像是访问网页一样，只是它的返回结果更加单一简单。</p><p>其大致流程为：由服务的调用者向服务的提供者发送请求，这种请求的方式可能是 GET、POST、PUT、DELETE 等中的一种，服务的提供者可能会根据不同的请求方式做出不同的处理，或者某个方法只允许某种请求方式。</p><p>而调用的具体方法则是根据 URL 进行方法调用，而方法所需要的参数可能是对服务调用方传输过去的 XML 数据或者 JSON 数据解析后的结果，***返回 JOSN 或者 XML 的数据结果。</p><p>由于目前有很多开源的 Web 服务器，如 Tomcat，所以其实现起来更加容易，就像做 Web 项目一样。</p><h3 id="两种方式对比"><a href="#两种方式对比" class="headerlink" title="两种方式对比"></a><strong>两种方式对比</strong></h3><p>基于 TCP 的协议实现的 RPC 调用，由于 TCP 协议处于协议栈的下层，能够更加灵活地对协议字段进行定制，减少网络开销，提高性能，实现更大的吞吐量和并发数。</p><p>但是需要更多关注底层复杂的细节，实现的代价更高。同时对不同平台，如安卓，iOS 等，需要重新开发出不同的工具包来进行请求发送和相应解析，工作量大，难以快速响应和满足用户需求。</p><p>基于 HTTP 协议实现的 RPC 则可以使用 JSON 和 XML 格式的请求或响应数据。</p><p>而 JSON 和 XML 作为通用的格式标准(使用 HTTP 协议也需要序列化和反序列化，不过这不是该协议下关心的内容，成熟的 Web 程序已经做好了序列化内容)，开源的解析工具已经相当成熟，在其上进行二次开发会非常便捷和简单。</p><p>但是由于 HTTP 协议是上层协议，发送包含同等内容的信息，使用 HTTP 协议传输所占用的字节数会比使用 TCP 协议传输所占用的字节数更高。</p><p>因此在同等网络下，通过 HTTP 协议传输相同内容，效率会比基于 TCP 协议的数据效率要低，信息传输所占用的时间也会更长，当然压缩数据，能够缩小这一差距。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MFC</title>
      <link href="/2022/05/14/mfc/"/>
      <url>/2022/05/14/mfc/</url>
      
        <content type="html"><![CDATA[<h1 id="MFC"><a href="#MFC" class="headerlink" title="MFC"></a>MFC</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>​        MFC库是开发Windows应用程序的C++接口。MFC提供了面向对象的框架，采用面向对象技术，将大部分的Windows API 封装到C++类中，以类成员函数的形式提供给程序开发人员调用。</p><p><img src="/2022/05/14/mfc/1.png" alt="Part1"></p><p><img src="/2022/05/14/mfc/2.png" alt="Part2"></p><p><img src="/2022/05/14/mfc/3.png" alt="Part3"></p><p>二、要点</p><p>1、Cwnd类</p><p><em>Cwnd</em>类是<em>MFC</em>中一个重要的类，它封装了与窗口有关的操作。</p><p>2、WinMain</p><p>​        MFC程序的WinMain函数，在由Appwized生成的源程序中找不到这个函数，但是程序是在编译时,生成于APPMODUL.cpp中，由链接器将它链接到程序中。WinMain函数实际上是调用AfxWinMain函数来实现的。在AfxWinMain函数中，调用了以下三个函数：</p><pre class="line-numbers language-none"><code class="language-none">pApp-&gt;InitApplication() //完成内存管理方面的工作pApp-&gt;InitInstance()//此函数是虚函数，调用派生类的InitInstance函数，完成窗口类的创建，注册，更新等操作。窗口类的注册是由AfxEndDeferRegisterClass完成。如果该窗口类已经注册，则直接返回一个真值;如果尚未注册，就调用RegisterClass函数注册该窗口类。pApp-&gt;Run()//完成消息循环。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3、theApp全局对象</p><p>​        在程序入口函数加载前，系统已经为全局变量或全局对象分配了内存空间并为它们赋与了初值。对于全局对象，要先调用构造函数对其进行初始化。调用<em>theApp</em>时会选调用设用其父类<em>CwinApp</em>的构造函数。</p><p>4、运行过程</p><p>​        首先利用全局应用程序对象theApp启动应用程序。正是产生了这个全局对象，基类CWinApp中的this指针才能指向这个对象。如果没有这个全局对象，程序在编译时不会出错，但是在运行时就会出错。调用全局应用程序对象的构造函数，从而就会先调用其基类CWinApp的构造函数后者完成应用程序的一些初始化工作,并将用应程序对象的指针保存起来。进入WinMain函数。在AfxWinMain函数中可以获取子类(对Test程序来说，就是CtestApp类)的指针，利用此指针调用虚函数：InitInstance，根据多态性原理，实际上调用的是子类(CTestApp)的InitInstance函数。后者完成应用程序的一些初始化工作，包括窗口类的注册、创建、窗口的显示和更新。期间会多次调用CreateEx函数，因为一个单文档MFC应用程序有多个窗口，包括框架窗口、工具条、状态条等。进入消息循环。虽然也设置了默认的窗口过程函数，但是，MFC应用程序实际上是采用消息映射机制来处理各种消息的。当收到WM_QUIT消息时，退出消息循环，程序结束。</p><p>​        在MFC程序运行时，程序执行的顺序为：theApp全局对象定义处-&gt;CXXXApp构造函数-&gt;WinMain函数-&gt;设计窗口-&gt;注册窗口-&gt;创建窗口-&gt;显示窗口-&gt;消息循环。</p><p>简单总结一下MFC程序的运行过程</p><ol><li>首先利用全局应用程序对象theApp启动应用程序；</li><li>调用全局应用程序对象的构造函数，从而就会调用其基类CWinApp的构造函数，以完成应用程序的一些初始化工作；</li><li>进入WinMain函数；</li><li>进入消息循环。</li></ol><p>5、窗口类、窗口类对象与窗口的生命周期</p><p>如果我们关闭了一个窗口，这个窗口就销毁了，那么该窗口对应的C++窗口类对象销毁了吗？</p><p>(1)当一个窗口销毁时，它会调用CWnd::DestroyWindow函数，该函数销毁窗口后，将CWnd::m_hWnd设为NULL；</p><p>(2)窗口的生命周期和C++窗口类对象theApp的声明周期不是一致的。当一个窗口销毁时，与C++窗口类对象没有关系，它们之间的纽带仅仅在于这个C++窗口类内部的成员变量m_hWnd，该变量保存了与这个C++窗口类对象相关的哪个窗口的句柄。当程序执行到右大括号结束时，窗口对象的生命周期结束。</p><p>(3)但是，当C++窗口类对象销毁时，与之相关的窗口也将销毁，因为它们之间的纽带m_hWnd已经断了</p><p>DDX和DDV</p><p>​        DoDataExchange<strong>由框架调用</strong>，作用是<strong>交互并且验证对话框数据</strong>，主要由(DDX) 和 (DDV)宏实现。 永远不要直接调用这个函数，而是通过UpdateData(TRUE/FALSE)实现控件与变量之间值的传递。 </p><p>当然你也可以不使用DoDataExchange而完成控件与变量之间值的传递，如：通过GetWindowText和SetWindowText等等函数完成String变量与Edit控件之间的数据交互。</p><p>通过使用ClassWizard向对话类添加成员变量，你可以利用ClassWizard所提供的高效特征，为对话数据交换和对话数据验证自动生成源代码，也就是人们所熟知的DDX/DDV。</p><p>数据交换和验证仅仅应用于为之选定了Value类别的成员变量。也就是CString，BOOL，数字，COleDateTime或COLeCurrency。</p><p><strong>对话数据交换</strong>（DDX）负责数据在控件中的进出。当对话首次出现的时候，每个控件窗口自动用相应的成员变量的值进行初始化。当用户通过单击OK按钮，或通过按Enter键关闭对话的时候，该控件无论是包含哪一个值或文本，都将被复制回该变量。</p><p><strong>对话数据验证</strong>(DDV)可以确保值落在规定的限制之内。交换和验证机制都是由MFC<a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&amp;spm=1001.2101.3001.7020">框架</a>提供的。每个函数都有一个前缀DDX_或DDV_，来把它作为数据交换或数据验证函数来标识。</p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/03/qt-qwidget/"/>
      <url>/2022/05/03/qt-qwidget/</url>
      
        <content type="html"><![CDATA[<p>Qt Qwidget</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bash guide</title>
      <link href="/2022/05/02/bash-guide/"/>
      <url>/2022/05/02/bash-guide/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p align="center">  <img src="https://cloud.githubusercontent.com/assets/2059754/24601246/753a7f36-1858-11e7-9d6b-7a0e64fb27f7.png" alt="bash logo"></p><h1 id="1-Basic-Operations"><a href="#1-Basic-Operations" class="headerlink" title="1. Basic Operations"></a>1. Basic Operations</h1><h3 id="a-export"><a href="#a-export" class="headerlink" title="a. export"></a>a. <code>export</code></h3><p>Displays all environment variables. If you want to get details of a specific variable, use <code>echo $VARIABLE_NAME</code>.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">export</span><span class="token assign-left variable">AWS_HOME</span><span class="token operator">=</span>/Users/adnanadnan/.aws<span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span>en_US.UTF-8<span class="token assign-left variable">LC_CTYPE</span><span class="token operator">=</span>en_US.UTF-8<span class="token assign-left variable">LESS</span><span class="token operator">=</span>-R$ <span class="token builtin class-name">echo</span> <span class="token variable">$AWS_HOME</span>/Users/adnanadnan/.aws<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="b-whatis"><a href="#b-whatis" class="headerlink" title="b. whatis"></a>b. <code>whatis</code></h3><p>whatis shows description for user commands, system calls, library functions, and others in manual pages</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">whatis something<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ whatis <span class="token function">bash</span><span class="token function">bash</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>             - GNU Bourne-Again SHell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="c-whereis"><a href="#c-whereis" class="headerlink" title="c. whereis"></a>c. <code>whereis</code></h3><p>whereis searches for executables, source files, and manual pages using a database built by system automatically.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">whereis</span> name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">whereis</span> php/usr/bin/php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="d-which"><a href="#d-which" class="headerlink" title="d. which"></a>d. <code>which</code></h3><p>which searches for executables in the directories specified by the environment variable PATH. This command will print the full path of the executable(s).</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">which</span> program_name <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">which</span> php/c/xampp/php/php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="e-clear"><a href="#e-clear" class="headerlink" title="e. clear"></a>e. clear</h3><p>Clears content on window.</p><h2 id="1-1-File-Operations"><a href="#1-1-File-Operations" class="headerlink" title="1.1. File Operations"></a>1.1. File Operations</h2><table>   <tbody><tr>      <td><a href="#a-cat">cat</a></td>      <td><a href="#b-chmod">chmod</a></td>      <td><a href="#c-chown">chown</a></td>      <td><a href="#d-cp">cp</a></td>      <td><a href="#e-diff">diff</a></td>      <td><a href="#f-file">file</a></td>      <td><a href="#g-find">find</a></td>      <td><a href="#h-gunzip">gunzip</a></td>      <td><a href="#i-gzcat">gzcat</a></td>      <td><a href="#j-gzip">gzip</a></td>      <td><a href="#k-head">head</a></td>   </tr>   <tr>      <td><a href="#l-lpq">lpq</a></td>      <td><a href="#m-lpr">lpr</a></td>      <td><a href="#n-lprm">lprm</a></td>      <td><a href="#o-ls">ls</a></td>      <td><a href="#p-more">more</a></td>      <td><a href="#q-mv">mv</a></td>      <td><a href="#r-rm">rm</a></td>      <td><a href="#s-tail">tail</a></td>      <td><a href="#t-touch">touch</a></td>   </tr></tbody></table><h3 id="a-cat"><a href="#a-cat" class="headerlink" title="a. cat"></a>a. <code>cat</code></h3><p>It can be used for the following purposes under UNIX or Linux.  </p><ul><li>Display text files on screen</li><li>Copy text files  </li><li>Combine text files  </li><li>Create new text files  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> filename<span class="token function">cat</span> file1 file2 <span class="token function">cat</span> file1 file2 <span class="token operator">&gt;</span> newcombinedfile<span class="token function">cat</span> <span class="token operator">&lt;</span> file1 <span class="token operator">&gt;</span> file2 <span class="token comment">#copy file1 to file2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="b-chmod"><a href="#b-chmod" class="headerlink" title="b. chmod"></a>b. <code>chmod</code></h3><p>The chmod command stands for “change mode” and allows you to change the read, write, and execute permissions on your files and folders. For more information on this command check this <a href="https://ss64.com/bash/chmod.html">link</a>.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> -options filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="c-chown"><a href="#c-chown" class="headerlink" title="c. chown"></a>c. <code>chown</code></h3><p>The chown command stands for “change owner”, and allows you to change the owner of a given file or folder, which can be a user and a group. Basic usage is simple forward first comes the user (owner), and then the group, delimited by a colon.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chown</span> -options user:group filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="d-cp"><a href="#d-cp" class="headerlink" title="d. cp"></a>d. <code>cp</code></h3><p>Copies a file from one location to other.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> filename1 filename2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Where <code>filename1</code> is the source path to the file and <code>filename2</code> is the destination path to the file.</p><h3 id="e-diff"><a href="#e-diff" class="headerlink" title="e. diff"></a>e. <code>diff</code></h3><p>Compares files, and lists their differences.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">diff</span> filename1 filename2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="f-file"><a href="#f-file" class="headerlink" title="f. file"></a>f. <code>file</code></h3><p>Determine file type.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">file</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">file</span> index.html index.html: HTML document, ASCII text<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="g-find"><a href="#g-find" class="headerlink" title="g. find"></a>g. <code>find</code></h3><p>Find files in directory</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> directory options pattern<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">find</span> <span class="token builtin class-name">.</span> -name README.md$ <span class="token function">find</span> /home/user1 -name <span class="token string">'*.png'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="h-gunzip"><a href="#h-gunzip" class="headerlink" title="h. gunzip"></a>h. <code>gunzip</code></h3><p>Un-compresses files compressed by gzip.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gunzip filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="i-gzcat"><a href="#i-gzcat" class="headerlink" title="i. gzcat"></a>i. <code>gzcat</code></h3><p>Lets you look at gzipped file without actually having to gunzip it.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gzcat filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="j-gzip"><a href="#j-gzip" class="headerlink" title="j. gzip"></a>j. <code>gzip</code></h3><p>Compresses files.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">gzip</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="k-head"><a href="#k-head" class="headerlink" title="k. head"></a>k. <code>head</code></h3><p>Outputs the first 10 lines of file  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">head</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="l-lpq"><a href="#l-lpq" class="headerlink" title="l. lpq"></a>l. <code>lpq</code></h3><p>Check out the printer queue.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lpq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ lpqRank    Owner   Job     File<span class="token punctuation">(</span>s<span class="token punctuation">)</span>                         Total Sizeactive  adnanad <span class="token number">59</span>      demo                            <span class="token number">399360</span> bytes1st     adnanad <span class="token number">60</span>      <span class="token punctuation">(</span>stdin<span class="token punctuation">)</span>                         <span class="token number">0</span> bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="m-lpr"><a href="#m-lpr" class="headerlink" title="m. lpr"></a>m. <code>lpr</code></h3><p>Print the file.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">lpr</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="n-lprm"><a href="#n-lprm" class="headerlink" title="n. lprm"></a>n. <code>lprm</code></h3><p>Remove something from the printer queue.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">lprm</span> jobnumber<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="o-ls"><a href="#o-ls" class="headerlink" title="o. ls"></a>o. <code>ls</code></h3><p>Lists your files. <code>ls</code> has many options: <code>-l</code> lists files in ‘long format’, which contains the exact size of the file, who owns the file, who has the right to look at it, and when it was last modified. <code>-a</code> lists all files, including hidden files. For more information on this command check this <a href="https://ss64.com/bash/ls.html">link</a>.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> option<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Example:</p><pre>$ ls -larwxr-xr-x   33 adnan  staff    1122 Mar 27 18:44 .drwxrwxrwx  60 adnan  staff    2040 Mar 21 15:06 ..-rw-r--r--@  1 adnan  staff   14340 Mar 23 15:05 .DS_Store-rw-r--r--   1 adnan  staff     157 Mar 25 18:08 .bumpversion.cfg-rw-r--r--   1 adnan  staff    6515 Mar 25 18:08 .config.ini-rw-r--r--   1 adnan  staff    5805 Mar 27 18:44 .config.override.inidrwxr-xr-x  17 adnan  staff     578 Mar 27 23:36 .git-rwxr-xr-x   1 adnan  staff    2702 Mar 25 18:08 .gitignore</pre><h3 id="p-more"><a href="#p-more" class="headerlink" title="p. more"></a>p. <code>more</code></h3><p>Shows the first part of a file (move with space and type q to quit).  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">more</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="q-mv"><a href="#q-mv" class="headerlink" title="q. mv"></a>q. <code>mv</code></h3><p>Moves a file from one location to other.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> filename1 filename2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Where <code>filename1</code> is the source path to the file and <code>filename2</code> is the destination path to the file.</p><p>Also it can be used for rename a file.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> old_name new_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="r-rm"><a href="#r-rm" class="headerlink" title="r. rm"></a>r. <code>rm</code></h3><p>Removes a file. Using this command on a directory gives you an error.<br><code>rm: directory: is a directory</code><br>To remove a directory you have to pass <code>-r</code> which will remove the content of the directory recursively. Optionally you can use <code>-f</code> flag to force the deletion i.e. without any confirmations etc.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="s-tail"><a href="#s-tail" class="headerlink" title="s. tail"></a>s. <code>tail</code></h3><p>Outputs the last 10 lines of file. Use <code>-f</code> to output appended data as the file grows.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tail</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="t-touch"><a href="#t-touch" class="headerlink" title="t. touch"></a>t. <code>touch</code></h3><p>Updates access and modification time stamps of your file. If it doesn’t exists, it’ll be created.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">touch</span> trick.md<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-2-Text-Operations"><a href="#1-2-Text-Operations" class="headerlink" title="1.2. Text Operations"></a>1.2. Text Operations</h2><table>    <tbody><tr>      <td><a href="#a-awk">awk</a></td>      <td><a href="#b-cut">cut</a></td>      <td><a href="#c-echo">echo</a></td>      <td><a href="#d-egrep">egrep</a></td>      <td><a href="#e-fgrep">fgrep</a></td>      <td><a href="#f-fmt">fmt</a></td>      <td><a href="#g-grep">grep</a></td>      <td><a href="#h-nl">nl</a></td>      <td><a href="#i-sed">sed</a></td>      <td><a href="#j-sort">sort</a></td>   </tr>   <tr>      <td><a href="#k-tr">tr</a></td>      <td><a href="#l-uniq">uniq</a></td>      <td><a href="#m-wc">wc</a></td>   </tr></tbody></table><h3 id="a-awk"><a href="#a-awk" class="headerlink" title="a. awk"></a>a. <code>awk</code></h3><p>awk is the most useful command for handling text files. It operates on an entire file line by line. By default it uses whitespace to separate the fields. The most common syntax for awk command is</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> <span class="token string">'/search_pattern/ { action_to_take_if_pattern_matches; }'</span> file_to_parse<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Lets take following file <code>/etc/passwd</code>. Here’s the sample data that this file contains:</p><pre class="line-numbers language-none"><code class="language-none">root:x:0:0:root:/root:/usr/bin/zshdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/sync<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>So now lets get only username from this file. Where <code>-F</code> specifies that on which base we are going to separate the fields. In our case it’s <code>:</code>. <code>{ print $1 }</code> means print out the first matching field.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> -F<span class="token string">':'</span> <span class="token string">'{ print $1 }'</span> /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>After running the above command you will get following output.</p><pre class="line-numbers language-none"><code class="language-none">rootdaemonbinsyssync<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>For more detail on how to use <code>awk</code>, check following <a href="https://www.cyberciti.biz/faq/bash-scripting-using-awk">link</a>.</p><h3 id="b-cut"><a href="#b-cut" class="headerlink" title="b. cut"></a>b. <code>cut</code></h3><p>Remove sections from each line of files</p><p><em>example.txt</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">red riding hood went to the park to play<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>show me columns 2 , 7 , and 9 with a space as a separator</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cut</span> -d <span class="token string">" "</span> -f2,7,9 example.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">riding park play<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="c-echo"><a href="#c-echo" class="headerlink" title="c. echo"></a>c. <code>echo</code></h3><p>Display a line of text</p><p><em>display “Hello World”</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> Hello World<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Hello World<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>display “Hello World” with newlines between words</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> -ne <span class="token string">"Hello<span class="token entity" title="\n">\n</span>World<span class="token entity" title="\n">\n</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">HelloWorld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="d-egrep"><a href="#d-egrep" class="headerlink" title="d. egrep"></a>d. <code>egrep</code></h3><p>Print lines matching a pattern - Extended Expression (alias for: ‘grep -E’)</p><p><em>example.txt</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Lorem ipsumdolor sit amet, consetetursadipscing elitr,<span class="token function">sed</span> diam nonumyeirmod temporinvidunt ut laboreet dolore magnaaliquyam erat, <span class="token function">sed</span>diam voluptua. Atvero eos etaccusam et justoduo dolores et earebum. Stet clitakasd gubergren,no sea takimatasanctus est Loremipsum dolor sitamet.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>display lines that have either “Lorem” or “dolor” in them.</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">egrep</span> <span class="token string">'(Lorem|dolor)'</span> example.txtor<span class="token function">grep</span> -E <span class="token string">'(Lorem|dolor)'</span> example.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Lorem ipsumdolor sit amet,et dolore magnaduo dolores et easanctus est Loremipsum dolor sit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="e-fgrep"><a href="#e-fgrep" class="headerlink" title="e. fgrep"></a>e. <code>fgrep</code></h3><p>Print lines matching a pattern - FIXED pattern matching  (alias for: ‘grep -F’)</p><p><em>example.txt</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Lorem ipsumdolor sit amet,consetetursadipscing elitr,<span class="token function">sed</span> diam nonumyeirmod temporfoo <span class="token punctuation">(</span>Lorem<span class="token operator">|</span>dolor<span class="token punctuation">)</span> invidunt ut laboreet dolore magnaaliquyam erat, <span class="token function">sed</span>diam voluptua. Atvero eos etaccusam et justoduo dolores et earebum. Stet clitakasd gubergren,no sea takimatasanctus est Loremipsum dolor sitamet.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>Find the exact string ‘(Lorem|dolor)’ in example.txt</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">fgrep</span> <span class="token string">'(Lorem|dolor)'</span> example.txtor<span class="token function">grep</span> -F <span class="token string">'(Lorem|dolor)'</span> example.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">foo <span class="token punctuation">(</span>Lorem<span class="token operator">|</span>dolor<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="f-fmt"><a href="#f-fmt" class="headerlink" title="f. fmt"></a>f. <code>fmt</code></h3><p>Simple optimal text formatter</p><p><em>example: example.txt (1 line)</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Lorem ipsum dolor sit amet, consetetur sadipscing elitr, <span class="token function">sed</span> diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, <span class="token function">sed</span> diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>output the lines of example.txt to 20 character width</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> example.txt <span class="token operator">|</span> <span class="token function">fmt</span> -w <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Lorem ipsumdolor sit amet,consetetursadipscing elitr,<span class="token function">sed</span> diam nonumyeirmod temporinvidunt ut laboreet dolore magnaaliquyam erat, <span class="token function">sed</span>diam voluptua. Atvero eos etaccusam et justoduo dolores et earebum. Stet clitakasd gubergren,no sea takimatasanctus est Loremipsum dolor sitamet.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="g-grep"><a href="#g-grep" class="headerlink" title="g. grep"></a>g. <code>grep</code></h3><p>Looks for text inside files. You can use grep to search for lines of text that match one or many regular expressions, and outputs only the matching lines.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> pattern filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">grep</span> admin /etc/passwd_kadmin_admin:*:218:-2:Kerberos Admin Service:/var/empty:/usr/bin/false_kadmin_changepw:*:219:-2:Kerberos Change Password Service:/var/empty:/usr/bin/false_krb_kadmin:*:231:-2:Open Directory Kerberos Admin Service:/var/empty:/usr/bin/false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>You can also force grep to ignore word case by using <code>-i</code> option. <code>-r</code> can be used to search all files under the specified directory, for example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">grep</span> -r admin /etc/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>And <code>-w</code> to search for words only. For more detail on <code>grep</code>, check following <a href="https://www.cyberciti.biz/faq/grep-in-bash">link</a>.</p><h3 id="h-nl"><a href="#h-nl" class="headerlink" title="h. nl"></a>h. <code>nl</code></h3><p>Number lines of files</p><p><em>example.txt</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Lorem ipsumdolor sit amet,consetetursadipscing elitr,<span class="token function">sed</span> diam nonumyeirmod temporinvidunt ut laboreet dolore magnaaliquyam erat, <span class="token function">sed</span>diam voluptua. Atvero eos etaccusam et justoduo dolores et earebum. Stet clitakasd gubergren,no sea takimatasanctus est Loremipsum dolor sitamet.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>show example.txt with line numbers</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nl</span> -s<span class="token string">". "</span> example.txt <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> <span class="token number">1</span>. Lorem ipsum <span class="token number">2</span>. dolor sit amet, <span class="token number">3</span>. consetetur <span class="token number">4</span>. sadipscing elitr, <span class="token number">5</span>. <span class="token function">sed</span> diam nonumy <span class="token number">6</span>. eirmod tempor <span class="token number">7</span>. invidunt ut labore <span class="token number">8</span>. et dolore magna <span class="token number">9</span>. aliquyam erat, <span class="token function">sed</span><span class="token number">10</span>. diam voluptua. At<span class="token number">11</span>. vero eos et<span class="token number">12</span>. accusam et justo<span class="token number">13</span>. duo dolores et ea<span class="token number">14</span>. rebum. Stet clita<span class="token number">15</span>. kasd gubergren,<span class="token number">16</span>. no sea takimata<span class="token number">17</span>. sanctus est Lorem<span class="token number">18</span>. ipsum dolor sit<span class="token number">19</span>. amet.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="i-sed"><a href="#i-sed" class="headerlink" title="i. sed"></a>i. <code>sed</code></h3><p>Stream editor for filtering and transforming text</p><p><em>example.txt</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Hello This is a Test <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>replace all spaces with hyphens</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token string">'s/ /-/g'</span> example.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Hello-This-is-a-Test-1-2-3-4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>replace all digits with “d”</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token string">'s/[0-9]/d/g'</span> example.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Hello This is a Test d d d d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="j-sort"><a href="#j-sort" class="headerlink" title="j. sort"></a>j. <code>sort</code></h3><p>Sort lines of text files</p><p><em>example.txt</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">fbcgaed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>sort example.txt</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sort</span> example.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">abcdefg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>randomize a sorted example.txt</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sort</span> example.txt <span class="token operator">|</span> <span class="token function">sort</span> -R<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bfacdge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="k-tr"><a href="#k-tr" class="headerlink" title="k. tr"></a>k. <code>tr</code></h3><p>Translate or delete characters</p><p><em>example.txt</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Hello World Foo Bar Baz<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>take all lower case letters and make them upper case</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> example.txt <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">'a-z'</span> <span class="token string">'A-Z'</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">HELLO WORLD FOO BAR BAZ<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>take all spaces and make them into newlines</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> example.txt <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">' '</span> <span class="token string">'\n'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">HelloWorldFooBarBaz<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="l-uniq"><a href="#l-uniq" class="headerlink" title="l. uniq"></a>l. <code>uniq</code></h3><p>Report or omit repeated lines</p><p><em>example.txt</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aababcdc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>show only unique lines of example.txt (first you need to sort it, otherwise it won’t see the overlap)</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sort</span> example.txt <span class="token operator">|</span> <span class="token function">uniq</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">abcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><em>show the unique items for each line, and tell me how many instances it found</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sort</span> example.txt <span class="token operator">|</span> <span class="token function">uniq</span> -c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">3</span> a<span class="token number">2</span> b<span class="token number">2</span> c<span class="token number">1</span> d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="m-wc"><a href="#m-wc" class="headerlink" title="m. wc"></a>m. <code>wc</code></h3><p>Tells you how many lines, words and characters there are in a file.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wc</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">wc</span> demo.txt<span class="token number">7459</span>   <span class="token number">15915</span>  <span class="token number">398400</span> demo.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Where <code>7459</code> is lines, <code>15915</code> is words and <code>398400</code> is characters.</p><h2 id="1-3-Directory-Operations"><a href="#1-3-Directory-Operations" class="headerlink" title="1.3. Directory Operations"></a>1.3. Directory Operations</h2><table>   <tbody><tr>      <td><a href="#a-cd">cd</a></td>      <td><a href="#b-mkdir">mkdir</a></td>      <td><a href="#c-pwd">pwd</a></td>   </tr></tbody></table><h3 id="a-cd"><a href="#a-cd" class="headerlink" title="a. cd"></a>a. <code>cd</code></h3><p>Moves you from one directory to other. Running this  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>moves you to home directory. This command accepts an optional <code>dirname</code>, which moves you to that directory.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token function">dirname</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="b-mkdir"><a href="#b-mkdir" class="headerlink" title="b. mkdir"></a>b. <code>mkdir</code></h3><p>Makes a new directory.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token function">dirname</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>You can use this to create multiple directories at once within your current directory.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> 1stDirectory 2ndDirectory 3rdDirectory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>You can also use this to create parent directories at the same time. For instance, if you wanted a directory named ‘project1’ in another subdirectory at ‘/samples/bash/projects/‘, you could run:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> /samples/bash/projects/project1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>If any of these directories did no already exist, they would be created as well.</p><h3 id="c-pwd"><a href="#c-pwd" class="headerlink" title="c. pwd"></a>c. <code>pwd</code></h3><p>Tells you which directory you currently are in.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">pwd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-4-SSH-System-Info-amp-Network-Operations"><a href="#1-4-SSH-System-Info-amp-Network-Operations" class="headerlink" title="1.4. SSH, System Info &amp; Network Operations"></a>1.4. SSH, System Info &amp; Network Operations</h2><table>   <tbody><tr>      <td><a href="#a-bg">bg</a></td>      <td><a href="#b-cal">cal</a></td>      <td><a href="#c-date">date</a></td>      <td><a href="#d-df">df</a></td>      <td><a href="#e-dig">dig</a></td>      <td><a href="#f-du">du</a></td>      <td><a href="#g-fg">fg</a></td>      <td><a href="#h-finger">finger</a></td>         <td><a href="#i-jobs">jobs</a></td>      <td><a href="#j-last">last</a></td>   </tr>   <tr>      <td><a href="#k-man">man</a></td>      <td><a href="#l-passwd">passwd</a></td>      <td><a href="#m-ping">ping</a></td>      <td><a href="#n-ps">ps</a></td>      <td><a href="#o-quota">quota</a></td>      <td><a href="#p-scp">scp</a></td>      <td><a href="#q-ssh">ssh</a></td>      <td><a href="#r-top">top</a></td>      <td><a href="#s-uname">uname</a></td>      <td><a href="#t-uptime">uptime</a></td>   </tr>   <tr>      <td><a href="#u-w">w</a></td>      <td><a href="#v-wget">wget</a></td>      <td><a href="#w-whoami">whoami</a></td>      <td><a href="#x-whois">whois</a></td>   </tr></tbody></table><h3 id="a-bg"><a href="#a-bg" class="headerlink" title="a. bg"></a>a. <code>bg</code></h3><p>Lists stopped or background jobs; resume a stopped job in the background.</p><h3 id="b-cal"><a href="#b-cal" class="headerlink" title="b. cal"></a>b. <code>cal</code></h3><p>Shows the month’s calendar.</p><h3 id="c-date"><a href="#c-date" class="headerlink" title="c. date"></a>c. <code>date</code></h3><p>Shows the current date and time.</p><h3 id="d-df"><a href="#d-df" class="headerlink" title="d. df"></a>d. <code>df</code></h3><p>Shows disk usage.</p><h3 id="e-dig"><a href="#e-dig" class="headerlink" title="e. dig"></a>e. <code>dig</code></h3><p>Gets DNS information for domain.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">dig</span> domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="f-du"><a href="#f-du" class="headerlink" title="f. du"></a>f. <code>du</code></h3><p>Shows the disk usage of files or directories. For more information on this command check this <a href="http://www.linfo.org/du.html">link</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">du</span> <span class="token punctuation">[</span>option<span class="token punctuation">]</span> <span class="token punctuation">[</span>filename<span class="token operator">|</span>directory<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Options:</p><ul><li><code>-h</code> (human readable) Displays output it in kilobytes (K), megabytes (M) and gigabytes (G).</li><li><code>-s</code> (supress or summarize) Outputs total disk space of a directory and supresses reports for subdirectories. </li></ul><p>Example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">du</span> -sh pictures<span class="token number">1</span>.4M pictures<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="g-fg"><a href="#g-fg" class="headerlink" title="g. fg"></a>g. <code>fg</code></h3><p>Brings the most recent job in the foreground.</p><h3 id="h-finger"><a href="#h-finger" class="headerlink" title="h. finger"></a>h. <code>finger</code></h3><p>Displays information about user.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">finger username<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="i-jobs"><a href="#i-jobs" class="headerlink" title="i. jobs"></a>i. <code>jobs</code></h3><p>Lists the jobs running in the background, giving the job number.</p><h3 id="j-last"><a href="#j-last" class="headerlink" title="j. last"></a>j. <code>last</code></h3><p>Lists your last logins of specified user.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">last yourUsername<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="k-man"><a href="#k-man" class="headerlink" title="k. man"></a>k. <code>man</code></h3><p>Shows the manual for specified command.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">man</span> <span class="token builtin class-name">command</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="l-passwd"><a href="#l-passwd" class="headerlink" title="l. passwd"></a>l. <code>passwd</code></h3><p>Allows the current logged user to change their password.</p><h3 id="m-ping"><a href="#m-ping" class="headerlink" title="m. ping"></a>m. <code>ping</code></h3><p>Pings host and outputs results.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ping</span> <span class="token function">host</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="n-ps"><a href="#n-ps" class="headerlink" title="n. ps"></a>n. <code>ps</code></h3><p>Lists your processes.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> -u yourusername<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Use the flags ef. e for every process and f for full listing. </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="o-quota"><a href="#o-quota" class="headerlink" title="o. quota"></a>o. <code>quota</code></h3><p>Shows what your disk quota is.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">quota</span> -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="p-scp"><a href="#p-scp" class="headerlink" title="p. scp"></a>p. <code>scp</code></h3><p>Transfer files between a local host and a remote host or between two remote hosts.</p><p><em>copy from local host to remote host</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> source_file user@host:directory/target_file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>copy from remote host to local host</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> user@host:directory/source_file target_file<span class="token function">scp</span> -r user@host:directory/source_folder target_folder<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>This command also accepts an option <code>-P</code> that can be used to connect to specific port.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> -P port user@host:directory/source_file target_file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="q-ssh"><a href="#q-ssh" class="headerlink" title="q. ssh"></a>q. <code>ssh</code></h3><p>ssh (SSH client) is a program for logging into and executing commands on a remote machine.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> user@host<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>This command also accepts an option <code>-p</code> that can be used to connect to specific port.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -p port user@host<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="r-top"><a href="#r-top" class="headerlink" title="r. top"></a>r. <code>top</code></h3><p>Displays your currently active processes.</p><h3 id="s-uname"><a href="#s-uname" class="headerlink" title="s. uname"></a>s. <code>uname</code></h3><p>Shows kernel information.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">uname</span> -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="t-uptime"><a href="#t-uptime" class="headerlink" title="t. uptime"></a>t. <code>uptime</code></h3><p>Shows current uptime.</p><h3 id="u-w"><a href="#u-w" class="headerlink" title="u. w"></a>u. <code>w</code></h3><p>Displays who is online.</p><h3 id="v-wget"><a href="#v-wget" class="headerlink" title="v. wget"></a>v. <code>wget</code></h3><p>Downloads file.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="w-whoami"><a href="#w-whoami" class="headerlink" title="w. whoami"></a>w. <code>whoami</code></h3><p>Return current logged in username.</p><h3 id="x-whois"><a href="#x-whois" class="headerlink" title="x. whois"></a>x. <code>whois</code></h3><p>Gets whois information for domain.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">whois domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-5-Process-Monitoring-Operations"><a href="#1-5-Process-Monitoring-Operations" class="headerlink" title="1.5. Process Monitoring Operations"></a>1.5. Process Monitoring Operations</h2><table>   <tbody><tr>      <td><a href="#a-kill">kill</a></td>      <td><a href="#b-killall">killall</a></td>      <td><a href="#c-&amp;">&amp;</a></td>      <td><a href="#d-nohup">nohup</a></td>   </tr></tbody></table><h3 id="a-kill"><a href="#a-kill" class="headerlink" title="a. kill"></a>a. <code>kill</code></h3><p>Kills (ends) the processes with the ID you gave.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> PID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="b-killall"><a href="#b-killall" class="headerlink" title="b. killall"></a>b. <code>killall</code></h3><p>Kill all processes with the name.  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">killall</span> processname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="c-amp"><a href="#c-amp" class="headerlink" title="c. &amp;"></a>c. &amp;</h3><p>The <code>&amp;</code> symbol instructs the command to run as a background process in a subshell.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="d-nohup"><a href="#d-nohup" class="headerlink" title="d. nohup"></a>d. <code>nohup</code></h3><p>nohup stands for “No Hang Up”. This allows to run command/process or shell script that can continue running in the background after you log out from a shell.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nohup</span> <span class="token builtin class-name">command</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Combine it with <code>&amp;</code> to create background processes </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nohup</span> <span class="token builtin class-name">command</span> <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="2-Basic-Shell-Programming"><a href="#2-Basic-Shell-Programming" class="headerlink" title="2. Basic Shell Programming"></a>2. Basic Shell Programming</h1><p>The first line that you will write in bash script files is called <code>shebang</code>. This line in any script determines the script’s ability to be executed like a standalone executable without typing sh, bash, python, php etc beforehand in the terminal.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-1-Variables"><a href="#2-1-Variables" class="headerlink" title="2.1. Variables"></a>2.1. Variables</h2><p>Creating variables in bash is similar to other languages. There are no data types. A variable in bash can contain a number, a character, a string of characters, etc. You have no need to declare a variable, just assigning a value to its reference will create it.</p><p>Example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">"hello world"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The above line creates a variable <code>str</code> and assigns “hello world” to it. The value of variable is retrieved by putting the <code>$</code> in the beginning of variable name.</p><p>Example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">$str</span>   <span class="token comment"># hello world</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-2-Array"><a href="#2-2-Array" class="headerlink" title="2.2. Array"></a>2.2. Array</h2><p>Like other languages bash has also arrays. An array is a variable containing multiple values. There’s no maximum limit on the size of array. Arrays in bash are zero based. The first element is indexed with element 0. There are several ways for creating arrays in bash which are given below.</p><p>Examples:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>valarray<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>valarray<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>val<span class="token assign-left variable">array</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>val <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>val <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>val<span class="token punctuation">)</span><span class="token assign-left variable">array</span><span class="token operator">=</span><span class="token punctuation">(</span>val val val<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>To display a value at specific index use following syntax:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">${array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>}</span>     <span class="token comment"># where i is the index</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>If no index is supplied, array element 0 is assumed. To find out how many values there are in the array use the following syntax:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">${<span class="token operator">#</span>array<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Bash has also support for the ternary conditions. Check some examples below.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">${varname<span class="token operator">:-</span>word}</span>    <span class="token comment"># if varname exists and isn't null, return its value; otherwise return word</span><span class="token variable">${varname<span class="token operator">:=</span>word}</span>    <span class="token comment"># if varname exists and isn't null, return its value; otherwise set it word and then return its value</span><span class="token variable">${varname<span class="token operator">:+</span>word}</span>    <span class="token comment"># if varname exists and isn't null, return word; otherwise return null</span><span class="token variable">${varname<span class="token operator">:</span>offset<span class="token operator">:</span>length}</span>    <span class="token comment"># performs substring expansion. It returns the substring of $varname starting at offset and up to length characters</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-String-Substitution"><a href="#2-3-String-Substitution" class="headerlink" title="2.3 String Substitution"></a>2.3 String Substitution</h2><p>Check some of the syntax on how to manipulate strings</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">${variable<span class="token operator">#</span>pattern}</span>         <span class="token comment"># if the pattern matches the beginning of the variable's value, delete the shortest part that matches and return the rest</span><span class="token variable">${variable<span class="token operator">##</span>pattern}</span>        <span class="token comment"># if the pattern matches the beginning of the variable's value, delete the longest part that matches and return the rest</span><span class="token variable">${variable<span class="token operator">%</span>pattern}</span>         <span class="token comment"># if the pattern matches the end of the variable's value, delete the shortest part that matches and return the rest</span><span class="token variable">${variable<span class="token operator">%%</span>pattern}</span>        <span class="token comment"># if the pattern matches the end of the variable's value, delete the longest part that matches and return the rest</span><span class="token variable">${variable<span class="token operator">/</span>pattern<span class="token operator">/</span>string}</span>  <span class="token comment"># the longest match to pattern in variable is replaced by string. Only the first match is replaced</span><span class="token variable">${variable<span class="token operator">/</span><span class="token operator">/</span>pattern<span class="token operator">/</span>string}</span> <span class="token comment"># the longest match to pattern in variable is replaced by string. All matches are replaced</span><span class="token variable">${<span class="token operator">#</span>varname}</span>     <span class="token comment"># returns the length of the value of the variable as a character string</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-Functions"><a href="#2-4-Functions" class="headerlink" title="2.4. Functions"></a>2.4. Functions</h2><p>As in almost any programming language, you can use functions to group pieces of code in a more logical way or practice the divine art of recursion. Declaring a function is just a matter of writing function my_func { my_code }. Calling a function is just like calling another program, you just write its name.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">function</span> <span class="token function-name function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    shell commands<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">function</span> <span class="token function-name function">hello</span> <span class="token punctuation">{</span>   <span class="token builtin class-name">echo</span> world<span class="token operator">!</span><span class="token punctuation">}</span>hello<span class="token keyword">function</span> <span class="token function-name function">say</span> <span class="token punctuation">{</span>    <span class="token builtin class-name">echo</span> <span class="token variable">$1</span><span class="token punctuation">}</span>say <span class="token string">"hello world!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>When you run the above example the <code>hello</code> function will output “world!”. The above two functions <code>hello</code> and <code>say</code> are identical. The main difference is function <code>say</code>. This function, prints the first argument it receives. Arguments, within functions, are treated in the same manner as arguments given to the script.</p><h2 id="2-5-Conditionals"><a href="#2-5-Conditionals" class="headerlink" title="2.5. Conditionals"></a>2.5. Conditionals</h2><p>The conditional statement in bash is similar to other programming languages. Conditions have many form like the most basic form is <code>if</code> expression <code>then</code> statement where statement is only executed if expression is true.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> expression <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    will execute only <span class="token keyword">if</span> expression is <span class="token boolean">true</span><span class="token keyword">else</span>    will execute <span class="token keyword">if</span> expression is <span class="token boolean">false</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Sometime if conditions becoming confusing so you can write the same condition using the <code>case statements</code>.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">case</span> expression <span class="token keyword">in</span>    pattern1 <span class="token punctuation">)</span>        statements <span class="token punctuation">;</span><span class="token punctuation">;</span>    pattern2 <span class="token punctuation">)</span>        statements <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token punctuation">..</span>.<span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Expression Examples:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">statement1 <span class="token operator">&amp;&amp;</span> statement2  <span class="token comment"># both statements are true</span>statement1 <span class="token operator">||</span> statement2  <span class="token comment"># at least one of the statements is true</span><span class="token assign-left variable">str1</span><span class="token operator">=</span>str2       <span class="token comment"># str1 matches str2</span>str1<span class="token operator">!=</span>str2      <span class="token comment"># str1 does not match str2</span>str<span class="token operator"><span class="token file-descriptor important">1</span>&lt;</span>str2       <span class="token comment"># str1 is less than str2</span>str<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>str2       <span class="token comment"># str1 is greater than str2</span>-n str1         <span class="token comment"># str1 is not null (has length greater than 0)</span>-z str1         <span class="token comment"># str1 is null (has length 0)</span>-a <span class="token function">file</span>         <span class="token comment"># file exists</span>-d <span class="token function">file</span>         <span class="token comment"># file exists and is a directory</span>-e <span class="token function">file</span>         <span class="token comment"># file exists; same -a</span>-f <span class="token function">file</span>         <span class="token comment"># file exists and is a regular file (i.e., not a directory or other special type of file)</span>-r <span class="token function">file</span>         <span class="token comment"># you have read permission</span>-s <span class="token function">file</span>         <span class="token comment"># file exists and is not empty</span>-w <span class="token function">file</span>         <span class="token comment"># you have write permission</span>-x <span class="token function">file</span>         <span class="token comment"># you have execute permission on file, or directory search permission if it is a directory</span>-N <span class="token function">file</span>         <span class="token comment"># file was modified since it was last read</span>-O <span class="token function">file</span>         <span class="token comment"># you own file</span>-G <span class="token function">file</span>         <span class="token comment"># file's group ID matches yours (or one of yours, if you are in multiple groups)</span>file1 -nt file2     <span class="token comment"># file1 is newer than file2</span>file1 -ot file2     <span class="token comment"># file1 is older than file2</span>-lt     <span class="token comment"># less than</span>-le     <span class="token comment"># less than or equal</span>-eq     <span class="token comment"># equal</span>-ge     <span class="token comment"># greater than or equal</span>-gt     <span class="token comment"># greater than</span>-ne     <span class="token comment"># not equal</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-6-Loops"><a href="#2-6-Loops" class="headerlink" title="2.6. Loops"></a>2.6. Loops</h2><p>There are three types of loops in bash. <code>for</code>, <code>while</code> and <code>until</code>.</p><p>Different <code>for</code> Syntax:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> x :<span class="token operator">=</span> <span class="token number">1</span> to <span class="token number">10</span> <span class="token keyword">do</span>begin  statementsend<span class="token keyword">for</span> name <span class="token punctuation">[</span>in list<span class="token punctuation">]</span><span class="token keyword">do</span>  statements that can use <span class="token variable">$name</span><span class="token keyword">done</span><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> initialisation <span class="token punctuation">;</span> ending condition <span class="token punctuation">;</span> update <span class="token punctuation">))</span></span><span class="token keyword">do</span>  statements<span class="token punctuation">..</span>.<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>while</code> Syntax:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">while</span> condition<span class="token punctuation">;</span> <span class="token keyword">do</span>  statements<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>until</code> Syntax:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">until</span> condition<span class="token punctuation">;</span> <span class="token keyword">do</span>  statements<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="3-Tricks"><a href="#3-Tricks" class="headerlink" title="3. Tricks"></a>3. Tricks</h1><h2 id="Set-an-alias"><a href="#Set-an-alias" class="headerlink" title="Set an alias"></a>Set an alias</h2><p>Run <code>nano ~/.bash_profile</code> and add the following line:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">dockerlogin</span><span class="token operator">=</span><span class="token string">'ssh www-data@adnan.local -p2222'</span>  <span class="token comment"># add your alias in .bash_profile</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="To-quickly-go-to-a-specific-directory"><a href="#To-quickly-go-to-a-specific-directory" class="headerlink" title="To quickly go to a specific directory"></a>To quickly go to a specific directory</h2><p>Run <code>nano ~/.bashrc</code> and add the following line:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">hotellogs</span><span class="token operator">=</span><span class="token string">"/workspace/hotel-api/storage/logs"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Now you can use the saved path:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.bashrc<span class="token builtin class-name">cd</span> <span class="token variable">$hotellogs</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Re-execute-the-previous-command"><a href="#Re-execute-the-previous-command" class="headerlink" title="Re-execute the previous command"></a>Re-execute the previous command</h2><p>This goes back to the days before you could rely on keyboards to have an “up” arrow key, but can still be useful.<br>To run the last command in your history</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">!</span><span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>A common error is to forget to use <code>sudo</code> to prefix a command requiring privileged execution. Instead of typing the whole command again, you can:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token operator">!</span><span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>This would change a <code>mkdir somedir</code> into <code>sudo mkdir somedir</code>.</p><h2 id="Exit-traps"><a href="#Exit-traps" class="headerlink" title="Exit traps"></a>Exit traps</h2><p>Make your bash scripts more robust by reliably performing cleanup.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">function</span> <span class="token function-name function">finish</span> <span class="token punctuation">{</span>  <span class="token comment"># your cleanup here. e.g. kill any forked processes</span>  <span class="token function">jobs</span> -p <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">kill</span><span class="token punctuation">}</span><span class="token builtin class-name">trap</span> finish EXIT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Saving-your-environment-variables"><a href="#Saving-your-environment-variables" class="headerlink" title="Saving your environment variables"></a>Saving your environment variables</h2><p>When you do <code>export FOO = BAR</code>, your variable is only exported in this current shell and all its children, to persist in the future you can simply append in your <code>~/.bash_profile</code> file the command to export your variable</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token builtin class-name">export</span> <span class="token assign-left variable">FOO</span><span class="token operator">=</span>BAR <span class="token operator">&gt;&gt;</span> ~/.bash_profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Accessing-your-scripts"><a href="#Accessing-your-scripts" class="headerlink" title="Accessing your scripts"></a>Accessing your scripts</h2><p>You can easily access your scripts by creating a bin folder in your home with <code>mkdir ~/bin</code>, now all the scripts you put in this folder you can access in any directory.</p><p>If you can not access, try append the code below in your <code>~/.bash_profile</code> file and after do <code>source ~/.bash_profile</code>.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># set PATH so it includes user's private bin if it exists</span><span class="token keyword">if</span> <span class="token punctuation">[</span> -d <span class="token string">"<span class="token environment constant">$HOME</span>/bin"</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$HOME</span>/bin:<span class="token environment constant">$PATH</span>"</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-Debugging"><a href="#4-Debugging" class="headerlink" title="4. Debugging"></a>4. Debugging</h1><p>You can easily debug the bash script by passing different options to <code>bash</code> command. For example <code>-n</code> will not run commands and check for syntax errors only. <code>-v</code> echo commands before running them. <code>-x</code> echo commands after command-line processing.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">bash</span> -n scriptname<span class="token function">bash</span> -v scriptname<span class="token function">bash</span> -x scriptname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul><li>Report issues <a href="https://help.github.com/articles/creating-an-issue/">How to</a></li><li>Open pull request with improvements <a href="https://help.github.com/articles/about-pull-requests/">How to</a></li><li>Spread the word</li></ul><h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><ul><li><a href="https://github.com/vuuihc/bash-guide">Chinese | 简体中文</a></li><li><a href="https://github.com/omergulen/bash-guide">Turkish | Türkçe</a></li><li><a href="https://github.com/itooww/bash-guide">Japanese | 日本語</a></li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="https://creativecommons.org/licenses/by/4.0/"><img src="https://img.shields.io/badge/License-CC%20BY%204.0-lightgrey.svg" alt="License: CC BY 4.0"></a></p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell</title>
      <link href="/2022/05/01/shell-jiao-ben/"/>
      <url>/2022/05/01/shell-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h1 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h1><h3 id="1-变量定义"><a href="#1-变量定义" class="headerlink" title="1. 变量定义"></a><strong>1. 变量定义</strong></h3><h4 id="1-1-脚本变量类型"><a href="#1-1-脚本变量类型" class="headerlink" title="1.1 脚本变量类型"></a>1.1 <strong>脚本变量类型</strong></h4><p><strong>(1) 局部变量</strong>：局部变量在脚本或命令中定义，仅在当前 shell 实例中有效，其他 shell 启动的程序不能访问局部变量；</p><p><strong>(2) 环境变量</strong>：所有的程序，包括 shell 启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候 shell 脚本也可以定义环境变量；</p><p><strong>(3) shell 变量</strong>：shell 变量是由 shell 程序设置的特殊变量。shell 变量中有一部分是环境变量，有一部分是局部变量。</p><h4 id="1-2-定义变量和使用变量"><a href="#1-2-定义变量和使用变量" class="headerlink" title="1.2 定义变量和使用变量"></a>1.2 <strong>定义变量和使用变量</strong></h4><p>在定义和使用变量时，应遵循如下描述：</p><p><strong>(1)</strong> 定义变量：<code>name=value</code> 需要注意，等号两侧不能有空格；</p><p><strong>(2)</strong> 使用变量：<code>echo $name 或 echo ${name}</code> ；</p><p><strong>(3)</strong> 定义局部变量：<code>local name="test"</code> ；</p><p><strong>(4)</strong> 定义只读变量：<code>readonly name</code>；</p><p><strong>(5)</strong> 删除变量：<code>unset name</code>。</p><h4 id="1-3-Bash-字符串"><a href="#1-3-Bash-字符串" class="headerlink" title="1.3 Bash 字符串"></a>1.3 <strong>Bash 字符串</strong></h4><p>在 Bash 中，字符串可以是单引号或双引号，二者的区别如下：</p><ul><li><p>单引号：单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；单引号字串中不能出现单独一个的单引号，但可以成对出现，作为字符串拼接使用；</p></li><li><p>双引号：双引号里可以有变量且可以出现转义字符。</p></li></ul><h3 id="2-Bash-脚本传递参数"><a href="#2-Bash-脚本传递参数" class="headerlink" title="2. Bash 脚本传递参数"></a><strong>2. Bash 脚本传递参数</strong></h3><p>在使用 Bash 脚本时，我们可以传递一些参数给 Bash 脚本，方便 Bash 脚本执行相应操作。具体的参数使用说明如下：</p><h4 id="2-1-Bash-中的参数"><a href="#2-1-Bash-中的参数" class="headerlink" title="2.1 Bash 中的参数"></a>2.1 <strong>Bash 中的参数</strong></h4><p>在 Bash 中使用参数时，具体定义如下：</p><p>⚫ Bash 中的参数按照数字顺序定义；</p><p>⚫ Bash 脚本内获取参数的格式为：**$n**。</p><h4 id="2-2-几个特殊参数"><a href="#2-2-几个特殊参数" class="headerlink" title="2.2 几个特殊参数"></a>2.2 <strong>几个特殊参数</strong></h4><p>Bash 中除了正常的顺序参数以外，还有一些特殊参数：</p><p>⚫ <strong>$0</strong>：文件名；</p><p>⚫ **$#**：传递到脚本的参数的个数；</p><p>⚫ **$***：以一个单字符串显示所有向脚本传递的参数。</p><h3 id="3-Bash-脚本定义数组"><a href="#3-Bash-脚本定义数组" class="headerlink" title="3. Bash 脚本定义数组"></a><strong>3. Bash 脚本定义数组</strong></h3><h4 id="3-1-定义数组"><a href="#3-1-定义数组" class="headerlink" title="3.1 定义数组"></a>3.1 <strong>定义数组</strong></h4><p>定义数组：<code>myArray=(value0 value1 value2)</code>。</p><h4 id="3-2-使用数组"><a href="#3-2-使用数组" class="headerlink" title="3.2 使用数组"></a>3.2 <strong>使用数组</strong></h4><p>使用数组：<code>${数组名[下标]}</code>。</p><h4 id="3-3-获取数组所有元素"><a href="#3-3-获取数组所有元素" class="headerlink" title="3.3 获取数组所有元素"></a>3.3 <strong>获取数组所有元素</strong></h4><p><code>${my_array[*]}</code> 或者 <code>${my_array[@]}</code> 可以获得数组的所有元素。</p><h4 id="3-4-获取数组长度"><a href="#3-4-获取数组长度" class="headerlink" title="3.4 获取数组长度"></a>3.4 <strong>获取数组长度</strong></h4><p><code>${#array_name[@]}</code> 或者 <code>${#array_name[*]}</code> <code>可以获得数组长度</code>。</p><h3 id="4-Bash-脚本运算符"><a href="#4-Bash-脚本运算符" class="headerlink" title="4. Bash 脚本运算符"></a><strong>4. Bash 脚本运算符</strong></h3><h4 id="4-1-Bash-中的算数运算符"><a href="#4-1-Bash-中的算数运算符" class="headerlink" title="4.1 Bash 中的算数运算符"></a>4.1 <strong>Bash 中的算数运算符</strong></h4><table><thead><tr><th align="center"><strong>运算符</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加法</td></tr><tr><td align="center">-</td><td align="center">减法</td></tr><tr><td align="center">*</td><td align="center">乘法</td></tr><tr><td align="center">/</td><td align="center">除法</td></tr><tr><td align="center">%</td><td align="center">取余</td></tr><tr><td align="center">=</td><td align="center">赋值</td></tr><tr><td align="center">==</td><td align="center">相等</td></tr><tr><td align="center">!=</td><td align="center">不相等</td></tr></tbody></table><h4 id="4-2-关系运算符"><a href="#4-2-关系运算符" class="headerlink" title="4.2 关系运算符"></a>4.2 <strong>关系运算符</strong></h4><table><thead><tr><th align="center"><strong>运算符</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">-eq</td><td align="left">检测两个数是否相等，相等返回 true。</td></tr><tr><td align="center">-ne</td><td align="left">检测两个数是否不相等，不相等返回 true。</td></tr><tr><td align="center">-gt</td><td align="left">检测左边的数是否大于右边的，如果是，则返回 true。</td></tr><tr><td align="center">-lt</td><td align="left">检测左边的数是否小于右边的，如果是，则返回 true。</td></tr><tr><td align="center">-ge</td><td align="left">检测左边的数是否大于等于右边的，如果是，则返回 true。</td></tr><tr><td align="center">-le</td><td align="left">检测左边的数是否小于等于右边的，如果是，则返回 true。</td></tr></tbody></table><h4 id="4-3-布尔运算符"><a href="#4-3-布尔运算符" class="headerlink" title="4.3 布尔运算符"></a>4.3 <strong>布尔运算符</strong></h4><table><thead><tr><th align="center"><strong>运算符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">!</td><td>非运算，表达式为 true 则返回 false，否则返回 true。</td></tr><tr><td align="center">-o</td><td>或运算，有一个表达式为 true 则返回 true。</td></tr><tr><td align="center">-a</td><td>与运算，两个表达式都为 true 才返回 true。</td></tr></tbody></table><h4 id="4-4-逻辑运算符"><a href="#4-4-逻辑运算符" class="headerlink" title="4.4 逻辑运算符"></a>4.4 <strong>逻辑运算符</strong></h4><table><thead><tr><th align="center"><strong>运算符</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">逻辑的 AND</td></tr><tr><td align="center">||</td><td align="center">逻辑的 OR</td></tr></tbody></table><h4 id="4-5-字符串运算符"><a href="#4-5-字符串运算符" class="headerlink" title="4.5 字符串运算符"></a>4.5 <strong>字符串运算符</strong></h4><table><thead><tr><th align="center"><strong>运算符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">=</td><td>检测两个字符串是否相等，相等返回 true。</td></tr><tr><td align="center">!=</td><td>检测两个字符串是否不相等，不相等返回 true。</td></tr><tr><td align="center">-z</td><td>检测字符串长度是否为 0，为 0 返回 true。</td></tr><tr><td align="center">-n</td><td>检测字符串长度是否不为 0，不为 0 返回 true。</td></tr><tr><td align="center">$</td><td>检测字符串是否为空，不为空返回 true。</td></tr></tbody></table><h4 id="4-6-文件测试运算符"><a href="#4-6-文件测试运算符" class="headerlink" title="4.6 文件测试运算符"></a>4.6 <strong>文件测试运算符</strong></h4><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true。</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true。</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true。</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td></tr><tr><td>-p file</td><td>检测文件是否是有名管道，如果是，则返回 true。</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true。</td></tr></tbody></table><h3 id="5-Bash-脚本流程控制"><a href="#5-Bash-脚本流程控制" class="headerlink" title="5. Bash 脚本流程控制"></a><strong>5. Bash 脚本流程控制</strong></h3><h4 id="5-1-if-语句"><a href="#5-1-if-语句" class="headerlink" title="5.1 if 语句"></a>5.1 <strong>if 语句</strong></h4><pre class="line-numbers language-none"><code class="language-none">if conditionthen command1  command2 ... commandN fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">if conditionthen command1  command2 ... commandNelse commandfi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">if condition1then command1elif condition2 then  command2else commandNfi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-2-For-循环"><a href="#5-2-For-循环" class="headerlink" title="5.2 For 循环"></a>5.2 <strong>For 循环</strong></h4><pre class="line-numbers language-none"><code class="language-none">for var in item1 item2 ... itemNdo command1 command2 ... commandNdone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-While-循环"><a href="#5-3-While-循环" class="headerlink" title="5.3 While 循环"></a>5.3 <strong>While 循环</strong></h4><pre class="line-numbers language-none"><code class="language-none">while conditiondo commanddone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#无限循环# 写法 1 while :do commanddone# 写法 2 while truedo commanddone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-Until-循环"><a href="#5-4-Until-循环" class="headerlink" title="5.4 Until 循环"></a>5.4 <strong>Until 循环</strong></h4><pre class="line-numbers language-none"><code class="language-none">until conditiondo commanddone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-5-Case-Switch-控制"><a href="#5-5-Case-Switch-控制" class="headerlink" title="5.5 Case (Switch) 控制"></a>5.5 <strong>Case (Switch) 控制</strong></h4><pre class="line-numbers language-none"><code class="language-none">case 值 invalue1) command1 command2 ... commandN ;;value2） command1 command2 ... commandN ;;esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-6-跳出循环"><a href="#5-6-跳出循环" class="headerlink" title="5.6 跳出循环"></a>5.6 <strong>跳出循环</strong></h4><p>⚫ 跳出循环使用 <code>break</code>； </p><p>⚫ 跳过当前循环使用 <code>continue</code>。</p><h3 id="6-Bash-脚本输出"><a href="#6-Bash-脚本输出" class="headerlink" title="6. Bash 脚本输出"></a><strong>6. Bash 脚本输出</strong></h3><h4 id="6-1-echo输出"><a href="#6-1-echo输出" class="headerlink" title="6.1 echo输出"></a>6.1 echo输出</h4><pre class="line-numbers language-none"><code class="language-none">echo "It is Linux.CN" # 输出普通字符串echo "\"It is Linux.CN\"" # 输出转义字符串echo "$name is best Linux Distro"。# 输出变量echo -e "Show me your code! \n" # 输出换行符，其中 -e 用于开启转义。echo `date` # 输出命令执行结果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-2-printf格式化输出"><a href="#6-2-printf格式化输出" class="headerlink" title="6.2 printf格式化输出"></a>6.2 printf<strong>格式化输出</strong></h4><table><thead><tr><th><strong>printf 支持</strong>的格式字符</th><th>说明</th></tr></thead><tbody><tr><td>\a</td><td>警告字符，通常为 ASCII 的 BEL 字符</td></tr><tr><td>\b</td><td>后退</td></tr><tr><td>\c</td><td>抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td>\f</td><td>换页（formfeed）</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车（Carriage return）</td></tr><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\</td><td>一个字面上的反斜杠字符</td></tr><tr><td>\ddd</td><td>表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效</td></tr><tr><td>\0ddd</td><td>表示 1 到 3 位的八进制值字符</td></tr></tbody></table><h3 id="7-Bash-脚本测试"><a href="#7-Bash-脚本测试" class="headerlink" title="7. Bash 脚本测试"></a><strong>7. Bash 脚本测试</strong></h3><p>借助测试参数，你可以判断 Bash 中某些语句是否符合特定的条件，比如文件是否存在、</p><p>字符串长度是否为 0 。测试参数可以帮助你完成更加复杂的 Bash 脚本。</p><h4 id="7-1-数值测试"><a href="#7-1-数值测试" class="headerlink" title="7.1 数值测试"></a>7.1 <strong>数值测试</strong></h4><table><thead><tr><th align="center"><strong>运算符</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">-eq</td><td align="left">相等返回 true。</td></tr><tr><td align="center">-ne</td><td align="left">不相等返回 true。</td></tr><tr><td align="center">-gt</td><td align="left">大于返回 true。</td></tr><tr><td align="center">-lt</td><td align="left">小于返回 true。</td></tr><tr><td align="center">-ge</td><td align="left">大于等于返回 true。</td></tr><tr><td align="center">-le</td><td align="left">小于等于返回 true。</td></tr></tbody></table><h4 id="7-2-字符测试"><a href="#7-2-字符测试" class="headerlink" title="7.2 字符测试"></a>7.2 <strong>字符测试</strong></h4><table><thead><tr><th align="center"><strong>运算符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">!</td><td>非运算，表达式为 true 则返回 false，否则返回 true。</td></tr><tr><td align="center">-o</td><td>或运算，有一个表达式为 true 则返回 true。</td></tr><tr><td align="center">-a</td><td>与运算，两个表达式都为 true 才返回 true。</td></tr></tbody></table><p>7.3 文件测试</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true。</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true。</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true。</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td></tr><tr><td>-p file</td><td>检测文件是否是有名管道，如果是，则返回 true。</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true。</td></tr></tbody></table><h3 id="8-Bash-脚本函数"><a href="#8-Bash-脚本函数" class="headerlink" title="8 Bash 脚本函数"></a><strong>8 Bash 脚本函数</strong></h3><h4 id="8-1-函数定义结构"><a href="#8-1-函数定义结构" class="headerlink" title="8.1 函数定义结构"></a>8.1 <strong>函数定义结构</strong></h4><pre class="line-numbers language-none"><code class="language-none">[ function ] funname [()]{ action; [return int;]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中</p><p>⚫ function 关键词可带可不带；</p><p>⚫ funcname 根据实际需要定义；</p><p>⚫ return int 根据需要加入。</p><h4 id="8-2-函数参数"><a href="#8-2-函数参数" class="headerlink" title="8.2 函数参数"></a>8.2 <strong>函数参数</strong></h4><p>⚫ 调用函数时传递的参数可以在函数中以 <code>$1、$2</code> 的方式获取；</p><p>⚫ 使用 <code>$1</code> 的方式获取参数仅可用于前 10 个参数，超出需要使用 $n 获取；</p><p>⚫ 特殊参数处理如下：</p><table><thead><tr><th><strong>参数处理</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>$#</td><td>传递到脚本或函数的参数个数</td></tr><tr><td>$*</td><td>以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td>$$</td><td>脚本运行的当前进程 ID 号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的 ID 号</td></tr><tr><td>$@</td><td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td></tr><tr><td>$-</td><td>显示 Shell 使用的当前选项，与 set 命令功能相同。</td></tr><tr><td>$?</td><td>显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><h4 id="8-4-Bash-脚本输出输入重定向"><a href="#8-4-Bash-脚本输出输入重定向" class="headerlink" title="8.4 Bash 脚本输出输入重定向"></a><strong>8.4 Bash 脚本输出输入重定向</strong></h4><p><strong>Bash 输入输出重定向</strong></p><table><thead><tr><th><strong>命令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>command &gt; file</td><td>将输出重定向到 file。</td></tr><tr><td>command &lt; file</td><td>将输入重定向到 file。</td></tr><tr><td>command &gt;&gt; file</td><td>将输出以追加的方式重定向到 file</td></tr><tr><td>n &gt; file</td><td>将文件描述符为 n 的文件重定向到 file。</td></tr><tr><td>n &gt;&gt; file</td><td>将文件描述符为 n 的文件以追加的方式重定向到 file</td></tr><tr><td>n &gt;&amp; m</td><td>将输出文件 m 和 n 合并</td></tr><tr><td>n &lt;&amp; m</td><td>将输入文件 m 和 n 合并</td></tr><tr><td>&lt;&lt; tag</td><td>将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td></tr><tr><td><strong>/dev/null</strong></td><td>如果不希望看到输出，可以将输出重定向到 /dev/null。</td></tr></tbody></table><h4 id="8-5-Bash-文件包含"><a href="#8-5-Bash-文件包含" class="headerlink" title="8.5 Bash 文件包含"></a><strong>8.5 Bash 文件包含</strong></h4><p><strong>包含文件</strong></p><pre class="line-numbers language-none"><code class="language-none"># 写法 1. filename # 注意点号(.)和文件名中间有一空格# 写法 2source filename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-Bash-编写常用命令"><a href="#9-Bash-编写常用命令" class="headerlink" title="9 Bash 编写常用命令"></a>9 Bash 编写常用命令</h3><h4 id="9-1-pwd"><a href="#9-1-pwd" class="headerlink" title="9.1 pwd"></a><strong>9.1 pwd</strong></h4><p>pwd 命令是用来获取当前目录的，可以用于基于当前目录进行文件/文件夹操作。</p><pre class="line-numbers language-none"><code class="language-none">pwd #输出当前所在目录；pwd -P #输出当前所在命令，并展示所有的软连接指向。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="9-2-sort"><a href="#9-2-sort" class="headerlink" title="9.2 sort"></a><strong>9.2 sort</strong></h4><p>sort 命令是用来对内容进行排序的，可以将文本、数字进行排序。</p><pre class="line-numbers language-none"><code class="language-none">sort path/to/file # 对文件内容进行升序排列；sort --reverse path/to/file # 对文件内容进行降序排列；sort --ignore-case path/to/file # 对文件内容进行忽略大小写的升序排列；sort --numeric-sort path/to/file # 对文件内容进行按数字顺序排列；sort --unique path/to/file # 对文件内容进行唯一排列；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="9-3-echo"><a href="#9-3-echo" class="headerlink" title="9.3 echo"></a><strong>9.3 echo</strong></h4><p>echo 命令是用来输出内容的，可以配合格式编码输出特定颜色/风格的文字。</p><pre class="line-numbers language-none"><code class="language-none">echo "message" # 输出信息；echo "my path is $PATH" # 输出包含有环境变量的信息；echo "Hello World" &gt;&gt; {{file.txt}} # 在文件尾部追加内容；echo "Hello World" &gt; {{file.txt}} # 移除当前文件内容，并替换为新的内容。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="9-4-read"><a href="#9-4-read" class="headerlink" title="9.4 read"></a><strong>9.4 read</strong></h4><p>read 命令是用来获取用户输入内容，即标准输入设备(键盘)输入内容。</p><pre class="line-numbers language-none"><code class="language-none">read $variable #读入数据，并设置给变量；read -p "Enter your input here: " $variable #展示提示，并读入数据，设置给变量；while read line; do echo "$line"; done #按行读取内容，并执行命令。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="9-5-shift"><a href="#9-5-shift" class="headerlink" title="9.5 shift"></a><strong>9.5 shift</strong></h4><p>shift 可以用于将函数的参数移除，其他参数向前移动。</p><pre class="line-numbers language-none"><code class="language-none">shift 3 shift 后可以跟一个数字参数，表示移除相应数量的参数，其他参数向前移动。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="10-Bash-公共库"><a href="#10-Bash-公共库" class="headerlink" title="10 Bash 公共库"></a>10 Bash 公共库</h3><h4 id="10-1-Bash-Shell-Function-Library"><a href="#10-1-Bash-Shell-Function-Library" class="headerlink" title="10.1 Bash Shell Function Library"></a><strong>10.1 Bash Shell Function Library</strong></h4><p>项目地址：<a href="https://github.com/SkypLabs/bsfl">https://github.com/SkypLabs/bsfl</a></p><p>​        Bash Shell Function Library 是一个短小精炼的 Bash 公共库，他提供了诸如数组操作、命令执行、文件管理、日志记录、信息提醒、网络检测、字符操作、时间操作、变量操作等功能。此外，Bash Shell Function Library 还提供了一个完整的<a href="https://skyplabs.github.io/bsfl/modules.html">在线文档</a>，帮助了解函数库中提供的重要函数</p><h4 id="10-2-Bash-Lib"><a href="#10-2-Bash-Lib" class="headerlink" title="10.2 Bash Lib"></a><strong>10.2 Bash Lib</strong></h4><p>项目地址：<a href="http://aks.github.io/bash-lib/">http://aks.github.io/bash-lib/</a></p><p>​        Bash Lib 是一个原子化的公共库，你可以根据自己的实际需要，引入所需的公共库分组，</p><p>使用相应的内容，降低整个项目的大小。</p><p>Bash Lib 提供了诸多原子库，你选择需要使用的引入即可：</p><pre class="line-numbers language-none"><code class="language-none">⚫ 参数处理：arg-utils⚫ 日历处理： calendar-utils⚫ 日期处理：date-utils⚫ Hash 处理：hash-utils⚫ 帮助处理：help-util⚫ 列表处理：list-utils⚫ 交互处理：prompt-colors⚫ 文字处理：text-utils⚫ 测试处理：test-utils⚫ 时间处理：time-utils⚫ ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用方法</strong></p><p>从 <a href="https://github.com/aks/bash-lib">https://github.com/aks/bash-lib</a> 下载仓库，并选择你需要引入的脚本，复制到项目</p><p>目录下，并进行引用即可。</p><p><strong>示例代码</strong></p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/env bashsource text-utils.shlowercase "HELLOWORLD"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>other</strong></p><p><a href="https://github.com/awesome-lists/awesome-bash">https://github.com/awesome-lists/awesome-bash</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ini文件</title>
      <link href="/2022/05/01/ini-wen-jian/"/>
      <url>/2022/05/01/ini-wen-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="ini文件"><a href="#ini文件" class="headerlink" title="ini文件"></a>ini文件</h1><p>一.什么是Ini</p><p>​        ini文件是Initialization File的缩写，即初始化文件，通常存放的是一个程序的初始化信息，是Windows的系统配置文件所采用的存储格式，统管windows的各项配置。ini文件的后缀名不一定是*<em>.ini，也可是<code>.cfg</code>、<code>.conf</code>或者是`.tx</em>t。</p><p>二.ini文件格式&amp;语法规范</p><p>​        <code>ini</code><strong>文件由若干个</strong><code>节（section）</code><strong>组成，每个</strong><code>section</code><strong>由若干</strong><code>键（Key）</code><strong>组成，每个</strong><code>Key</code><strong>可以赋相应的值。读写</strong><code>ini</code><strong>文件实际上就是读写某个的</strong><code>section</code><strong>中相应的</strong><code>Key</code>的值，而这只要借助几个函数即可完成。</p><ul><li>**<code>参数（Parameter）</code><strong>：</strong><code>ini</code>*<em>文件包含的最基本元素是*</em><code>参数</code><strong>，</strong><code>参数</code>*<em>包含*</em><code>参数名（name）</code>*<em>和*</em><code>参数值（value）</code>**，格式如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">name=value ;【参数】（键=值）：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**<code>节（section）</code><strong>：所有的<code>参数</code>都是以<code>节</code>为单位结合在一起。</strong><code>节</code>*<em>名称独占一行，在节声明后的所有的*</em><code>参数</code>*<em>都属于该*</em><code>节</code>**。<code>节</code><strong>没有结束标识符，一个</strong><code>section</code><strong>的开始就是上一个</strong><code>section</code>的结束。格式如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">[section]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**<code>注释（comments)</code>**：<code>注释</code>用分号<code>;</code><strong>表示，放在注释之前，</strong><code>;</code>号后直到行尾均为注释。示例如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">;i wish nothing but the best for you<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>文件实例</li></ul><pre class="line-numbers language-none"><code class="language-none">[owner]name=WU yanzuorganization=The United Nations[UserConfig]OpenDownloadFileAtOnec=YWindowStyle=DevExpress Dark Style [Language]Language=CHS [AutoUpdate]Version=2.10  ;last version:2.08<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ini </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c&amp;c++学习网站</title>
      <link href="/2022/04/29/cc-xue-xi-wang-zhan/"/>
      <url>/2022/04/29/cc-xue-xi-wang-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="c-amp-c-学习网站"><a href="#c-amp-c-学习网站" class="headerlink" title="c&amp;c++学习网站"></a>c&amp;c++学习网站</h1><pre class="line-numbers language-none"><code class="language-none">// c/c++ 基础https://github.com/TheAlgorithms/Chttps://github.com/TheAlgorithms/C-Plus-Plushttps://www.tutorialspoint.com/cplusplus/index.htmlhttp://www.cplusplus.com/reference/https://en.cppreference.com/w/// libhv是一个类似于libevent、libev、libuv的跨平台网络库，提供了更易用的接口和更丰富的协议。https://github.com/ithewei/libhv //跨平台网络库https://github.com/Light-City/CPlusPlusThings // c++基础https://github.com/JakubVojvoda/design-patterns-cpp // 设计模式https://github.com/tmux/tmuxhttps://github.com/netdata/netdata // 分布式实时监控代理//资源库推荐https://github.com/oz123/awesome-chttps://github.com/fffaraz/awesome-cpphttps://github.com/zhengnianli/EmbedSummary<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPool</title>
      <link href="/2022/04/28/threadpool/"/>
      <url>/2022/04/28/threadpool/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h1><h3 id="一、背景："><a href="#一、背景：" class="headerlink" title="一、背景："></a><strong>一、背景：</strong></h3><p>​        手动创建多个线程，会消耗过多内存且耗时长，最重要的是，频繁创建线程，在任务执行完毕之后被回收，对GC也有一定的压力。</p><p>​        线程池：创建线程变成了从线程池获取空闲的线程，关闭线程变成了向池子中归还线程。合理地使用线程池能够带来三个好处：</p><p>(1)降低内存资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>(2)提高响应速度。在线程池中的线程都是已经被创建好的，我们的任务直接获取一个空闲的线程就能够被执行了。</p><p>(3)提高线程的可管理性。使用线程池可以进行统一分配、调优和监控。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性。</p><h3 id="二、进程和线程"><a href="#二、进程和线程" class="headerlink" title="二、进程和线程"></a>二、<strong>进程和线程</strong></h3><p><strong>进程</strong>：在操作系统中能够独立运行，并且作为资源分配的基本单位，是应用程序的可执行单元(*.exe文件)  。一个应用程序可以有多个进程,每个进程都有独立的运行内存空间。系统运行一个应用程序就是一个进程从创建、运行到消亡的过程。</p><p><strong>线程</strong>：是一个比进程更小的执行单位，<strong>是进程的可执行单元</strong>, 也被称为轻量级进程。</p><p>一个进程可以有多个线程,每个线程都有独立的运行内存空间</p><h3 id="三、并行和并发"><a href="#三、并行和并发" class="headerlink" title="三、并行和并发"></a>三、<strong>并行和并发</strong></h3><p><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（<strong>同时执行</strong>）。</p><p><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生(<strong>交替执行</strong>)。</p><h3 id="四、线程池Thread-Pool"><a href="#四、线程池Thread-Pool" class="headerlink" title="四、线程池Thread Pool"></a>四、线程池Thread Pool</h3><p>​        线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后 启动这些任务，如果线程数量超过了最大数量   超出数量的线程排队等候   ，等其它线程执行完毕， 再从队列中取出任务来执行。  </p><p>   他的主要特点为：线程复用；控制最大并发数；管理线程   。  </p><p>  一般的线程池主要分为以下 4 个组成部分： </p><ol><li>线程池管理器：用于创建并管理线程池  </li><li>工作线程：线程池中的线程  </li><li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行  </li><li>任务队列：用于存放待处理的任务，提供一种缓冲机制 </li></ol><p>线程池作用：限制系统中执行线程的数量</p><h3 id="五、线程池作用"><a href="#五、线程池作用" class="headerlink" title="五、线程池作用"></a>五、线程池作用</h3><p>线程池主要作用为限制系统中执行线程的数量</p><ol><li><strong>降低资源消耗</strong>。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 </li></ol><h3 id="六、线程池工作的四种情况"><a href="#六、线程池工作的四种情况" class="headerlink" title="六、线程池工作的四种情况"></a><strong>六、线程池工作的四种情况</strong></h3><h4 id="1-主程序当前没有任务要执行，线程池中的任务队列为空闲状态"><a href="#1-主程序当前没有任务要执行，线程池中的任务队列为空闲状态" class="headerlink" title="1.主程序当前没有任务要执行，线程池中的任务队列为空闲状态"></a>1.<strong>主程序当前没有任务要执行，线程池中的任务队列为空闲状态</strong></h4><p>此情况下所有工作线程处于空闲的等待状态，任务缓冲队列为空</p><p><img src="/2022/04/28/threadpool/1.png" alt="任务队列和工作线程组空闲"></p><h4 id="2、主程序添加小于等于线程池中线程数量的任务"><a href="#2、主程序添加小于等于线程池中线程数量的任务" class="headerlink" title="2、主程序添加小于等于线程池中线程数量的任务."></a>2、主程序添加小于等于线程池中线程数量的任务.</h4><p>此情况基于情形1，所有工作线程已处在等待状态，主线程开始添加三个任务，添加后通知(notif())唤醒线程池中的线程开始取(take())任务执行. 此时的任务缓冲队列还是空。</p><p><img src="/2022/04/28/threadpool/2.png" alt="任务队列空，任务线程组非空"></p><h4 id="3、主程序添加任务数量大于当前线程池中线程数量的任务"><a href="#3、主程序添加任务数量大于当前线程池中线程数量的任务" class="headerlink" title="3、主程序添加任务数量大于当前线程池中线程数量的任务."></a>3、主程序添加任务数量大于当前线程池中线程数量的任务.</h4><p>此情况发生情形2后面，所有工作线程都在工作中，主线程开始添加第四个任务，添加后发现现在线程池中的线程用完了,于是存入任务缓冲队列。工作线程空闲后主动从任务队列取任务执行.</p><p><img src="/2022/04/28/threadpool/3.png" alt="工作线程组busy,任务队列阻塞"></p><h4 id="4、主程序添加任务数量大于当前线程池中线程数量的任务-且任务缓冲队列已满"><a href="#4、主程序添加任务数量大于当前线程池中线程数量的任务-且任务缓冲队列已满" class="headerlink" title="4、主程序添加任务数量大于当前线程池中线程数量的任务,且任务缓冲队列已满."></a>4、主程序添加任务数量大于当前线程池中线程数量的任务,且任务缓冲队列已满.</h4><p>此情况发生情形3且设置了任务缓冲队列大小后面，主程序添加第N个任务，添加后发现池子中的线程用完了，任务缓冲队列也满了，于是进入等待状态、等待任务缓冲队列中的任务腾空通知。<br>但是要注意这种情形会阻塞主线程,本篇暂不限制任务队列大小,必要时再来优化.</p><p><img src="/2022/04/28/threadpool/4.png" alt="任务队列和线程组均busy"></p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadPool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IC&amp;IT概念</title>
      <link href="/2022/04/28/ic-it-gai-nian/"/>
      <url>/2022/04/28/ic-it-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="IC-amp-IT概念"><a href="#IC-amp-IT概念" class="headerlink" title="IC&amp;IT概念"></a>IC&amp;IT概念</h2><ol><li><p><strong>操作系统</strong>（Operating System，OS）：是管理计算机硬件与软件资源的系统软件，同时也是计算机系统的内核与基石。操作系统需要处理管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p></li><li><p><strong>shell</strong>：它是一个程序，可从键盘获取命令并将其提供给操作系统以执行。在过去，它是类似 Unix 的系统上唯一可用的用户界面。如今，除了命令行界面（CLI）外，我们还具有图形用户界面（GUI）。</p></li><li><p><strong>GUI</strong> (Graphical User Interface)：是一种用户界面，允许用户通过图形图标和音频指示符与电子设备进行交互。</p></li><li><p><strong>内核模式</strong>（kernel mode）: 通常也被称为 超级模式（supervisor mode），在内核模式下，正在执行的代码具有对底层硬件的完整且不受限制的访问。它可以执行任何 CPU 指令并引用任何内存地址。内核模式通常保留给操作系统的最低级别，最受信任的功能。内核模式下的崩溃是灾难性的；他们将停止整个计算机。超级用户模式是计算机开机时选择的自动模式。</p></li><li><p><strong>用户模式</strong>（user node）：当操作系统运行用户应用程序（例如处理文本编辑器）时，系统处于用户模式。当应用程序请求操作系统的帮助或发生中断或系统调用时，就会发生从用户模式到内核模式的转换。在用户模式下，模式位设置为1。从用户模式切换到内核模式时，它从1更改为0。</p></li><li><p><strong>计算机架构</strong>(computer architecture) ：在计算机工程中，计算机体系结构是描述计算机系统功能，组织和实现的一组规则和方法。它主要包括指令集、内存管理、I/O 和总线结构。</p></li><li><p><strong>SATA</strong>(Serial ATA)：串行 ATA (Serial Advanced Technology Attachment)，它是一种电脑总线，负责主板和大容量存储设备（如硬盘及光盘驱动器）之间的数据传输，主要用于个人电脑。</p></li><li><p><strong>复用</strong>(multiplexing)：也称为共享，在操作系统中主要指示了时间和空间的管理。对资源进行复用时，不同的程序或用户轮流使用它。他们中的第一个开始使用资源，然后再使用另一个，依此类推。</p></li><li><p><strong>大型机</strong>(mainframes)：大型机是一类计算机，通常以其大尺寸，存储量，处理能力和高度的可靠性而著称。它们主要由大型组织用于需要大量数据处理的关键任务应用程序。</p></li><li><p><strong>批处理</strong>(batch system): 批处理操作系统的用户不直接与计算机进行交互。每个用户都在打孔卡等脱机设备上准备工作，并将其提交给计算机操作员。为了加快处理速度，将具有类似需求的作业一起批处理并成组运行。程序员将程序留给操作员，然后操作员将具有类似要求的程序分批处理。</p></li><li><p><strong>OS/360</strong>：OS/360，正式称为IBM System / 360操作系统，是由 IBM 为 1964 年发布的其当时新的System/360 大型机开发的已停产的批处理操作系统。</p></li><li><p><strong>多处理系统</strong>(Computer multitasking)：是指计算机同时运行多个程序的能力。多任务的一般方法是运行第一个程序的一段代码，保存工作环境；再运行第二个程序的一段代码，保存环境；……恢复第一个程序的工作环境，执行第一个程序的下一段代码。</p></li><li><p><strong>分时系统</strong>(Time-sharing)：在计算中，分时是通过多程序和多任务同时在许多用户之间共享计算资源的一种系统</p></li><li><p><strong>相容分时系统</strong>(Compatible Time-Sharing System)：最早的分时操作系统，由美国麻省理工学院计算机中心设计与实作。</p></li><li><p><strong>云计算</strong>(cloud computing)：云计算是计算机系统资源（尤其是数据存储和计算能力）的按需可用性，而无需用户直接进行主动管理。这个术语通常用于描述 Internet 上可供许多用户使用的数据中心。如今占主导地位的大型云通常具有从中央服务器分布在多个位置的功能。如果与用户的连接相对较近，则可以将其指定为边缘服务器。</p></li><li><p><strong>UNIX 操作系统</strong>：UNIX 操作系统，是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统。</p></li><li><p><strong>UNIX System V</strong>：是 UNIX 操作系统的一个分支。</p></li><li><p><strong>BSD</strong>(Berkeley Software Distribution)：UNIX 的衍生系统。</p></li><li><p><strong>POSIX</strong>：可移植操作系统接口，是 IEEE 为要在各种 UNIX 操作系统上运行软件，而定义API的一系列互相关联的标准的总称。</p></li><li><p><strong>MINIX</strong>：Minix，是一个迷你版本的类 UNIX 操作系统。</p></li><li><p><strong>Linux</strong>：终于到了大名鼎鼎的 Linux 操作系统了，太强大了，不予以解释了，大家都懂。</p></li><li><p><strong>DOS</strong> (Disk Operating System)：磁盘操作系统（缩写为DOS）是可以使用磁盘存储设备（例如软盘，硬盘驱动器或光盘）的计算机操作系统。</p></li><li><p><strong>MS-DOS</strong>(MicroSoft Disk Operating System) ：一个由美国微软公司发展的操作系统，运行在Intel x86个人电脑上。它是DOS操作系统家族中最著名的一个，在Windows 95以前，DOS是IBM PC及兼容机中的最基本配备，而MS-DOS则是个人电脑中最普遍使用的DOS操作系统。</p></li><li><p><strong>MacOS X</strong>，怎能少的了苹果操作系统？macOS 是苹果公司推出的基于图形用户界面操作系统，为 Macintosh 的主操作系统。</p></li><li><p><strong>Windows NT</strong>(Windows New Technology)：是美国微软公司 1993 年推出的纯 32 位操作系统核心。</p></li><li><p><strong>Service Pack</strong>(SP)：是程序的更新、修复和（或）增强的集合，以一个独立的安装包的形式发布。许多公司，如微软或Autodesk，通常在为某一程序而做的修补程序达到一定数量时，就发布一个Service Pack。</p></li><li><p><strong>数字版权管理</strong>（DRM）：他是工具或技术保护措施（TPM）是一组访问控制技术，用于限制对专有硬件和受版权保护的作品的使用。</p></li><li><p><strong>x86</strong>：x86是一整套指令集体系结构，由 Intel 最初基于 Intel 8086 微处理器及其 8088 变体开发。采用内存分段作为解决方案，用于处理比普通 16 位地址可以覆盖的更多内存。32 位是 x86 默认的位数，除此之外，还有一个 x86-64 位，是x86架构的 64 位拓展，向后兼容于 16 位及 32 位的 x86架构。</p></li><li><p><strong>FreeBSD</strong>：FreeBSD 是一个类 UNIX 的操作系统，也是 FreeBSD 项目的发展成果。</p></li><li><p><strong>X Window System</strong>：X 窗口系统（X11，或简称X）是用于位图显示的窗口系统，在类 UNIX 操作系统上很常见。</p></li><li><p><strong>Gnome</strong>：GNOME 是一个完全由自由软件组成的桌面环境。它的目标操作系统是Linux，但是大部分的 BSD 系统亦支持 GNOME。</p></li><li><p><strong>网络操作系统</strong>(network operating systems)：网络操作系统是用于网络设备（如路由器，交换机或防火墙）的专用操作系统。</p></li><li><p><strong>分布式网络系统</strong>(distributed operating systems)：分布式操作系统是在独立，网络，通信和物理上独立计算节点的集合上的软件。它们处理由多个CPU服务的作业。每个单独的节点都拥有全局集合操作系统的特定软件的一部分。</p></li><li><p><strong>程序计数器</strong>(Program counter)：程序计数器 是一个 CPU 中的寄存器，用于指示计算机在其程序序列中的位置。</p></li><li><p><strong>堆栈寄存器</strong>(stack pointer)：堆栈寄存器是计算机 CPU 中的寄存器，其目的是跟踪调用堆栈。</p></li><li><p><strong>程序状态字</strong>(Program Status Word): 它是由操作系统维护的8个字节（或64位）长的数据的集合。它跟踪系统的当前状态。</p></li><li><p><strong>流水线</strong>(Pipeline): 在计算世界中，管道是一组串联连接的数据处理元素，其中一个元素的输出是下一个元素的输入。流水线的元素通常以并行或按时间分割的方式执行。通常在元素之间插入一定数量的缓冲区存储。</p></li><li><p><strong>超标量</strong>(superscalar)：超标量 CPU 架构是指在一颗处理器内核中实行了指令级并发的一类并发运算。这种技术能够在相同的CPU主频下实现更高的 CPU 流量。</p></li><li><p><strong>系统调用</strong>(system call):  指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态运行。如设备 IO 操作或者进程间通信。</p></li><li><p><strong>多线程</strong>(multithreading)：是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因为有硬件支持而能够在同一时间执行多个线程，进而提升整体处理性能。</p></li><li><p><strong>CPU 核心</strong>(core)：它是 CPU 的大脑，它接收指令，并执行计算或运算以满足这些指令。一个 CPU 可以有多个内核。</p></li><li><p><strong>图形处理器</strong>(Graphics Processing Unit)：又称显示核心、视觉处理器、显示芯片或绘图芯片；它是一种专门在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上运行绘图运算工作的微处理器。</p></li><li><p><strong>存储体系结构</strong>：顶层的存储器速度最高，但是容量最小，成本非常高，层级结构越向下，其访问效率越慢，容量越大，但是造价也就越便宜。</p></li><li><p><strong>高速缓存行</strong>(cache lines)：其实就是把高速缓存分割成了固定大小的块，其大小是以突发读或者突发写周期的大小为基础的。</p></li></ol><p><img src="/2022/04/28/ic-it-gai-nian/1.png" alt="存储层次结构"></p><ol start="45"><li><strong>缓存命中</strong>(cache hit)：当应用程序或软件请求数据时，会首先发生缓存命中。首先，中央处理单元（CPU）在其最近的内存位置（通常是主缓存）中查找数据。如果在缓存中找到请求的数据，则将其视为缓存命中。</li></ol><p><img src="/2022/04/28/ic-it-gai-nian/2.png" alt="存储器层次结构示例"></p><ol start="46"><li><p><strong>L1 cache</strong>：一级缓存是 CPU 芯片中内置的存储库。L1缓存也称为主缓存，是计算机中最快的内存，并且最接近处理器。</p></li><li><p><strong>L2 cache</strong>: 二级缓存存储库，内置在 CPU 芯片中，包装在同一模块中，或者建在主板上。L2 高速缓存提供给 L1 高速缓存，后者提供给处理器。L2 内存比 L1 内存慢。</p></li><li><p><strong>L3 cache</strong>: 三级缓存内置在主板上或CPU模块内的存储库。L3 高速缓存为 L2 高速缓存提供数据，其内存通常比 L2 内存慢，但比主内存快。L3 高速缓存提供给 L2 高速缓存，后者又提供给 L1 高速缓存，后者又提供给处理器。</p></li><li><p><strong>RAM</strong>(Random Access Memory)：随机存取存储器，也叫主存，是与 CPU 直接交换数据的内部存储器。它可以随时读写，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质。RAM工作时可以随时从任何一个指定的地址写入（存入）或读出（取出）信息。它与 ROM 的最大区别是数据的易失性，即一旦断电所存储的数据将随之丢失。RAM 在计算机和数字系统中用来暂时存储程序、数据和中间结果。</p></li><li><p><strong>ROM</strong> (Read Only Memory)：只读存储器是一种半导体存储器，其特性是一旦存储数据就无法改变或删除，且内容不会因为电源关闭而消失。在电子或电脑系统中，通常用以存储不需经常变更的程序或数据。</p></li><li><p><strong>EEPROM</strong> (Electrically Erasable PROM)：电可擦除可编程只读存储器，是一种可以通过电子方式多次复写的半导体存储设备。</p></li><li><p><strong>闪存</strong>(flash memory)：是一种电子式可清除程序化只读存储器的形式，允许在操作中被多次擦或写的存储器。这种科技主要用于一般性数据存储，以及在电脑与其他数字产品间交换传输数据，如储存卡与U盘。</p></li><li><p><strong>SSD</strong>(Solid State Disks)：固态硬盘，是一种主要以闪存作为永久性存储器的电脑存储设备。</p></li><li><p><strong>虚拟地址</strong>(virtual memory)：虚拟内存是计算机系统内存管理的一种机制。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。</p></li><li><p><strong>MMU</strong> (Memory Management Unit)：内存管理单元，有时称作分页内存管理单元。它是一种负责处理中央处理器（CPU）的内存访问请求的计算机硬件。它的功能包括虚拟地址到物理地址的转换（即虚拟内存管理）、内存保护、中央处理器高速缓存的控制等。</p></li><li><p><strong>context switch</strong>：上下文切换，又称环境切换。是一个存储和重建 CPU 状态的机制。要交换 CPU 上的进程时，必须先行存储当前进程的状态，然后再将进程状态读回 CPU 中。</p></li><li><p><strong>驱动程序</strong>(device driver)：设备驱动程序，简称驱动程序（driver），是一个允许高级别电脑软件与硬件交互的程序，这种程序创建了一个硬件与硬件，或硬件与软件沟通的接口，经由主板上的总线或其它沟通子系统与硬件形成连接的机制，这样使得硬件设备上的数据交换成为可能。</p></li></ol><p>\58. <strong>忙等</strong>(busy waiting)：在软件工程中，忙碌等待也称自旋，是一种以进程反复检查一个条件是否为真的条件，这种机制可能为检查键盘输入或某个锁是否可用。</p><ol start="59"><li><p><strong>中断</strong>(Interrupt)：通常，在接收到来自外围硬件（相对于中央处理器和内存）的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件／软件处理。发出这样的信号称为进行中断请求（interrupt request，IRQ）。硬件中断导致处理器通过一个运行信息切换（context switch）来保存执行状态（以程序计数器和程序状态字等寄存器信息为主）；软件中断则通常作为 CPU 指令集中的一个指令，以可编程的方式直接指示这种运行信息切换，并将处理导向一段中断处理代码。中断在计算机多任务处理，尤其是即时系统中尤为有用。</p></li><li><p><strong>中断向量</strong>(interrupt vector)：中断向量位于中断向量表中。中断向量表（IVT）是将中断处理程序列表与中断向量表中的中断请求列表相关联的数据结构。中断向量表的每个条目（称为中断向量）都是中断处理程序的地址。</p></li><li><p><strong>DMA</strong> (Direct Memory Access)：直接内存访问，直接内存访问是计算机科学中的一种内存访问技术。它允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，而不需中央处理器（CPU）介入处理 。</p></li></ol><p>\62. <strong>总线</strong>(Bus)：总线（Bus）是指计算机组件间规范化的交换数据的方式，即以一种通用的方式为各组件提供数据传送和控制逻辑。</p><ol start="63"><li><p><strong>PCIe</strong> (Peripheral Component Interconnect Express)：官方简称PCIe，是计算机总线的一个重要分支，它沿用现有的PCI编程概念及信号标准，并且构建了更加高速的串行通信系统标准。</p></li><li><p><strong>DMI</strong> (Direct Media Interface)：直接媒体接口，是英特尔专用的总线，用于电脑主板上南桥芯片和北桥芯片之间的连接。</p></li><li><p><strong>USB</strong>(Universal Serial Bus)：是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范，被广泛地应用于个人电脑和移动设备等信息通讯产品，并扩展至摄影器材、数字电视（机顶盒）、游戏机等其它相关领域。</p></li><li><p><strong>BIOS</strong>(Basic Input Output System)：是在通电引导阶段运行硬件初始化，以及为操作系统提供运行时服务的固件。它是开机时运行的第一个软件。</p></li><li><p><strong>硬实时系统</strong>(hard real-time system)：硬实时性意味着你必须绝对在每个截止日期前完成任务。很少有系统有此要求。例如核系统，一些医疗应用（例如起搏器），大量国防应用，航空电子设备等。</p></li><li><p><strong>软实时系统</strong>(soft real-time system)：软实时系统可能会错过某些截止日期，但是如果错过太多，最终性能将下降。一个很好的例子是计算机中的声音系统。</p></li><li><p><strong>进程</strong>(Process)：程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。若进程有可能与同一个程序相关系，且每个进程皆可以同步（循序）或异步的方式独立运行。</p></li><li><p><strong>地址空间</strong>(address space)：地址空间是内存中可供程序或进程使用的有效地址范围。也就是说，它是程序或进程可以访问的内存。存储器可以是物理的也可以是虚拟的，用于执行指令和存储数据。</p></li><li><p><strong>进程表</strong>(process table)：进程表是操作系统维护的数据结构，该表中的每个条目（通常称为上下文块）均包含有关进程的信息，例如进程名称和状态，优先级，寄存器以及它可能正在等待的信号灯。</p></li><li><p><strong>命令行界面</strong>(command-line interpreter)：是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。</p></li><li><p><strong>进程间通信</strong>(interprocess communication)：指至少两个进程或线程间传送数据或信号的一些技术或方法。</p></li><li><p><strong>超级用户</strong>(superuser)：也被称为管理员帐户，在计算机操作系统领域中指一种用于进行系统管理的特殊用户，其在系统中的实际名称也因系统而异，如 root、administrator 与supervisor。</p></li><li><p><strong>目录</strong>(directory):  在计算机或相关设备中，一个目录或文件夹就是一个装有数字文件系统的虚拟容器。在它里面保存着一组文件和其它一些目录。</p></li><li><p><strong>路径</strong>(path name)：路径是一种电脑文件或目录的名称的通用表现形式，它指向文件系统上的一个唯一位置。</p></li><li><p><strong>根目录</strong>(root directory)：根目录指的就是计算机系统中的顶层目录，比如 Windows 中的 C 盘和 D 盘，Linux 中的 /。</p></li><li><p><strong>工作目录</strong>(Working directory)：它是一个计算机用语。用户在操作系统内所在的目录，用户可在此目录之下，用相对文件名访问文件。</p></li><li><p><strong>文件描述符</strong>(file descriptor)：文件描述符是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p></li><li><p><strong>inode</strong>：索引节点的缩写，索引节点是 UNIX 系统中包含的信息，其中包含有关每个文件的详细信息，例如节点，所有者，文件，文件位置等。</p></li><li><p><strong>共享库</strong>(shared library)：共享库是一个包含目标代码的文件，执行过程中多个 a.out 文件可能会同时使用该目标代码。</p></li><li><p><strong>DLLs</strong> (Dynamic-Link Libraries)：动态链接库，它是微软公司在操作系统中实现共享函数库概念的一种实现方式。这些库函数的扩展名是 .DLL、.OCX（包含ActiveX控制的库）或者.DRV（旧式的系统驱动程序）。</p></li><li><p><strong>客户端</strong>(clients)：客户端是访问服务器提供的服务的计算机硬件或软件。</p></li><li><p><strong>服务端</strong>(servers)：在计算中，服务器是为其他程序或设备提供功能的计算机程序或设备，称为服务端</p></li><li><p><strong>主从架构</strong>(client-server)：主从式架构也称客户端/服务器架构、C/S 架构，是一种网络架构，它把客户端与服务器区分开来。每一个客户端软件的实例都可以向一个服务器或应用程序服务器发出请求。有很多不同类型的服务器，例如文件服务器、游戏服务器等。</p></li><li><p><strong>虚拟机</strong>(Virtual Machines)：在计算机科学中的体系结构里，是指一种特殊的软件，可以在计算机平台和终端用户之间创建一种环境，而终端用户则是基于虚拟机这个软件所创建的环境来操作其它软件。</p></li><li><p><strong>Java 虚拟机</strong>(Java virtual Machines)：Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p></li><li><p><strong>目标文件</strong>(object file)：目标文件是包含目标代码的文件，这意味着通常无法直接执行的可重定位格式的机器代码。目标文件有多种格式，相同的目标代码可以打包在不同的目标文件中。目标文件也可以像共享库一样工作。</p></li><li><p><strong>C preprocessor</strong>：C 预处理器是 C 语言、C++ 语言的预处理器。用于在编译器处理程序之前预扫描源代码，完成头文件的包含, 宏扩展, 条件编译, 行控制等操作。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下使用MinGW编译boost库</title>
      <link href="/2022/04/15/windows-xia-shi-yong-mingw-bian-yi-boost-ku/"/>
      <url>/2022/04/15/windows-xia-shi-yong-mingw-bian-yi-boost-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows下使用MinGW编译boost库"><a href="#Windows下使用MinGW编译boost库" class="headerlink" title="Windows下使用MinGW编译boost库"></a>Windows下使用MinGW编译boost库</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>​        解压并打开boost源码目录，</p><pre class="line-numbers language-none"><code class="language-none">call .\build.bat 改成 call .\build.bat gccSET TOOLSET=msvc 改成 SET TOOLSET=gcc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        执行bootstrap.bat批处理文件，会在目录内产生一个b2.exe文件。在目录文件夹，按住shift键+鼠标右键，选择“在此处打开PowerShell窗口”（或“在此处打开控制台窗口”），执行指令：</p><pre class="line-numbers language-none"><code class="language-none">./b2.exe --help <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会列出关于boost的编译选项，其主要选项如下：</p><pre class="line-numbers language-none"><code class="language-none">--prefix=&lt;PREFIX&gt;   编译后安装路径，默认C:\Boost--build-type=&lt;type&gt; 编译类型，可选minimal（最小）、complete（完整），默认minimal。--with-&lt;library&gt;    加入此参数，代表只编译的库。--without-&lt;library&gt; 加入此参数，代表忽略编译的库。toolset             编译器，win下默认msvc，用MinGW则选择gcc。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此编译参数可设置为：</p><pre class="line-numbers language-none"><code class="language-none">./b2.exe install --prefix=E:\boost\boost_1_76_0_mingw --build-type=complete toolset=gcc threading=multi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数解析：完整编译（会编译包含/不包含运行时库的debug/release的动态/静态库），编译器选择MinGW（gcc），多线程，编译完成后将库和头文件复制到D:\boost\boost_1.65.1_mingw路径。</p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> boost </tag>
            
            <tag> MinGW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread.sleep(0)的作用</title>
      <link href="/2022/04/14/thread.sleep-0-de-zuo-yong/"/>
      <url>/2022/04/14/thread.sleep-0-de-zuo-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Thread-sleep-0-的作用"><a href="#Thread-sleep-0-的作用" class="headerlink" title="Thread.sleep(0)的作用"></a>Thread.sleep(0)的作用</h1><p>我们可能经常会用到 Thread.Sleep 函数来吧使线程挂起一段时间。那么你有没有正确的理解这个函数的用法呢？<br>思考下面这两个问题：</p><p>假设现在是 2008-4-7 12:00:00.000，如果我调用一下 Thread.Sleep(1000) ，在 2008-4-7 12:00:01.000 的时候，这个线程会不会被唤醒？</p><p>某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？</p><p>我们先回顾一下操作系统原理。</p><p>操作系统中，CPU竞争有很多种策略。Unix系统使用的是时间片算法，而Windows则属于抢占式的。</p><p>在时间片算法中，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程 序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。</p><p>所谓抢占式操作系统，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。因此可以看出，在抢 占式操作系统中，操作系统假设所有的进程都是“人品很好”的，会主动退出 CPU 。</p><p>在抢占式操作系统中，假设有若干进程，操作系统会根据他们的优先级、饥饿时间（已经多长时间没有使用过 CPU 了），给他们算出一 个总的优先级来。操作系统就会把 CPU 交给总优先级最高的这个进程。当进程执行完毕或者自己主动挂起后，操作系统就会重新计算一 次所有进程的总优先级，然后再挑一个优先级最高的把 CPU 控制权交给他。</p><p>我们用分蛋糕的场景来描述这两种算法。假设有源源不断的蛋糕（源源不断的时间），一副刀叉（一个CPU），10个等待吃蛋糕的人（10 个进程）。</p><p>如果是 Unix操作系统来负责分蛋糕，那么他会这样定规矩：每个人上来吃 1 分钟，时间到了换下一个。最后一个人吃完了就再从头开始。于是，不管这10个人是不是优先级不同、饥饿程度不同、饭量不同，每个人上来的时候都可以吃 1 分钟。当然，如果有人本来不太饿，或者饭量小，吃了30秒钟之后就吃饱了，那么他可以跟操作系统说：我已经吃饱了（挂起）。于是操作系统就会让下一个人接着来。</p><p>如果是 Windows 操作系统来负责分蛋糕的，那么场面就很有意思了。他会这样定规矩：我会根据你们的优先级、饥饿程度去给你们每个人计算一个优先级。优先级最高的那个人，可以上来吃蛋糕——吃到你不想吃为止。等这个人吃完了，我再重新根据优先级、饥饿程度来计算每个人的优先级，然后再分给优先级最高的那个人。</p><p>这样看来，这个场面就有意思了——可能有些人是PPMM，因此具有高优先级，于是她就可以经常来吃蛋糕。可能另外一个人是个丑男，而去很ws，所以优先级特别低，于是好半天了才轮到他一次（因为随着时间的推移，他会越来越饥饿，因此算出来的总优先级就会越来越高，因此总有一天会轮到他的）。而且，如果一不小心让一个大胖子得到了刀叉，因为他饭量大，可能他会霸占着蛋糕连续吃很久很久，导致旁边的人在那里咽口水。。。</p><p>而且，还可能会有这种情况出现：操作系统现在计算出来的结果，5号PPMM总优先级最高，而且高出别人一大截。因此就叫5号来吃蛋糕。5号吃了一小会儿，觉得没那么饿了，于是说“我不吃了”（挂起）。，因此操作系统就会重新计算所有人的优先级。</p><p>因为5号刚刚吃过，因此她的饥饿程度变小了，于是总优先级变小了；而其他人因为多等了一会儿，饥饿程度都变大了，所以总优先级也变大了。不过这时候仍然有可能5号的优先级比别的都高，只不过现在只比其他的高一点点——但她仍然是总优先级最高的啊。因此操作系统就会说：5号mm上来吃蛋糕……（5号mm心里郁闷，这不刚吃过嘛……人家要减肥……谁叫你长那么漂亮，获得了那么高的优先级）。</p><p>那么，Thread.Sleep 函数是干吗的呢？还用刚才的分蛋糕的场景来描述。上面的场景里面，5号MM在吃了一次蛋糕之后，觉得已经有8分饱了，她觉得在未来的半个小时之内都不想再来吃蛋糕了，那么她就会跟操作系统说：在未来的半个小时之内不要再叫我上来吃蛋糕了。</p><p>这样，操作系统在随后的半个小时里面重新计算所有人总优先级的时候，就会忽略5号mm。Sleep函数就是干这事的，他告诉操作系统“在未来的多少毫秒内我不参与CPU竞争”。</p><p>看完了 Thread.Sleep 的作用，我们再来想想文章开头的两个问题。</p><p>对于第一个问题，答案是：不一定。因为你只是告诉操作系统：在未来的1000毫秒内我不想再参与到CPU竞争。那么1000毫秒过去之后，这时候也许另外一个线程正在使用CPU，那么这时候操作系统是不会重新分配CPU的，直到那个线程挂起或结束；况且，即使这个时候恰巧轮到操作系统进行CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU还是可能被其他线程抢占去。</p><p>与此相似的，Thread有个Resume函数，是用来唤醒挂起的线程的。好像上面所说的一样，这个函数只是“告诉操作系统我从现在起开始参与CPU竞争了”，这个函数的调用并不能马上使得这个线程获得CPU控制权。</p><p>对于第二个问题，答案是：有，而且区别很明显。假设我们刚才的分蛋糕场景里面，有另外一个PPMM 7号，她的优先级也非常非常高（因为非常非常漂亮），所以操作系统总是会叫道她来吃蛋糕。而且，7号也非常喜欢吃蛋糕，而且饭量也很大。不过，7号人品很好，她很善良，她没吃几口就会想：如果现在有别人比我更需要吃蛋糕，那么我就让给他。</p><p>因此，她可以每吃几口就跟操作系统说：我们来重新计算一下所有人的总优先级吧。不过，操作系统不接受这个建议——因为操作系统不提供这个接口。于是7号mm就换了个说法：“在未来的0毫秒之内不要再叫我上来吃蛋糕了”。这个指令操作系统是接受的，于是此时操作系统就会重新计算大家的总优先级——注意这个时候是连7号一起计算的，因为“0毫秒已经过去了”嘛。因此如果没有比7号更需要吃蛋糕的人出现，那么下一次7号还是会被叫上来吃蛋糕。</p><p>因此，Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。这也是我们在大循环里面经常会写一句Thread.Sleep(0) ，因为这样就给了其他线程比如Paint线程获得CPU控制权的权力，这样界面就不会假死在那里。</p><p>另外，虽然上面提到说“除非它自己放弃使用 CPU ，否则将完全霸占 CPU”，但这个行为仍然是受到制约的——操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。至于我们的大循环造成程序假死，并不是因为这个线程一直在霸占着CPU。</p><p>实际上在这段时间操作系统已经进行过多次CPU竞争了，只不过其他线程在获得CPU控制权之后很短时间内马上就退出了，于是就又轮到了这个线程继续执行循环，于是就又用了很久才被操作系统强制挂起。。。因此反应到界面上，看起来就好像这个线程一直在霸占着CPU一样。</p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sleep(0) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Protocol Buffers</title>
      <link href="/2022/04/13/protocol-bian-yi-an-zhuang/"/>
      <url>/2022/04/13/protocol-bian-yi-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="Protocol-Buffers-Google’s-data-interchange-format"><a href="#Protocol-Buffers-Google’s-data-interchange-format" class="headerlink" title="Protocol Buffers - Google’s data interchange format"></a>Protocol Buffers - Google’s data interchange format</h1><p>Copyright 2008 Google Inc.</p><p><a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p><h2 id="C-Installation-Unix"><a href="#C-Installation-Unix" class="headerlink" title="C++ Installation - Unix"></a>C++ Installation - Unix</h2><p>To build protobuf from source, the following tools are needed:</p><ul><li>autoconf</li><li>automake</li><li>libtool</li><li>make</li><li>g++</li><li>unzip</li></ul><p>On Ubuntu/Debian, you can install them with:</p><pre><code>sudo apt-get install autoconf automake libtool curl make g++ unzip</code></pre><p>On other platforms, please use the corresponding package managing tool to<br>install them before proceeding.</p><p>To get the source, download one of the release .tar.gz or .zip packages in the<br>release page:</p><pre><code>https://github.com/protocolbuffers/protobuf/releases/latest</code></pre><p>For example: if you only need C++, download <code>protobuf-cpp-[VERSION].tar.gz</code>; if<br>you need C++ and Java, download <code>protobuf-java-[VERSION].tar.gz</code> (every package<br>contains C++ source already); if you need C++ and multiple other languages,<br>download <code>protobuf-all-[VERSION].tar.gz</code>.</p><p>You can also get the source by “git clone” our git repository. Make sure you<br>have also cloned the submodules and generated the configure script (skip this<br>if you are using a release .tar.gz or .zip package):</p><pre><code>git clone https://github.com/protocolbuffers/protobuf.gitcd protobufgit submodule update --init --recursive./autogen.sh</code></pre><p>To build and install the C++ Protocol Buffer runtime and the Protocol<br>Buffer compiler (protoc) execute the following:</p><pre><code> ./configure make make check sudo make install sudo ldconfig # refresh shared library cache.</code></pre><p>If “make check” fails, you can still install, but it is likely that<br>some features of this library will not work correctly on your system.<br>Proceed at your own risk.</p><p>For advanced usage information on configure and make, please refer to the<br>autoconf documentation:</p><pre><code>http://www.gnu.org/software/autoconf/manual/autoconf.html#Running-configure-Scripts</code></pre><p><strong>Hint on install location</strong></p><p>By default, the package will be installed to /usr/local.  However,<br>on many platforms, /usr/local/lib is not part of LD_LIBRARY_PATH.<br>You can add it, but it may be easier to just install to /usr<br>instead.  To do this, invoke configure as follows:</p><pre><code>./configure --prefix=/usr</code></pre><p>If you already built the package with a different prefix, make sure<br>to run “make clean” before building again.</p><p><strong>Compiling dependent packages</strong></p><p>To compile a package that uses Protocol Buffers, you need to pass<br>various flags to your compiler and linker.  As of version 2.2.0,<br>Protocol Buffers integrates with pkg-config to manage this.  If you<br>have pkg-config installed, then you can invoke it to get a list of<br>flags like so:</p><pre><code>pkg-config --cflags protobuf         # print compiler flagspkg-config --libs protobuf           # print linker flagspkg-config --cflags --libs protobuf  # print both</code></pre><p>For example:</p><pre><code>c++ my_program.cc my_proto.pb.cc `pkg-config --cflags --libs protobuf`</code></pre><p>Note that packages written prior to the 2.2.0 release of Protocol<br>Buffers may not yet integrate with pkg-config to get flags, and may<br>not pass the correct set of flags to correctly link against<br>libprotobuf.  If the package in question uses autoconf, you can<br>often fix the problem by invoking its configure script like:</p><pre><code>configure CXXFLAGS="$(pkg-config --cflags protobuf)" \          LIBS="$(pkg-config --libs protobuf)"</code></pre><p>This will force it to use the correct flags.</p><p>If you are writing an autoconf-based package that uses Protocol<br>Buffers, you should probably use the PKG_CHECK_MODULES macro in your<br>configure script like:</p><pre><code>PKG_CHECK_MODULES([protobuf], [protobuf])</code></pre><p>See the pkg-config man page for more info.</p><p>If you only want protobuf-lite, substitute “protobuf-lite” in place<br>of “protobuf” in these examples.</p><p><strong>Note for Mac users</strong></p><p>For a Mac system, Unix tools are not available by default. You will first need<br>to install Xcode from the Mac AppStore and then run the following command from<br>a terminal:</p><pre><code>sudo xcode-select --install</code></pre><p>To install Unix tools, you can install “port” following the instructions at<br><a href="https://www.macports.org/">https://www.macports.org</a> . This will reside in /opt/local/bin/port for most<br>Mac installations.</p><pre><code>sudo /opt/local/bin/port install autoconf automake libtool</code></pre><p>Then follow the Unix instructions above.</p><p><strong>Note for cross-compiling</strong></p><p>The makefiles normally invoke the protoc executable that they just<br>built in order to build tests.  When cross-compiling, the protoc<br>executable may not be executable on the host machine.  In this case,<br>you must build a copy of protoc for the host machine first, then use<br>the –with-protoc option to tell configure to use it instead.  For<br>example:</p><pre><code>./configure --with-protoc=protoc</code></pre><p>This will use the installed protoc (found in your $PATH) instead of<br>trying to execute the one built during the build process.  You can<br>also use an executable that hasn’t been installed.  For example, if<br>you built the protobuf package for your host machine in ../host,<br>you might do:</p><pre><code>./configure --with-protoc=../host/src/protoc</code></pre><p>Either way, you must make sure that the protoc executable you use<br>has the same version as the protobuf source code you are trying to<br>use it with.</p><p><strong>Note for Solaris users</strong></p><p>Solaris 10 x86 has a bug that will make linking fail, complaining<br>about libstdc++.la being invalid.  We have included a work-around<br>in this package.  To use the work-around, run configure as follows:</p><pre><code>./configure LDFLAGS=-L$PWD/src/solaris</code></pre><p>See src/solaris/libstdc++.la for more info on this bug.</p><p><strong>Note for HP C++ Tru64 users</strong></p><p>To compile invoke configure as follows:</p><pre><code>./configure CXXFLAGS="-O -std ansi -ieee -D__USE_STD_IOSTREAM"</code></pre><p>Also, you will need to use gmake instead of make.</p><p><strong>Note for AIX users</strong></p><p>Compile using the IBM xlC C++ compiler as follows:</p><pre><code>./configure CXX=xlC</code></pre><p>Also, you will need to use GNU <code>make</code> (<code>gmake</code>) instead of AIX <code>make</code>.</p><h2 id="C-Installation-Windows"><a href="#C-Installation-Windows" class="headerlink" title="C++ Installation - Windows"></a>C++ Installation - Windows</h2><p>If you only need the protoc binary, you can download it from the release<br>page:</p><pre><code>https://github.com/protocolbuffers/protobuf/releases/latest</code></pre><p>In the downloads section, download the zip file protoc-$VERSION-win32.zip.<br>It contains the protoc binary as well as public proto files of protobuf<br>library.</p><p>Protobuf and its dependencies can be installed directly by using <code>vcpkg</code>:</p><pre><code>&gt;vcpkg install protobuf protobuf:x64-windows</code></pre><p>If zlib support is desired, you’ll also need to install the zlib feature:</p><pre><code>&gt;vcpkg install protobuf[zlib] protobuf[zlib]:x64-windows</code></pre><p>See <a href="https://github.com/Microsoft/vcpkg">https://github.com/Microsoft/vcpkg</a> for more information.</p><p>To build from source using Microsoft Visual C++, see <a href="../cmake/README.md">cmake/README.md</a>.</p><p>To build from source using Cygwin or MinGW, follow the Unix installation<br>instructions, above.</p><h2 id="Binary-Compatibility-Warning"><a href="#Binary-Compatibility-Warning" class="headerlink" title="Binary Compatibility Warning"></a>Binary Compatibility Warning</h2><p>Due to the nature of C++, it is unlikely that any two versions of the<br>Protocol Buffers C++ runtime libraries will have compatible ABIs.<br>That is, if you linked an executable against an older version of<br>libprotobuf, it is unlikely to work with a newer version without<br>re-compiling.  This problem, when it occurs, will normally be detected<br>immediately on startup of your app.  Still, you may want to consider<br>using static linkage.  You can configure this package to install<br>static libraries only using:</p><pre><code>./configure --disable-shared</code></pre><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>The complete documentation for Protocol Buffers is available via the<br>web at:</p><p><a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Protocol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo</title>
      <link href="/2022/04/12/note-hexo/"/>
      <url>/2022/04/12/note-hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="一、常用命令"><a href="#一、常用命令" class="headerlink" title="一、常用命令"></a>一、常用命令</h2><h3 id="hexo-init"><a href="#hexo-init" class="headerlink" title="hexo init"></a>hexo init</h3><p><code>hexo init</code> 命令用于初始化本地文件夹为网站的根目录</p><pre class="line-numbers language-none"><code class="language-none">$ hexo init [folder]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Hexo-s"><a href="#Hexo-s" class="headerlink" title="Hexo s"></a>Hexo s</h3><pre class="line-numbers language-none"><code class="language-none">$ hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/">http://localhost:4000/</a></p><ul><li>hexo s 是 hexo server 的缩写，命令效果一致；</li><li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</li><li>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。</li></ul><h3 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a><strong>hexo new</strong></h3><pre class="line-numbers language-none"><code class="language-none">$ hexo new "学习笔记  六"  //hexo new [layout] &lt;title&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建一篇标题为 学习笔记 六 的文章，因为标题里有空格，所以加上了引号。</p><ul><li>文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。</li><li><code>layout</code>指定文章的布局，默认<code>Post</code> ，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局</li><li>此命令会在/source/_posts下创建一个文件名 <code>title.md</code>文件，然后就可以使用<code>markdown</code>编辑器开始写自己的博客了。</li></ul><h3 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a><strong>hexo d</strong></h3><pre class="line-numbers language-none"><code class="language-none">$ hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>自动生成网站静态文件，并部署到设定的仓库（<a href="https://moomq.github.io/%EF%BC%89%E3%80%82">https://moomq.github.io/）。</a></p><ul><li>hexo d 是 hexo deploy 的缩写，命令效果一致。</li></ul><h3 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a><strong>hexo clean</strong></h3><pre class="line-numbers language-none"><code class="language-none">$ hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>清除缓存文件 db.json 和已生成的静态文件 public 。</p><ul><li>网站显示异常时可以执行这条命令试试。</li></ul><h3 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a><strong>hexo g</strong></h3><pre class="line-numbers language-none"><code class="language-none">$ hexo g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成网站静态文件到默认设置的 public 文件夹。</p><ul><li>便于查看网站生成的静态文件或者手动部署网站；</li><li>如果使用自动部署，不需要先执行该命令；</li><li>hexo g 是 hexo generate 的缩写，命令效果一致。</li></ul><h3 id="hexo-new-page"><a href="#hexo-new-page" class="headerlink" title="hexo new page"></a><strong>hexo new page</strong></h3><pre class="line-numbers language-none"><code class="language-none">$ hexo new page aboutme<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建一个标题为 aboutme 的页面，默认链接地址为 主页地址/aboutme/</p><ul><li>标题可以为中文，但一般习惯用英文；</li><li>页面标题和文章一样可以随意修改；</li><li>页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。</li></ul><h3 id="hexo-–safe"><a href="#hexo-–safe" class="headerlink" title="hexo –safe"></a>hexo –safe</h3><p><code>hexo --safe</code> 表示安全模式，用于禁用加载插件和脚本，<strong>安装新插件时遇到问题可尝试此操作</strong></p><pre class="line-numbers language-none"><code class="language-none">$ hexo --safe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="hexo-–debug"><a href="#hexo-–debug" class="headerlink" title="hexo –debug"></a>hexo –debug</h3><p><code>hexo --debug</code> 表示调试模式，用于将消息详细记录到终端和 <code>debug.log</code> 文件</p><pre class="line-numbers language-none"><code class="language-none">$ hexo --debug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="hexo-–silent"><a href="#hexo-–silent" class="headerlink" title="hexo –silent"></a>hexo –silent</h3><p><code>hexo --silent</code> 表示静默模式，用于静默输出到终端</p><pre class="line-numbers language-none"><code class="language-none">$ hexo --silent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="二、Hexo图片显示"><a href="#二、Hexo图片显示" class="headerlink" title="二、Hexo图片显示"></a>二、Hexo图片显示</h2><p>1.安装依赖</p><pre class="line-numbers language-none"><code class="language-none">$ npm install https://github.com/CodeFalling/hexo-asset-image --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.config配置</p><p>​        把_config.yml中的post_asset_folder设为true，这个配置的意思是每次new post一个博客，会增加一个和博客同名的文件夹。</p><p>3.图片拷贝和引用</p><p>将图片拷贝到与博客同名的文件夹，然后按如下相对路径引用</p><pre class="line-numbers language-none"><code class="language-none">![图片描述]（./博客名/NO.01.001.jpg）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.保存和generator</p><pre class="line-numbers language-none"><code class="language-none">$ hexo clean &amp; hexo g &amp; hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用指令</title>
      <link href="/2022/04/11/git/"/>
      <url>/2022/04/11/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git常用指令"><a href="#Git常用指令" class="headerlink" title="Git常用指令"></a>Git常用指令</h1><p>[TOC]</p><table><thead><tr><th align="center">name</th><th align="center">名词</th></tr></thead><tbody><tr><td align="center">Workspace</td><td align="center">工作区</td></tr><tr><td align="center">Index / Stage</td><td align="center">暂存区</td></tr><tr><td align="center">Repository</td><td align="center">仓库区（或本地仓库）</td></tr><tr><td align="center">Remote</td><td align="center">远程仓库</td></tr></tbody></table><h3 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a><strong>一、新建代码库</strong></h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;在当前目录新建一个Git代码库$&nbsp;git&nbsp;init#&nbsp;新建一个目录，将其初始化为Git代码库$&nbsp;git&nbsp;init&nbsp;[project-name]#&nbsp;下载一个项目和它的整个代码历史$&nbsp;git&nbsp;clone&nbsp;[url]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a><strong>二、配置</strong></h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)</p><pre class="line-numbers language-none"><code class="language-none">#&nbsp;显示当前的Git配置$&nbsp;git&nbsp;config&nbsp;--list#&nbsp;编辑Git配置文件$&nbsp;git&nbsp;config&nbsp;-e&nbsp;[--global]#&nbsp;设置提交代码时的用户信息$&nbsp;git&nbsp;config&nbsp;[--global]&nbsp;user.name&nbsp;"[name]"$&nbsp;git&nbsp;config&nbsp;[--global]&nbsp;user.email&nbsp;"[email&nbsp;address]"#&nbsp;颜色设置git&nbsp;config&nbsp;--global&nbsp;color.ui&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;git&nbsp;status等命令自动着色git&nbsp;config&nbsp;--global&nbsp;color.status&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;color.diff&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;color.branch&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;color.interactive&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;--unset&nbsp;http.proxy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;remove&nbsp;&nbsp;proxy&nbsp;configuration&nbsp;on&nbsp;gitgit config user.name // 查看git用户名git config user.password //查看git密码git config user.email // 查看git邮箱地址git config --global user.name "xxxx(新的用户名)" // 修改git用户名git config --global user.password "xxxx(新的密码)" // 修改git密码git config --global user.email "xxxx@xxx.com(新的邮箱)" // 修改git邮箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;添加指定文件到暂存区$&nbsp;git&nbsp;add&nbsp;[file1]&nbsp;[file2]&nbsp;...#&nbsp;添加指定目录到暂存区，包括子目录$&nbsp;git&nbsp;add&nbsp;[dir]#&nbsp;添加当前目录的所有文件到暂存区$&nbsp;git&nbsp;add&nbsp;.#&nbsp;添加每个变化前，都会要求确认#&nbsp;对于同一个文件的多处变化，可以实现分次提交$&nbsp;git&nbsp;add&nbsp;-p#&nbsp;删除工作区文件，并且将这次删除放入暂存区$&nbsp;git&nbsp;rm&nbsp;[file1]&nbsp;[file2]&nbsp;...#&nbsp;停止追踪指定文件，但该文件会保留在工作区$&nbsp;git&nbsp;rm&nbsp;--cached&nbsp;[file]#&nbsp;改名文件，并且将这个改名放入暂存区$&nbsp;git&nbsp;mv&nbsp;[file-original]&nbsp;[file-renamed]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a><strong>四、代码提交</strong></h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;提交暂存区到仓库区$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;[message]#&nbsp;提交暂存区的指定文件到仓库区$&nbsp;git&nbsp;commit&nbsp;[file1]&nbsp;[file2]&nbsp;...&nbsp;-m&nbsp;[message]#&nbsp;提交工作区自上次commit之后的变化，直接到仓库区$&nbsp;git&nbsp;commit&nbsp;-a#&nbsp;提交时显示所有diff信息$&nbsp;git&nbsp;commit&nbsp;-v#&nbsp;将add和commit合为一步$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'message'#&nbsp;使用一次新的commit，替代上一次提交#&nbsp;如果代码没有任何新变化，则用来改写上一次commit的提交信息$&nbsp;git&nbsp;commit&nbsp;--amend&nbsp;-m&nbsp;[message]#&nbsp;重做上一次commit，并包括指定文件的新变化$&nbsp;git&nbsp;commit&nbsp;--amend&nbsp;[file1]&nbsp;[file2]&nbsp;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a><strong>五、分支</strong></h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;列出所有本地分支$&nbsp;git&nbsp;branch#&nbsp;列出所有远程分支$&nbsp;git&nbsp;branch&nbsp;-r#&nbsp;列出所有本地分支和远程分支$&nbsp;git&nbsp;branch&nbsp;-a#&nbsp;新建一个分支，但依然停留在当前分支$&nbsp;git&nbsp;branch&nbsp;[branch-name]#&nbsp;新建一个分支，并切换到该分支$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;[branch]#&nbsp;新建一个分支，指向指定commit$&nbsp;git&nbsp;branch&nbsp;[branch]&nbsp;[commit]#&nbsp;新建一个分支，与指定的远程分支建立追踪关系$&nbsp;git&nbsp;branch&nbsp;--track&nbsp;[branch]&nbsp;[remote-branch]#&nbsp;切换到指定分支，并更新工作区$&nbsp;git&nbsp;checkout&nbsp;[branch-name]#&nbsp;切换到上一个分支$&nbsp;git&nbsp;checkout&nbsp;-#&nbsp;建立追踪关系，在现有分支与指定的远程分支之间$&nbsp;git&nbsp;branch&nbsp;--set-upstream&nbsp;[branch]&nbsp;[remote-branch]#&nbsp;合并指定分支到当前分支$&nbsp;git&nbsp;merge&nbsp;[branch]#&nbsp;选择一个commit，合并进当前分支$&nbsp;git&nbsp;cherry-pick&nbsp;[commit]#&nbsp;删除分支$&nbsp;git&nbsp;branch&nbsp;-d&nbsp;[branch-name]#&nbsp;删除远程分支$&nbsp;git&nbsp;push&nbsp;origin&nbsp;--delete&nbsp;[branch-name]$&nbsp;git&nbsp;branch&nbsp;-dr&nbsp;[remote/branch]#&nbsp;检出版本v2.0$&nbsp;git&nbsp;checkout&nbsp;v2.0#&nbsp;从远程分支develop创建新本地分支devel并检出$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;devel&nbsp;origin/develop#&nbsp;检出head版本的README文件（可用于修改错误回退）git&nbsp;checkout&nbsp;--&nbsp;README <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;列出所有tag$&nbsp;git&nbsp;tag#&nbsp;新建一个tag在当前commit$&nbsp;git&nbsp;tag&nbsp;[tag]#&nbsp;新建一个tag在指定commit$&nbsp;git&nbsp;tag&nbsp;[tag]&nbsp;[commit]#&nbsp;删除本地tag$&nbsp;git&nbsp;tag&nbsp;-d&nbsp;[tag]#&nbsp;删除远程tag$&nbsp;git&nbsp;push&nbsp;origin&nbsp;:refs/tags/[tagName]#&nbsp;查看tag信息$&nbsp;git&nbsp;show&nbsp;[tag]#&nbsp;提交指定tag$&nbsp;git&nbsp;push&nbsp;[remote]&nbsp;[tag]#&nbsp;提交所有tag$&nbsp;git&nbsp;push&nbsp;[remote]&nbsp;--tags#&nbsp;新建一个分支，指向某个tag$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;[branch]&nbsp;[tag]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;显示有变更的文件$&nbsp;git&nbsp;status#&nbsp;显示当前分支的版本历史$&nbsp;git&nbsp;log#&nbsp;显示commit历史，以及每次commit发生变更的文件$&nbsp;git&nbsp;log&nbsp;--stat#&nbsp;搜索提交历史，根据关键词$&nbsp;git&nbsp;log&nbsp;-S&nbsp;[keyword]#&nbsp;显示某个commit之后的所有变动，每个commit占据一行$&nbsp;git&nbsp;log&nbsp;[tag]&nbsp;HEAD&nbsp;--pretty=format:%s#&nbsp;显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件$&nbsp;git&nbsp;log&nbsp;[tag]&nbsp;HEAD&nbsp;--grep&nbsp;feature#&nbsp;显示某个文件的版本历史，包括文件改名$&nbsp;git&nbsp;log&nbsp;--follow&nbsp;[file]$&nbsp;git&nbsp;whatchanged&nbsp;[file]#&nbsp;显示指定文件相关的每一次diff$&nbsp;git&nbsp;log&nbsp;-p&nbsp;[file]#&nbsp;显示过去5次提交$&nbsp;git&nbsp;log&nbsp;-5&nbsp;--pretty&nbsp;--oneline#&nbsp;显示所有提交过的用户，按提交次数排序$&nbsp;git&nbsp;shortlog&nbsp;-sn#&nbsp;显示指定文件是什么人在什么时间修改过$&nbsp;git&nbsp;blame&nbsp;[file]#&nbsp;显示暂存区和工作区的差异$&nbsp;git&nbsp;diff#&nbsp;显示暂存区和上一个commit的差异$&nbsp;git&nbsp;diff&nbsp;--cached&nbsp;[file]#&nbsp;显示工作区与当前分支最新commit之间的差异$&nbsp;git&nbsp;diff&nbsp;HEAD#&nbsp;显示两次提交之间的差异$&nbsp;git&nbsp;diff&nbsp;[first-branch]...[second-branch]#&nbsp;显示今天你写了多少行代码$&nbsp;git&nbsp;diff&nbsp;--shortstat&nbsp;"@{0&nbsp;day&nbsp;ago}"#&nbsp;显示某次提交的元数据和内容变化$&nbsp;git&nbsp;show&nbsp;[commit]#&nbsp;显示某次提交发生变化的文件$&nbsp;git&nbsp;show&nbsp;--name-only&nbsp;[commit]#&nbsp;显示某次提交时，某个文件的内容$&nbsp;git&nbsp;show&nbsp;[commit]:[filename]#&nbsp;显示当前分支的最近几次提交$&nbsp;git&nbsp;reflog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a><strong>八、远程同步</strong></h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;下载远程仓库的所有变动$&nbsp;git&nbsp;fetch&nbsp;[remote]#&nbsp;显示所有远程仓库$&nbsp;git&nbsp;remote&nbsp;-v#&nbsp;显示某个远程仓库的信息$&nbsp;git&nbsp;remote&nbsp;show&nbsp;[remote]#&nbsp;增加一个新的远程仓库，并命名$&nbsp;git&nbsp;remote&nbsp;add&nbsp;[shortname]&nbsp;[url]#&nbsp;取回远程仓库的变化，并与本地分支合并$&nbsp;git&nbsp;pull&nbsp;[remote]&nbsp;[branch]#&nbsp;上传本地指定分支到远程仓库$&nbsp;git&nbsp;push&nbsp;[remote]&nbsp;[branch]#&nbsp;强行推送当前分支到远程仓库，即使有冲突$&nbsp;git&nbsp;push&nbsp;[remote]&nbsp;--force#&nbsp;推送所有分支到远程仓库$&nbsp;git&nbsp;push&nbsp;[remote]&nbsp;--all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a><strong>九、撤销</strong></h3><pre class="line-numbers language-none"><code class="language-none">#&nbsp;恢复暂存区的指定文件到工作区$&nbsp;git&nbsp;checkout&nbsp;[file]  #&nbsp;恢复某个commit的指定文件到暂存区和工作区$&nbsp;git&nbsp;checkout&nbsp;[commit]&nbsp;[file]  #&nbsp;恢复暂存区的所有文件到工作区$&nbsp;git&nbsp;checkout&nbsp;.     #&nbsp;重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$&nbsp;git&nbsp;reset&nbsp;[file]   #&nbsp;重置暂存区与工作区，与上一次commit保持一致$&nbsp;git&nbsp;reset&nbsp;--hard   #&nbsp;重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$&nbsp;git&nbsp;reset&nbsp;[commit] #&nbsp;重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$&nbsp;git&nbsp;reset&nbsp;--hard&nbsp;[commit] #&nbsp;重置当前HEAD为指定commit，但保持暂存区和工作区不变$&nbsp;git&nbsp;reset&nbsp;--keep&nbsp;[commit]#&nbsp;新建一个commit，用来撤销指定commit,后者的所有变化都将被前者抵消，并且应用到当前分支$&nbsp;git&nbsp;revert&nbsp;[commit] #&nbsp;暂时将未提交的变化移除，稍后再移入$&nbsp;git&nbsp;stash$&nbsp;git&nbsp;stash&nbsp;pop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h3><pre class="line-numbers language-none"><code class="language-none">git&nbsp;init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;初始化本地git仓库（创建新仓库）git&nbsp;config&nbsp;--global&nbsp;user.name&nbsp;"xxx"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;配置用户名git&nbsp;config&nbsp;--global&nbsp;user.email&nbsp;"xxx@xxx.com"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;配置邮件git&nbsp;config&nbsp;--global&nbsp;color.ui&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;git&nbsp;status等命令自动着色git&nbsp;config&nbsp;--global&nbsp;color.status&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;color.diff&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;color.branch&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;color.interactive&nbsp;autogit&nbsp;config&nbsp;--global&nbsp;--unset&nbsp;http.proxy&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;remove&nbsp;&nbsp;proxy&nbsp;configuration&nbsp;on&nbsp;gitgit&nbsp;clone&nbsp;git+ssh://git@192.168.53.168/VT.git&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;clone远程仓库git&nbsp;status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看当前版本状态（是否修改）git&nbsp;add&nbsp;xyz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;添加xyz文件至indexgit&nbsp;add&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;增加当前子目录下所有更改过的文件至indexgit&nbsp;commit&nbsp;-m&nbsp;'xxx'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;提交git&nbsp;commit&nbsp;--amend&nbsp;-m&nbsp;'xxx'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;合并上一次提交（用于反复修改）git&nbsp;commit&nbsp;-am&nbsp;'xxx'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;将add和commit合为一步git&nbsp;rm&nbsp;xxx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;删除index中的文件git&nbsp;rm&nbsp;-r&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;递归删除git&nbsp;log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示提交日志git&nbsp;log&nbsp;-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示1行日志&nbsp;-n为n行git&nbsp;log&nbsp;-5git&nbsp;log&nbsp;--stat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示提交日志及相关变动文件git&nbsp;log&nbsp;-p&nbsp;-mgit&nbsp;show&nbsp;dfb02e6e4f2f7b573337763e5c0013802e392818&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示某个提交的详细内容git&nbsp;show&nbsp;dfb02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;可只用commitid的前几位git&nbsp;show&nbsp;HEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示HEAD提交日志git&nbsp;show&nbsp;HEAD^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示HEAD的父（上一个版本）的提交日志&nbsp;^^为上两个版本&nbsp;^5为上5个版本git&nbsp;tag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示已存在的taggit&nbsp;tag&nbsp;-a&nbsp;v2.0&nbsp;-m&nbsp;'xxx'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;增加v2.0的taggit&nbsp;show&nbsp;v2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示v2.0的日志及详细内容git&nbsp;log&nbsp;v2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示v2.0的日志git&nbsp;diff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有未添加至index的变更git&nbsp;diff&nbsp;--cached&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有已添加index但还未commit的变更git&nbsp;diff&nbsp;HEAD^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;比较与上一个版本的差异git&nbsp;diff&nbsp;HEAD&nbsp;--&nbsp;./lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;比较与HEAD版本lib目录的差异git&nbsp;diff&nbsp;origin/master..master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;比较远程分支master上有本地分支master上没有的git&nbsp;diff&nbsp;origin/master..master&nbsp;--stat&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;只显示差异的文件，不显示具体内容git&nbsp;remote&nbsp;add&nbsp;origin&nbsp;git+ssh://git@192.168.53.168/VT.git&nbsp;#&nbsp;增加远程定义（用于push/pull/fetch）git&nbsp;branch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示本地分支git&nbsp;branch&nbsp;--contains&nbsp;50089&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示包含提交50089的分支git&nbsp;branch&nbsp;-a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有分支git&nbsp;branch&nbsp;-r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有原创分支git&nbsp;branch&nbsp;--merged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有已合并到当前分支的分支git&nbsp;branch&nbsp;--no-merged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有未合并到当前分支的分支git&nbsp;branch&nbsp;-m&nbsp;master&nbsp;master_copy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;本地分支改名git&nbsp;checkout&nbsp;-b&nbsp;master_copy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;从当前分支创建新分支master_copy并检出git&nbsp;checkout&nbsp;-b&nbsp;master&nbsp;master_copy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;上面的完整版git&nbsp;checkout&nbsp;features/performance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;检出已存在的features/performance分支git&nbsp;checkout&nbsp;--track&nbsp;hotfixes/BJVEP933&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git&nbsp;checkout&nbsp;v2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;检出版本v2.0git&nbsp;checkout&nbsp;-b&nbsp;devel&nbsp;origin/develop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;从远程分支develop创建新本地分支devel并检出git&nbsp;checkout&nbsp;--&nbsp;README&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;检出head版本的README文件（可用于修改错误回退）git&nbsp;merge&nbsp;origin/master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;合并远程master分支至当前分支git&nbsp;cherry-pick&nbsp;ff44785404a8e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;合并提交ff44785404a8e的修改git&nbsp;push&nbsp;origin&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;将当前分支push到远程master分支git&nbsp;push&nbsp;origin&nbsp;:hotfixes/BJVEP933&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;删除远程仓库的hotfixes/BJVEP933分支git&nbsp;push&nbsp;--tags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;把所有tag推送到远程仓库git&nbsp;fetch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;获取所有远程分支（不更新本地分支，另需merge）git&nbsp;fetch&nbsp;--prune&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;获取所有原创分支并清除服务器上已删掉的分支git&nbsp;pull&nbsp;origin&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;获取远程分支master并merge到当前分支git&nbsp;mv&nbsp;README&nbsp;README2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;重命名文件README为README2git&nbsp;reset&nbsp;--hard&nbsp;HEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;将当前版本重置为HEAD（通常用于merge失败回退）git&nbsp;rebasegit&nbsp;branch&nbsp;-d&nbsp;hotfixes/BJVEP933&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git&nbsp;branch&nbsp;-D&nbsp;hotfixes/BJVEP933&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;强制删除分支hotfixes/BJVEP933git&nbsp;ls-files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;列出git&nbsp;index包含的文件git&nbsp;show-branch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;图示当前分支历史git&nbsp;show-branch&nbsp;--all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;图示所有分支历史git&nbsp;whatchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示提交历史对应的文件修改git&nbsp;revert&nbsp;dfb02e6e4f2f7b573337763e5c0013802e392818&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git&nbsp;ls-tree&nbsp;HEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;内部命令：显示某个git对象git&nbsp;rev-parse&nbsp;v2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;内部命令：显示某个ref对于的SHA1 HASHgit&nbsp;reflog&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示所有提交，包括孤立节点git&nbsp;show&nbsp;HEAD@{5}git&nbsp;show&nbsp;master@{yesterday}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;显示master分支昨天的状态git&nbsp;log&nbsp;--pretty=format:'%h&nbsp;%s'&nbsp;--graph&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;图示提交日志git&nbsp;show&nbsp;HEAD~3git&nbsp;show&nbsp;-s&nbsp;--pretty=raw&nbsp;2be7fcb476git&nbsp;stash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;暂存当前修改，将所有至为HEAD状态git&nbsp;stash&nbsp;list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看所有暂存git&nbsp;stash&nbsp;show&nbsp;-p&nbsp;stash@{0}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;参考第一次暂存git&nbsp;stash&nbsp;apply&nbsp;stash@{0}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;应用第一次暂存git&nbsp;grep&nbsp;"delete&nbsp;from"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;文件中搜索文本“delete&nbsp;from”git&nbsp;grep&nbsp;-e&nbsp;'#define'&nbsp;--and&nbsp;-e&nbsp;SORT_DIRENTgit&nbsp;gcgit&nbsp;fsck                                                  #&nbsp;生成一个可供发布的压缩包git&nbsp;archivegit submodule update --init --recursivegit submodule initgit submodule updatessh -T git@github.com #检查连接和认证<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC常用编译选项</title>
      <link href="/2022/04/10/gcc-chang-yong-bian-yi-xuan-xiang/"/>
      <url>/2022/04/10/gcc-chang-yong-bian-yi-xuan-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="GCC常用编译选项"><a href="#GCC常用编译选项" class="headerlink" title="GCC常用编译选项"></a>GCC常用编译选项</h1><p>​        </p><p>[TOC]</p><p>​        GCC有很多编译选项，有一些常用的选项可以作为检查代码质量的辅助手段，有的则可以让编译器对代码和编译目标文件进行优化，还有的是专门为了调试代码设计的，熟悉这些编译选项可以让开发者在使用GCC时更加游刃有余。</p><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">CFLAGS := -Wall -Wundef -Wshadow -Wconversion -Werror=return-type \    -Werror=implicit-function-declaration -Werror=unused-variable \    -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE \    -Wno-trigraphs -Os<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于调试版本，将<code>-Os</code>替换为<code>-g -Og</code>。</p><h2 id="一-警告选项"><a href="#一-警告选项" class="headerlink" title="一 警告选项"></a>一 警告选项</h2><p>​        GCC编译器支持对代码进行诊断，<strong>针对代码本身不是错误但是疑似错误或者可能存在风险的地方发出警告</strong>，而警告编译选项就是用于<strong>控制需要告警的警告类型</strong>的。一般启用特定类型警告的格式为<code>-Wxxx</code>，而排除特定类型的警告的格式则一般为<code>-Wno-xxx</code>。</p><h3 id="1-Wall"><a href="#1-Wall" class="headerlink" title="1 -Wall"></a>1 -Wall</h3><p>​        这是一个非常常用的编译选项，用于启用一批<strong>比较常见且易于修改的警告</strong>，这些选项都是对代码进行基本的检查，比如下面这些：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-Waddress</td><td>检查是否存在可疑的内存地址使用</td></tr><tr><td>-Wformat</td><td>检查标准库函数的使用格式是否正确，比如printf的格式化字符串中的格式符和对应的参数是否匹配</td></tr><tr><td>-Wunused-function</td><td>对已声明但是未定义的静态函数和未被使用的非内联静态函数发出警告</td></tr><tr><td>-Wswitch</td><td>当用switch用于枚举类型时，判断分支是否包含所有枚举值，否则发出警告</td></tr><tr><td>-Wunused-variable</td><td>对声明但未被使用的变量发出警告</td></tr><tr><td>-Wunused-but-set-variable</td><td>对声明且被赋值但未被使用的变量发出警告</td></tr><tr><td>-Warray-bounds=1</td><td>数组越界检查，需启用选项-ftree-vrp</td></tr></tbody></table><p>​        当需要排除某些类型的警告时，记得使用<code>-Wno-xxx</code>, 比如使用<code>-Wall -Wno-unused-variable</code>可以从<code>-Wall</code>中排除<code>-Wunused-variable</code>。</p><p>​        完整的列表参见链接**<a href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html">Warning-Options</a>**。</p><h3 id="2-Wextra"><a href="#2-Wextra" class="headerlink" title="2 -Wextra"></a>2 -Wextra</h3><p>​        单单只有<code>-Wall</code>可能还不够严格，GCC还有<code>-Wextra</code>作为补充，包括另外一些没有被<code>-Wall</code>包含的警告类型，比如笔者比较喜欢的几个：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-Wcast-function-type</td><td>当函数被强转为不兼容的函数指针时发出警告</td></tr><tr><td>-Wempty-body</td><td>当存在空的if、else或者do while语句时发出警告</td></tr><tr><td>-Wunused-parameter</td><td>当函数有未被使用的参数时发出警告，需配合-Wall</td></tr><tr><td>-Wunused-but-set-parameter</td><td>当存在被设置但是未被使用的参数发出警告，需配合-Wall</td></tr><tr><td>-Wsign-compare</td><td>当比较有符号和无符号值时发出警告</td></tr></tbody></table><p>对于不同语言，<code>-Wall</code>和<code>-Wextra</code>启用的选项可能略有差异</p><h3 id="3-Werror"><a href="#3-Werror" class="headerlink" title="3 -Werror"></a>3 -Werror</h3><p><code>-Werror</code>用于将所有警告视为错误。</p><p>​        如果不希望某些类型的警告被视为错误可以使用<code>-Wno-error=&lt;警告类型&gt;</code>，比如<code>-Wno-error=switch</code>；而使用<code>-Werror=&lt;警告类型&gt;</code>则可以将指定警告类型视为错误，比如<code>-Werror=switch</code>。</p><p>​        当代码量变得比较大的时候，同时启用<code>-Wall -Wextra -Werror</code>是比较严苛的，可能存在一些不准确的警告，这时可以将<code>-Werror</code>替换为只将某些警告视为错误，在自动化编译构建的时候提前报错终止提示开发者进行改进。</p><p>​        对于大部分<code>-Wunused-</code>类警告选项，其实都是<strong>让开发者明确知道定义的变量或者参数是不是必须的</strong>，是多余的还是忘记使用了，对于反思代码逻辑和简化代码都是很有帮助的，所以建议将这些警告视为错误。</p><h3 id="4-Wpedantic"><a href="#4-Wpedantic" class="headerlink" title="4 -Wpedantic"></a>4 -Wpedantic</h3><p>对于所有不符合<code>ISO C/ISO C++</code>语言标准的源代码发出警告，等价于<code>-pedantic</code>。</p><pre class="line-numbers language-none"><code class="language-none">-pedantic-errors`参数将这些警告视为错误，等同于`-Werror=pedantic<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-Wshadow"><a href="#5-Wshadow" class="headerlink" title="5 -Wshadow"></a>5 -Wshadow</h3><p>当局部变量屏蔽（shadow）已有已有变量时发出警告。比如以下代码：</p><pre class="line-numbers language-none"><code class="language-none">int ret = 0;for (int i = 0; i &lt; 10; ++i) {    int ret = i;  //  warning: declaration shadows a local variable}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-Wconversion"><a href="#6-Wconversion" class="headerlink" title="6 -Wconversion"></a>6 -Wconversion</h3><p>​        在<strong>隐式转换可能导致值变化的时候</strong>发出警告。在隐式转换的时候，如果值发生变化，那么结果可能就不是预料中的，所以最好使用显式转换。</p><h2 id="二-优化选项"><a href="#二-优化选项" class="headerlink" title="二 优化选项"></a>二 优化选项</h2><p>​        优化选项用于控制编译器对代码的优化等级。比较常用的是<code>-O2</code>和<code>-Os</code>。详细的介绍请查看官网**<a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">Optimize-Options</a>**。</p><h3 id="1-O0-Og"><a href="#1-O0-Og" class="headerlink" title="1 -O0/-Og"></a>1 -O0/-Og</h3><p>​        <code>-O0</code>是默认选项，不执行任何优化。在编译调试版本的时候，一般使用<code>-O0</code>，可以确保调试执行过程完全和代码一致（如果使用优化选项，根据源文件设定的断点和经过优化编译得到的程序可能对不上，所以不能准确停在预期的地方）。</p><p>​        <code>-Og</code>是针对调试的优化选项，它会启用<code>-O1</code>的优化指令，除了那么可能会干扰调试的优化选项，同时可获取到更多的调试信息，提供更好好的编译体验，</p><h3 id="2-O-O1"><a href="#2-O-O1" class="headerlink" title="2 -O/-O1"></a>2 -O/-O1</h3><p>​        执行级别1的优化，尝试减少代码大小和提高性能，但是不包括需要花费大量编译时间的优化选项。</p><p>比如：</p><ol><li><code>-fdce</code>：移除不可能执行到的代码</li><li><code>-fif-conversion</code>：尝试简化if语句。使用更少的分支、转化成标志位等操作</li><li><code>-fmerge-constants</code>：尝试合并相同的常量</li></ol><h3 id="3-O2"><a href="#3-O2" class="headerlink" title="3 -O2"></a>3 -O2</h3><p>​        执行<code>-O1</code>所有优化选项，同时额外执行<strong>几乎全部不需要在空间和性能之间平衡</strong>的优化选项。</p><p>比如：</p><ol><li><code>-fgcse</code>：优化全局公共表达式、常量的传递</li><li><code>-fcode-hoisting</code>：将所有分支都需要执行的表达式尽早执行（对于优化代码大小很有用，同时也提升性能）</li><li><code>-finline-functions</code>：考虑将所有函数变成内联函数（即使没有被声明为inline）</li></ol><h3 id="4-Os"><a href="#4-Os" class="headerlink" title="4 -Os"></a>4 -Os</h3><p>​        这是专门用于优化代码大小的优化级别，执行<code>-O2</code>所有优化选项，排除那些可能导致程序大小增加的优化选项。</p><h3 id="5-O3"><a href="#5-O3" class="headerlink" title="5 -O3"></a>5 -O3</h3><p>​        最高优化等级。该优化级别较高，执行的优化不会很直观，所以可能也会出现一些问题，需要看实际情况选择是否需要使用<code>-O3</code>。在使用<code>-O3</code>优化级别时，<strong>小概率出现代码执行一段时间后出现了一些不符合预期的现象</strong>，在降低优化等级时则没有问题。</p><h3 id="6-ffunction-sections-fdata-sections-Wl-–gc-sections"><a href="#6-ffunction-sections-fdata-sections-Wl-–gc-sections" class="headerlink" title="6 -ffunction-sections/-fdata-sections/-Wl,–gc-sections"></a>6 -ffunction-sections/-fdata-sections/-Wl,–gc-sections</h3><p>​        在开发过程中，可能会实现一些实际并不会用到的函数或者对外有多个接口，并不是所有的接口都需要用到所有的模块和函数，但是默认情况下，GCC会把整个静态库链接到目标可执行文件，所以会增加可执行文件的大小。</p><p>​        GCC在链接的时候以<code>section</code>为单元处理，所以可以尝试使用<code>-ffunction-sections/-fdata-sections</code>将每个函数或者符号创建成独立的<code>section</code>，然后结合选项<code>-Wl,--gc-sections</code>让链接器忽略用不到的<code>section</code>，这样就可以减少目标可执行程序的大小。其中<code>-Wl</code>表示将后面的参数传递给链接器，所以也可以直接设置链接器选项。</p><p>​        注意这个并不是所有的链接器都支持的，大多数支持编译ELF目标文件的工具链都是支持的，<strong>一般嵌入式开发会比较常用</strong>的。</p><h2 id="三-代码生成选项"><a href="#三-代码生成选项" class="headerlink" title="三 代码生成选项"></a>三 代码生成选项</h2><p>​        最常用的就只有<code>-fPIC</code>，该选项用于生成**位置无关代码(PIC，position-independent code)**，主要是为了生成共享库。此类代码通过全局偏移表 (GOT) 访问所有常量地址，在程序启动的时候，动态加载器会确定需要使用的共享库的GOT。</p><p><code>-fPIE</code>和<code>-fPIC</code>是类似的，但<code>-fPIE</code>产生的位置无关代码只能用于链接可执行文件。</p><p>另外可能还会偶尔用到<code>-fpic</code>和<code>-fpie</code>，它们和全大写的区别只在于系统对GOT大小有一定限制。</p><h2 id="四-调试选项"><a href="#四-调试选项" class="headerlink" title="四 调试选项"></a>四 调试选项</h2><p>​        一般情况下是为了能够正常使用调试器调试程序，必须要让编译器给编译目标添加额外的调试信息。最常使用的是<code>-g</code>，一般可以满足需求。但是如果为了提升一些调试程序的性能，可以配合使用针对调试的优化选项<code>-Og</code>。（添加的调试信息可以使用<code>strip</code>工具移除，一般对于需要release的程序代码可以都通过此工具移除一些敏感信息，同时也能够减少目标文件的大小。）</p><p>​        GCC的编译选项还有很多，对于常用的就是上面这一些，在开发阶段，最重要还是通过一些有用的警告选项排查常见的代码bug，提高代码的鲁棒性。</p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc </tag>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>doxygen教程</title>
      <link href="/2022/04/09/doxygen-jiao-cheng/"/>
      <url>/2022/04/09/doxygen-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="doxygen教程"><a href="#doxygen教程" class="headerlink" title="doxygen教程"></a>doxygen教程</h1><h2 id="一．什么是Doxygen"><a href="#一．什么是Doxygen" class="headerlink" title="一．什么是Doxygen?"></a><strong>一．什么是Doxygen?</strong></h2><p>​        Doxygen 是一个程序的文件产生工具，可将程序中的特定批注转换成为说明文件。通常我们在写程序时，或多或少都会写上批注，但是对于其它人而言，要直接探索程序里的批注，与打捞泰坦尼克号同样的辛苦。大部分有用的批注都是属于针对函式，类别等等的说明。所以，如果能依据程序本身的结构，将批注经过处理重新整理成为一个纯粹的参考手册，对于后面利用您的程序代码的人而言将会减少许多的负担。不过，反过来说，整理文件的工作对于您来说，就是沉重的负担。Doxygen 就是在您写批注时，稍微<strong>按照一些它所制订的规则</strong>。接着，他就可以帮您产生出漂亮的文档了。</p><p>​        因此，Doxygen 的使用可分为两大部分。首先是<strong>特定格式的批注撰写</strong>，第二便是<strong>利用Doxygen的工具来产生文档。</strong></p><p>​        目前Doxygen可处理的程序语言包含：C/C++、 Java、IDL (Corba, Microsoft及KDE-DCOP类型)  ，而可产生出来的文档格式有：HTML、XML、LaTeX、RTF、Unix Man Page。而其中还可衍生出不少其它格式。HTML可以打包成<strong>CHM格式</strong>，而LaTeX可以透过一些工具产生出<strong>PS或是PDF文档</strong>。</p><h2 id="二．安装Doxygen"><a href="#二．安装Doxygen" class="headerlink" title="二．安装Doxygen"></a><strong>二．安装Doxygen</strong></h2><h3 id="2-1-安装-Doxygen"><a href="#2-1-安装-Doxygen" class="headerlink" title="2.1 安装 Doxygen"></a>2.1 安装 Doxygen</h3><p>在Linux下可以通过apt install doxygen安装命令行工具，然后用apt install doxygen-gui安装图形界面。对Linux用户来说，命令行工具可以通过doxygen命令运行，而图形界面可以通过doxywizard命令运行。</p><p>Windows 用户的下载地址：</p><h3 id="2-2-安装-graphviz"><a href="#2-2-安装-graphviz" class="headerlink" title="2.2 安装 graphviz"></a>2.2 安装 graphviz</h3><p>​        graphviz 是一个由AT&amp;T实验室启动的开源工具包，用于绘制DOT语言脚本描述的图形。Doxygen 使用 graphviz 自动生成类之间和文件之间的调用关系图，如不需要此功能可不安装该工具包。</p><h3 id="2-3-安装-Windows-Help-Workshop"><a href="#2-3-安装-Windows-Help-Workshop" class="headerlink" title="2.3 安装 Windows Help Workshop"></a>2.3 安装 Windows Help Workshop</h3><p>​        Doxygen 使用这个工具可以生成 CHM 格式的文档。</p><h2 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a><strong>三、基本使用</strong></h2><h3 id="1-基本配置"><a href="#1-基本配置" class="headerlink" title="1.基本配置"></a>1.基本配置</h3><p>图形工具的基本使用如下图所示，有非常多的配置选项，这里我们只填入必要的配置，其它配置都用默认值。</p><pre class="line-numbers language-none"><code class="language-none">（1）Wizard--&gt;Project--&gt;DOXYFILE_ENCODING  Doxygen  文件的编码方式默认为UTF-，若希望支持中文，最好设置为GB2312。 （2）Wizard--&gt;Project--&gt;PROJECT_NAME 项目名项目    的名字，以一个单词为主，多个单词请使用双引号括住。*（3）Wizard--&gt;Project--&gt;Scan recursively ：yes 递归扫描（4）Wozard--&gt;Project--&gt;Source code directory 源代码目录（5）Wizard--&gt;Project--&gt;Destination directory 输出Html页面的目录（6）Wizard--&gt;Mode --&gt; All Entities （7）Wizard--&gt;Mode --&gt; Include cross-referenced（8）Wizard--&gt;Diagrams --&gt; Use dot tool from the GraphViz package 全选(使用GraphViz画图，需要安装GraphViz）（9）Expert--&gt;Project--&gt;OUTPUT_LANGUAGE--&gt;Chinese  输出语言（10）Expert--&gt;Dot--&gt;CLASS_DIAGRAMS            yes（11）Expert--&gt;Dot--&gt;UML_LOOK                           yes         显示UML图（12）Expert--&gt;Dot--&gt;CALL_GRAPH                      yes（13）Expert--&gt;Dot--&gt;CALLER_GRAPH                  yes（14）Expert--&gt;Dot--&gt;DOT_ATH           D:\Program Files (x86)\Graphviz2.38\bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/04/09/doxygen-jiao-cheng/doxygen教程/1.png" alt="基本配置"></p><p><img src="/2022/04/09/doxygen-jiao-cheng/.%5Cdoxygen%E6%95%99%E7%A8%8B%5C2.png" alt="生成文档"></p><h3 id="2-生成文档"><a href="#2-生成文档" class="headerlink" title="2.生成文档"></a>2.生成文档</h3><p>Doxygen生成的HTML会放到<code>out</code>目录下，生成的HTML如下图所示。</p><p><img src="/2022/04/09/doxygen-jiao-cheng/3.png" alt="文档效果"></p><h3 id="3、保存配置"><a href="#3、保存配置" class="headerlink" title="3、保存配置"></a><strong>3、保存配置</strong></h3><p>上面我们配置了一些选项，也成功生成了HTML文档。我们希望下次代码改动后能够继续沿用上次配置，那么我们可以把这些配置保存成Doxyfile文件，如下图所示</p><p><img src="/2022/04/09/doxygen-jiao-cheng/4.png" alt="保存配置"></p><h3 id="4、命令行运行Doxygen"><a href="#4、命令行运行Doxygen" class="headerlink" title="4、命令行运行Doxygen"></a><strong>4、命令行运行Doxygen</strong></h3><p>有了配置文件后我们完全可以通过命令行来生成API文档，假设配置文件名为Doxyfile，那么我们只需要执行doxygen /path/to/Doxyfile即可生成API文档。</p><p>通过命令行生成文档有许多好处，其中最主要的好处就是：能够集成到持续集成之类的自动化系统中。</p><h2 id="四、为代码编写注释"><a href="#四、为代码编写注释" class="headerlink" title="四、为代码编写注释"></a><strong>四、为代码编写注释</strong></h2><h3 id="1-识别的注释"><a href="#1-识别的注释" class="headerlink" title="1.识别的注释"></a>1.识别的注释</h3><p>Doxygen能识别这几种风格的注释：</p><pre class="line-numbers language-none"><code class="language-none">/** * ... text ... *//*! * ... text ... */////// ... text .../////!//!... text ...//!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件的开头必须有文件注释，否则该文件不会被识别：</p><pre class="line-numbers language-none"><code class="language-none">/*! \file math.h */<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-注释怎么写"><a href="#2-注释怎么写" class="headerlink" title="2.注释怎么写"></a><strong>2.注释怎么写</strong></h3><p>建议参考官网例子。</p><pre class="line-numbers language-none"><code class="language-none">https://www.doxygen.nl/manual/doxygen_usage.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-为其它编程语言生成注释"><a href="#3-为其它编程语言生成注释" class="headerlink" title="3.为其它编程语言生成注释"></a>3.<strong>为其它编程语言生成注释</strong></h3><p>Doxygen主要支持C语言，其它语法跟C差不多的语言（如：C++/C#/PHP/Java）也能够支持，我们称这类语言为「C语系语言」。而哪些跟C语法差异较大的语言叫做「非C语系语言」。</p><p>对于大多非C语系语言，Doxygen都是支持的，Doxygen原生支持这些语言：IDL、Java、Javascript、C#、C、C++、D、PHP、Objective-C、Python、Fortran、VHDL。</p><p>更详细的使用教程可以查看官方文档：</p><p><a href="https://www.doxygen.nl/manual/doxygen_usage.html">https://www.doxygen.nl/manual/doxygen_usage.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doxygen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMakeLists语法</title>
      <link href="/2022/04/08/cmakelists-yu-fa/"/>
      <url>/2022/04/08/cmakelists-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="CMakeLists-txt-语法"><a href="#CMakeLists-txt-语法" class="headerlink" title="CMakeLists.txt 语法"></a>CMakeLists.txt 语法</h1><h2 id="一、Cmake-示例"><a href="#一、Cmake-示例" class="headerlink" title="一、Cmake 示例"></a>一、Cmake 示例</h2><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.16)project(easylogging)set(CMAKE_CXX_STANDARD 11)MESSAGE(STATUS "This is make for easylogging++ lib " ${PROJECT_BINARY_DIR})set(LIB_DIR ${PROJECT_SOURCE_DIR}/SDK/lib/easylogging++)include_directories(${LIB_DIR})include_directories(SDK/include/CRC)include_directories(mongoose)include_directories(SDK/include)set(SRC_LIST        mongoose/mongoose.c#        test.cpp        )add_executable(${PROJECT_NAME} main.cpp ${SRC_LIST})# link the new hello_library target with the hello_binary targettarget_link_libraries( ${PROJECT_NAME}        PRIVATE        ${LIB_DIR}/libeasylogging.a        ws2_32        )##########################Install##################################set(BUILD_DIR ${PROJECT_SOURCE_DIR}/../bin)# Binariesinstall (TARGETS ${PROJECT_NAME} DESTINATION ${BUILD_DIR})# Header filesinstall(DIRECTORY ${PROJECT_BINARY_DIR}/tinyxml2 DESTINATION ${BUILD_DIR}/include)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a><strong>二、常用命令</strong></h2><h4 id="1-指定-cmake-的最小版本"><a href="#1-指定-cmake-的最小版本" class="headerlink" title="1.指定 cmake 的最小版本"></a>1.指定 cmake 的最小版本</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">cmake_minimum_required</span><span class="token punctuation">(</span>VERSION <span class="token number">3.4</span><span class="token number">.1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这行命令是可选的，我们可以不写这句话，但在有些情况下，如果 CMakeLists.txt 文件中使用了一些高版本 cmake 特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行 cmake。</p><h4 id="2-设置项目名称"><a href="#2-设置项目名称" class="headerlink" title="2.设置项目名称"></a>2.设置项目名称</h4><pre class="line-numbers language-none"><code class="language-none">project(demo VERSION 1.0.0 LANGUAGES C CXX)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个命令不是强制性的，但最好都加上。它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。</p><p>​        第一个字段是项目名称；通过<code>VERSION</code>指定版本号，格式为<code>main.minor.patch.tweak</code>，并且CMake会将对应的值分别赋值给以下变量（如果没有设置，则为空字符串）：</p><pre class="line-numbers language-none"><code class="language-none">PROJECT_VERSION, &lt;PROJECT-NAME&gt;_VERSIONPROJECT_VERSION_MAJOR, &lt;PROJECT-NAME&gt;_VERSION_MAJORPROJECT_VERSION_MINOR, &lt;PROJECT-NAME&gt;_VERSION_MINORPROJECT_VERSION_PATCH, &lt;PROJECT-NAME&gt;_VERSION_PATCHPROJECT_VERSION_TWEAK, &lt;PROJECT-NAME&gt;_VERSION_TWEAK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-指定编程语言版本"><a href="#3-指定编程语言版本" class="headerlink" title="3.指定编程语言版本"></a>3.指定编程语言版本</h4><p>为了在不同机器上编译更加统一，最好指定语言的版本，比如声明C使用<code>c99</code>标准，C++使用<code>c++11</code>标准：</p><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_C_STANDARD 99)set(CMAKE_CXX_STANDARD 11)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-配置编译选项"><a href="#4-配置编译选项" class="headerlink" title="4.配置编译选项"></a>4.配置编译选项</h4><p>通过命令<code>add_compile_options</code>命令可以为所有编译器配置编译选项（同时对多个编译器生效）； 通过设置变量<code>CMAKE_C_FLAGS</code>可以配置c编译器的编译选项； 而设置变量<code>CMAKE_CXX_FLAGS</code>可配置针对c++编译器的编译选项。 比如：</p><pre class="line-numbers language-none"><code class="language-none">add_compile_options(-Wall -Wextra -pedantic -Werror)set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -pipe -std=c99")set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pipe -std=c++11")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3-设置编译类型"><a href="#3-设置编译类型" class="headerlink" title="3.设置编译类型"></a>3.设置编译类型</h4><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_BUILD_TYPE Debug)add_executable(demo demo.cpp) # 生成可执行文件add_library(common STATIC util.cpp) # 生成静态库add_library(common SHARED util.cpp) # 生成动态库或共享库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过设置变量<code>CMAKE_BUILD_TYPE</code>来配置编译类型，可设置为：<code>Debug</code>、<code>Release</code>、<code>RelWithDebInfo</code>、<code>MinSizeRel</code>等，比如：</p><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_BUILD_TYPE Debug)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以针对不同的编译类型设置不同的编译选项，比如对于<code>Debug</code>版本，开启调试信息，不进行代码优化：</p><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -g -O0")set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -O0")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于<code>Release</code>版本，不包含调试信息，优化等级设置为2：</p><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -O2")set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O2")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>add_library 默认生成是静态库，通过以上命令生成文件名字，<br>在 Linux 下是：<br>demo<br>libcommon.a<br>libcommon.so<br>在 Windows 下是：<br>demo.exe<br>common.lib<br>common.dll</p><h4 id="4-指定编译包含的源文件"><a href="#4-指定编译包含的源文件" class="headerlink" title="4.指定编译包含的源文件"></a>4.指定编译包含的源文件</h4><h5 id="4-1-明确指定包含哪些源文件"><a href="#4-1-明确指定包含哪些源文件" class="headerlink" title="4.1 明确指定包含哪些源文件"></a>4.1 明确指定包含哪些源文件</h5><pre class="line-numbers language-none"><code class="language-none">add_library(demo demo.cpp test.cpp util.cpp)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4-2-搜索所有的-cpp-文件"><a href="#4-2-搜索所有的-cpp-文件" class="headerlink" title="4.2 搜索所有的 cpp 文件"></a>4.2 搜索所有的 cpp 文件</h5><p>aux_source_directory(dir VAR) 发现一个目录下所有的源代码文件并将列表存储在一个变量中。</p><pre class="line-numbers language-none"><code class="language-none">aux_source_directory(. SRC_LIST) # 搜索当前目录下的所有.cpp文件add_library(demo ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="4-3-自定义搜索规则"><a href="#4-3-自定义搜索规则" class="headerlink" title="4.3 自定义搜索规则"></a>4.3 自定义搜索规则</h5><pre class="line-numbers language-none"><code class="language-none">file(GLOB SRC_LIST "*.cpp" "protocol/*.cpp")add_library(demo ${SRC_LIST})# 或者file(GLOB SRC_LIST "*.cpp")file(GLOB SRC_PROTOCOL_LIST "protocol/*.cpp")add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})# 或者file(GLOB_RECURSE SRC_LIST "*.cpp") #递归搜索FILE(GLOB SRC_PROTOCOL RELATIVE "protocol" "*.cpp") # 相对protocol目录下搜索add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})# 或者aux_source_directory(. SRC_LIST)aux_source_directory(protocol SRC_PROTOCOL_LIST)add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-查找指定的库文件"><a href="#5-查找指定的库文件" class="headerlink" title="5.查找指定的库文件"></a>5.查找指定的库文件</h4><p>​        find_library(VAR name path)查找到指定的预编译库，并将它的路径存储在变量中。默认的搜索路径为 cmake 包含的系统库，因此如果是 NDK 的公共库只需要指定库的 name 即可。</p><pre class="line-numbers language-none"><code class="language-none">find_library( # Sets the name of the path variable.              log-lib               # Specifies the name of the NDK library that              # you want CMake to locate.              log )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似的命令还有 find_file()、find_path()、find_program()、find_package()。</p><h4 id="6-设置包含的目录"><a href="#6-设置包含的目录" class="headerlink" title="6.设置包含的目录"></a>6.设置包含的目录</h4><pre class="line-numbers language-none"><code class="language-none">include_directories(    ${CMAKE_CURRENT_SOURCE_DIR}    ${CMAKE_CURRENT_BINARY_DIR}    ${CMAKE_CURRENT_SOURCE_DIR}/include)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Linux 下还可以通过如下方式设置包含的目录</p><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -I${CMAKE_CURRENT_SOURCE_DIR}")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="7-设置链接库搜索目录"><a href="#7-设置链接库搜索目录" class="headerlink" title="7.设置链接库搜索目录"></a>7.设置链接库搜索目录</h4><pre class="line-numbers language-none"><code class="language-none">link_directories(    ${CMAKE_CURRENT_SOURCE_DIR}/libs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Linux 下还可以通过如下方式设置包含的目录</p><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -L${CMAKE_CURRENT_SOURCE_DIR}/libs")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="8-设置-target-需要链接的库"><a href="#8-设置-target-需要链接的库" class="headerlink" title="8.设置 target 需要链接的库"></a>8.设置 target 需要链接的库</h4><pre class="line-numbers language-none"><code class="language-none">target_link_libraries( # 目标库                       demo                        # 目标库需要链接的库                       # log-lib 是上面 find_library 指定的变量名                       ${log-lib} )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在 Windows 下，系统会根据链接库目录，搜索xxx.lib 文件，Linux 下会搜索 xxx.so 或者 xxx.a 文件，如果都存在会优先链接动态库（so 后缀）。</p><h5 id="8-1-指定链接动态库或静态库"><a href="#8-1-指定链接动态库或静态库" class="headerlink" title="8.1 指定链接动态库或静态库"></a>8.1 指定链接动态库或静态库</h5><pre class="line-numbers language-none"><code class="language-none">target_link_libraries(demo libface.a) # 链接libface.atarget_link_libraries(demo libface.so) # 链接libface.so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="8-2-指定全路径"><a href="#8-2-指定全路径" class="headerlink" title="8.2 指定全路径"></a>8.2 指定全路径</h5><pre class="line-numbers language-none"><code class="language-none">target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.a)target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.so)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="8-3-指定链接多个库"><a href="#8-3-指定链接多个库" class="headerlink" title="8.3 指定链接多个库"></a>8.3 指定链接多个库</h5><pre class="line-numbers language-none"><code class="language-none">target_link_libraries(demo    ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.a    boost_system.a    boost_thread    pthread)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="9-设置变量"><a href="#9-设置变量" class="headerlink" title="9.设置变量"></a>9.设置变量</h4><h5 id="9-1-set-直接设置变量的值"><a href="#9-1-set-直接设置变量的值" class="headerlink" title="9.1 set 直接设置变量的值"></a>9.1 set 直接设置变量的值</h5><pre class="line-numbers language-none"><code class="language-none">set(SRC_LIST main.cpp test.cpp)add_executable(demo ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="9-2-set-追加设置变量的值"><a href="#9-2-set-追加设置变量的值" class="headerlink" title="9.2 set 追加设置变量的值"></a>9.2 set 追加设置变量的值</h5><pre class="line-numbers language-none"><code class="language-none">set(SRC_LIST main.cpp)set(SRC_LIST ${SRC_LIST} test.cpp)add_executable(demo ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="9-3-list-追加或者删除变量的值"><a href="#9-3-list-追加或者删除变量的值" class="headerlink" title="9.3 list 追加或者删除变量的值"></a>9.3 list 追加或者删除变量的值</h5><pre class="line-numbers language-none"><code class="language-none">set(SRC_LIST main.cpp)list(APPEND SRC_LIST test.cpp)list(REMOVE_ITEM SRC_LIST main.cpp)add_executable(demo ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="10-条件控制"><a href="#10-条件控制" class="headerlink" title="10.条件控制"></a>10.条件控制</h4><h5 id="10-1-if…elseif…else…endif"><a href="#10-1-if…elseif…else…endif" class="headerlink" title="10.1 if…elseif…else…endif"></a>10.1 if…elseif…else…endif</h5><p><strong>逻辑判断和比较：</strong><br>if (expression)：expression 不为空（0,N,NO,OFF,FALSE,NOTFOUND）时为真<br>if (not exp)：与上面相反<br>if (var1 AND var2)<br>if (var1 OR var2)<br>if (COMMAND cmd)：如果 cmd 确实是命令并可调用为真<br>if (EXISTS dir) if (EXISTS file)：如果目录或文件存在为真<br>if (file1 IS_NEWER_THAN file2)：当 file1 比 file2 新，或 file1/file2 中有一个不存在时为真，文件名需使用全路径<br>if (IS_DIRECTORY dir)：当 dir 是目录时为真<br>if (DEFINED var)：如果变量被定义为真<br>if (var MATCHES regex)：给定的变量或者字符串能够匹配正则表达式 regex 时为真，此处 var 可以用 var 名，也可以用 ${var}<br>if (string MATCHES regex)</p><p><strong>数字比较：</strong><br>if (variable LESS number)：LESS 小于<br>if (string LESS number)<br>if (variable GREATER number)：GREATER 大于<br>if (string GREATER number)<br>if (variable EQUAL number)：EQUAL 等于<br>if (string EQUAL number)</p><p><strong>字母表顺序比较：</strong><br>if (variable STRLESS string)<br>if (string STRLESS string)<br>if (variable STRGREATER string)<br>if (string STRGREATER string)<br>if (variable STREQUAL string)<br>if (string STREQUAL string)</p><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">if(MSVC)    set(LINK_LIBS common)else()    set(boost_thread boost_log.a boost_system.a)endif()target_link_libraries(demo ${LINK_LIBS})# 或者if(UNIX)    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -fpermissive -g")else()    add_definitions(-D_SCL_SECURE_NO_WARNINGS    D_CRT_SECURE_NO_WARNINGS    -D_WIN32_WINNT=0x601    -D_WINSOCK_DEPRECATED_NO_WARNINGS)endif() if(${CMAKE_BUILD_TYPE} MATCHES "debug")    ...else()    ...endif()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="10-2-while…endwhile"><a href="#10-2-while…endwhile" class="headerlink" title="10.2 while…endwhile"></a>10.2 while…endwhile</h5><pre class="line-numbers language-none"><code class="language-none">while(condition)    ...endwhile()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="10-3-foreach…endforeach"><a href="#10-3-foreach…endforeach" class="headerlink" title="10.3 foreach…endforeach"></a>10.3 foreach…endforeach</h5><pre class="line-numbers language-none"><code class="language-none">foreach(loop_var RANGE start stop [step])    ...endforeach(loop_var)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>start 表示起始数，stop 表示终止数，step 表示步长，示例：</code></pre><pre class="line-numbers language-none"><code class="language-none">foreach(i RANGE 1 9 2)    message(${i})endforeach(i)# 输出：13579<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="11-打印信息"><a href="#11-打印信息" class="headerlink" title="11.打印信息"></a>11.打印信息</h4><pre class="line-numbers language-none"><code class="language-none">message(${PROJECT_SOURCE_DIR})message("build with debug mode")message(WARNING "this is warnning message")message(FATAL_ERROR "this build has many error") # FATAL_ERROR 会导致编译失败<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="12-包含其它-cmake-文件"><a href="#12-包含其它-cmake-文件" class="headerlink" title="12.包含其它 cmake 文件"></a>12.包含其它 cmake 文件</h4><pre class="line-numbers language-none"><code class="language-none">include(./common.cmake) # 指定包含文件的全路径include(def) # 在搜索路径中搜索def.cmake文件set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake) # 设置include的搜索路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="三、常用变量"><a href="#三、常用变量" class="headerlink" title="三、常用变量"></a>三、常用变量</h2><h4 id="1-预定义变量"><a href="#1-预定义变量" class="headerlink" title="1.预定义变量"></a>1.预定义变量</h4><pre class="line-numbers language-none"><code class="language-none">PROJECT_SOURCE_DIR：工程的根目录PROJECT_BINARY_DIR：运行 cmake 命令的目录，通常是 ${PROJECT_SOURCE_DIR}/buildPROJECT_NAME：返回通过 project 命令定义的项目名称CMAKE_CURRENT_SOURCE_DIR：当前处理的 CMakeLists.txt 所在的路径CMAKE_CURRENT_BINARY_DIR：target 编译目录CMAKE_CURRENT_LIST_DIR：CMakeLists.txt 的完整路径CMAKE_CURRENT_LIST_LINE：当前所在的行CMAKE_MODULE_PATH：定义自己的 cmake 模块所在的路径，SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)，然后可以用INCLUDE命令来调用自己的模块EXECUTABLE_OUTPUT_PATH：重新定义目标二进制可执行文件的存放位置LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的存放位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-环境变量"><a href="#2-环境变量" class="headerlink" title="2.环境变量"></a>2.环境变量</h4><p>使用环境变量</p><pre class="line-numbers language-none"><code class="language-none">$ENV{Name}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>写入环境变量</p><pre class="line-numbers language-none"><code class="language-none">set(ENV{Name} value) # 这里没有“$”符号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-系统信息"><a href="#3-系统信息" class="headerlink" title="3.系统信息"></a>3.系统信息</h4><pre class="line-numbers language-none"><code class="language-none">CMAKE_MAJOR_VERSION：cmake 主版本号，比如 3.4.1 中的 3CMAKE_MINOR_VERSION：cmake 次版本号，比如 3.4.1 中的 4CMAKE_PATCH_VERSION：cmake 补丁等级，比如 3.4.1 中的 1CMAKE_SYSTEM：系统名称，比如 Linux-2.6.22CMAKE_SYSTEM_NAME：不包含版本的系统名，比如 LinuxCMAKE_SYSTEM_VERSION：系统版本，比如 2.6.22CMAKE_SYSTEM_PROCESSOR：处理器名称，比如 i686UNIX：在所有的类 UNIX 平台下该值为 TRUE，包括 OS X 和 cygwinWIN32：在所有的 win32 平台下该值为 TRUE，包括 cygwin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-主要开关选项"><a href="#4-主要开关选项" class="headerlink" title="4.主要开关选项"></a>4.主要开关选项</h4><p>​        BUILD_SHARED_LIBS：这个开关用来控制默认的库编译方式，如果不进行设置，使用 add_library 又没有指定库类型的情况下，默认编译生成的库都是静态库。如果 set(BUILD_SHARED_LIBS ON) 后，默认生成的为动态库<br>CMAKE_C_FLAGS：设置 C 编译选项，也可以通过指令 add_definitions() 添加<br>CMAKE_CXX_FLAGS：设置 C++ 编译选项，也可以通过指令 add_definitions() 添加</p><pre class="line-numbers language-none"><code class="language-none">add_definitions(-DENABLE_DEBUG -DABC) # 参数之间用空格分隔<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-自定义编译选项"><a href="#5-自定义编译选项" class="headerlink" title="5.自定义编译选项"></a>5.自定义编译选项</h4><p>​        cmake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。例如，可以将 MathFunctions 库设为一个可选的库，如果该选项为 ON ，就使用该库定义的数学函数来进行运算，否则就调用标准库中的数学函数库。修改根目录下的 CMakeLists.txt 文件如下：</p><pre class="line-numbers language-none"><code class="language-none"># CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo)# 加入一个配置头文件，用于处理 CMake 对源码的设置configure_file (    "${PROJECT_SOURCE_DIR}/config.h.in"    "${PROJECT_BINARY_DIR}/config.h"    )# 是否使用自己的 MathFunctions 库option (USE_MYMATH        "Use provided math implementation" ON)# 是否加入 MathFunctions 库if (USE_MYMATH)    include_directories ("${PROJECT_SOURCE_DIR}/math")    add_subdirectory (math)    set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)endif (USE_MYMATH)# 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable(Demo ${DIR_SRCS})target_link_libraries (Demo ${EXTRA_LIBS})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>configure_file 命令用于加入一个配置头文件 config.h ，这个文件由 cmake 从 config.h.in 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。</li><li>option 命令添加了一个 USE_MYMATH 选项，并且默认值为 ON 。根据 USE_MYMATH 变量的值来决定是否使用我们自己编写的 MathFunctions 库。修改 main.cc 文件，让其根据 USE_MYMATH 的预定义值来决定是否调用标准库还是MathFunctions 库：</li></ul><pre class="line-numbers language-none"><code class="language-none">#include "config.h"#ifdef USE_MYMATH    #include "math/MathFunctions.h"#else    #include &lt;math.h&gt;#endif int main(int argc, char *argv[]){    if (argc &lt; 3){        printf("Usage: %s base exponent \n", argv[0]);        return 1;    }    double base = atof(argv[1]);    int exponent = atoi(argv[2]); #ifdef USE_MYMATH    printf("Now we use our own Math library. \n");    double result = power(base, exponent);#else    printf("Now we use the standard library. \n");    double result = pow(base, exponent);#endif    printf("%g ^ %d is %g\n", base, exponent, result);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写 config.h.in 文件<br>        注意 main.cc 的第一行，这里引用了一个 config.h 文件，这个文件预定义了 USE_MYMATH 的值。但我们并不直接编写这个文件，为了方便从 CMakeLists.txt 中导入配置，我们编写一个 config.h.in 文件，内容如下：</p><pre class="line-numbers language-none"><code class="language-none">#cmakedefine USE_MYMATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样 cmake 会自动根据 CMakeLists.txt 配置文件中的设置自动生成 config.h 文件。</p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Base64的编码原理</title>
      <link href="/2022/04/07/base64-de-bian-ma-yuan-li/"/>
      <url>/2022/04/07/base64-de-bian-ma-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="Base64的编码原理"><a href="#Base64的编码原理" class="headerlink" title="Base64的编码原理"></a><strong>Base64的编码原理</strong></h2><h3 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h3><ul><li><p>将待转换的字符串每三个字节分为一组，每个字节占8bit，那么共有24个二进制位。</p></li><li><p>将上面的24个二进制位每6个一组，共分为4组。</p></li><li><p>在每组前面添加两个0，每组由6个变为8个二进制位，总共32个二进制位，即四个字节。</p></li></ul><h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><h4 id="1-示例"><a href="#1-示例" class="headerlink" title="1.示例"></a>1.示例</h4><ul><li><p>“M”、“a”、”n”对应的ASCII码值分别为77，97，110，对应的二进制值是01001101、01100001、01101110。如图第二三行所示，由此组成一个24位的二进制字符串。</p></li><li><p>如图红色框，将24位每6位二进制位一组分成四组。</p></li><li><p>在上面每一组前面补两个0，扩展成32个二进制位，此时变为四个字节：00010011、00010110、00000101、00101110。分别对应的值（Base64编码索引）为：19、22、5、46。</p></li><li><p>用上面的值在Base64编码表中进行查找，分别对应：T、W、F、u。因此“Man”Base64编码之后就变为：TWFu。</p></li></ul><p><img src="/2022/04/07/base64-de-bian-ma-yuan-li/base64_2.png" alt="Base64编码示例1"></p><h4 id="2-位数不足情况"><a href="#2-位数不足情况" class="headerlink" title="2.位数不足情况"></a>2.<strong>位数不足情况</strong></h4><p>​        一个字节：一个字节共8个二进制位，依旧按照规则进行分组。此时共8个二进制位，每6个一组，则第二组缺少4位，用0补齐，得到两个Base64编码，而后面两组没有对应数据，都用“=”补上。因此，上图中“A”转换之后为“QQ==”；        </p><p>​        两个字节：两个字节共16个二进制位，依旧按照规则进行分组。此时总共16个二进制位，每6个一组，则第三组缺少2位，用0补齐，得到三个Base64编码，第四组完全没有数据则用“=”补上。因此，上图中“BC”转换之后为“QKM=”；</p><p><img src="/2022/04/07/base64-de-bian-ma-yuan-li/base64_2.png" alt="Base64编码示例2"></p><h4 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.<strong>注意事项</strong></h4><p>​        大多数编码都是由字符串转化成二进制的过程，而Base64的编码则是从二进制转换为字符串。与常规恰恰相反，Base64编码主要用在传输、存储、表示二进制领域，不能算得上加密，只是无法直接看到明文。也可以通过打乱Base64编码来进行加密。中文有多种编码（比如：utf-8、gb2312、gbk等），不同编码对应Base64编码结果都不一样。</p><h4 id="4-延伸"><a href="#4-延伸" class="headerlink" title="4.延伸"></a>4.<strong>延伸</strong></h4><p>​        上面我们已经看到了Base64就是用6位（2的6次幂就是64）表示字符，因此成为Base64。同理，Base32就是用5位，Base16就是用4位。大家可以按照上面的步骤进行演化一下。</p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Base64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2022/04/06/wei-yun-suan/"/>
      <url>/2022/04/06/wei-yun-suan/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>[TOC]</p><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>基本的位操作符有与、或、异或、取反、左移、右移这6种:</p><table><thead><tr><th>符号</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td><td>两个bit都为1，才为1</td></tr><tr><td>|</td><td>或</td><td>两个bit都为0，才为0</td></tr><tr><td>^</td><td>异或</td><td>两个bit相同为0，不同为1</td></tr><tr><td>~</td><td>取反</td><td>0变1，1变0</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>左移若干位，高位丢弃，低位补0</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>右移若干位，无符号数高位补0，有符号数不同编译器处理不同，有的补符号位（算术右移），有的补0（逻辑右移）</td></tr></tbody></table><h2 id="位运算示例操作"><a href="#位运算示例操作" class="headerlink" title="位运算示例操作"></a>位运算示例操作</h2><table><thead><tr><th>位运算</th><th>功能</th><th>示例</th><th></th></tr></thead><tbody><tr><td>x &gt;&gt; 1</td><td>去掉最后一位</td><td>101101-&gt;10110</td><td></td></tr><tr><td>x &lt;&lt; 1</td><td>在最后加一个0</td><td>101101-&gt;1011010</td><td></td></tr><tr><td>x &lt;&lt; 1</td><td>在最后加一个1</td><td>101101-&gt;1011011</td><td></td></tr><tr><td>x\</td><td>1</td><td>把最后一位变成1</td><td>101100-&gt;101101</td></tr><tr><td>x &amp; -2</td><td>把最后一位变成0</td><td>101101-&gt;101100</td><td></td></tr><tr><td>x ^ 1</td><td>最后一位取反</td><td>101101-&gt;101100</td><td></td></tr><tr><td>x \</td><td>(1 &lt;&lt; (k-1))</td><td>把右数第k位变成1</td><td>101001-&gt;101101,k=3</td></tr><tr><td>x &amp; ~ (1 &lt;&lt; (k-1))</td><td>把右数第k位变成0</td><td>101101-&gt;101001,k=3</td><td></td></tr><tr><td>x ^(1 &lt;&lt;(k-1))</td><td>右数第k位取反</td><td>101001-&gt;101101,k=3</td><td></td></tr><tr><td>x &amp; 7</td><td>取末三位</td><td>1101101-&gt;101</td><td></td></tr><tr><td>x &amp; (1 &lt;&lt; k-1)</td><td>取末k位</td><td>1101101-&gt;1101,k=5</td><td></td></tr><tr><td>x &gt;&gt; (k-1) &amp; 1</td><td>取右数第k位</td><td>1101101-&gt;1,k=4</td><td></td></tr><tr><td>x \</td><td>((1 &lt;&lt; k)-1)</td><td>把末k位变成1</td><td>101001-&gt;101111,k=4</td></tr><tr><td>x ^ (1 &lt;&lt; k-1)</td><td>末k位取反</td><td>101001-&gt;100110,k=4</td><td></td></tr><tr><td>x &amp; (x+1)</td><td>把右边连续的1变成0</td><td>100101111-&gt;100100000</td><td></td></tr><tr><td>x \</td><td>(x+1)</td><td>把右起第一个0变成1</td><td>100101111-&gt;100111111</td></tr><tr><td>x \</td><td>(x-1)</td><td>把右边连续的0变成1</td><td>11011000-&gt;11011111</td></tr><tr><td>(x ^ (x+1)) &gt;&gt; 1</td><td>取右边连续的1</td><td>100101111-&gt;1111</td><td></td></tr><tr><td>x &amp; -x</td><td>去掉右起第一个1的左边</td><td>100101000-&gt;1000</td><td></td></tr><tr><td>x&amp;0x7F</td><td>取末7位</td><td>100101000-&gt;101000</td><td></td></tr><tr><td>x&amp; ~0x7F</td><td>是否小于127</td><td>001111111 &amp; ~0x7F-&gt;0</td><td></td></tr><tr><td>x &amp; 1</td><td>判断奇偶</td><td>00000111&amp;1-&gt;1</td><td></td></tr></tbody></table><p>使用位运算的两点注意事项：</p><ol><li>位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。</li><li>位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序</li></ol><h3 id="1-判断一个数值是不是2的整数次方"><a href="#1-判断一个数值是不是2的整数次方" class="headerlink" title="1. 判断一个数值是不是2的整数次方"></a>1. 判断一个数值是不是2的整数次方</h3><p>解题思路：</p><p>2的整数次方对应的二进制的最高位上只有一个1，如：8，二进制为 1000； 4，二进制为 0100，</p><p>那么将该数字减去1再与该数字进行与运算，减去1 后得到二进制：7，二进制为 0111；3，二进制为 0011，可以看出 8&amp;7 为0，</p><p>4&amp;3 为0</p><p>所以，如果 n 是2的整数次方，那么 n &amp; ( n - 1 )结果一定为0:</p><p>n 的数值要大于 0 </p><h3 id="2-使用位运算交换两个数字【不使用中间变量】"><a href="#2-使用位运算交换两个数字【不使用中间变量】" class="headerlink" title="2. 使用位运算交换两个数字【不使用中间变量】"></a>2. 使用位运算交换两个数字【不使用中间变量】</h3><pre class="line-numbers language-none"><code class="language-none">1.  public class Main {3.      public static void main(String[] args) {4.          int n = 8, m = 10;5.          n ^= m;6.          m ^= n;7.          n ^= m;8.          System.out.println(n + ", " + m);9.      }10.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如： a = 13, b = 6:<br>a的二进制为 13 = 8 + 4 + 1 = 1101(二进制)<br>b的二进制为 6 = 4 + 2 = 110(二进制)</p><ol><li>a ^= b a = 1101 ^ 110 = 1011;</li><li>b ^= a b = 110 ^ 1011 = 1101; 即b == 13</li><li>a ^= b a = 1011 ^ 1101 = 110; 即a == 6</li></ol><p>其他方法，<strong>使用加减法</strong></p><pre class="line-numbers language-none"><code class="language-none">1.  public class Main {3.      public static void main(String[] args) {4.          int n = 8, m = 10;5.          n = n + m;6.          m = n - m;7.          n = n - m;8.          System.out.println(n + ", " + m);9.      }10.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-计算在一个-32-位的整数的二进制表示中有多少个-1"><a href="#3-计算在一个-32-位的整数的二进制表示中有多少个-1" class="headerlink" title="3. 计算在一个 32 位的整数的二进制表示中有多少个 1"></a>3. 计算在一个 32 位的整数的二进制表示中有多少个 1</h3><p>循环使用x &amp; (x-1)消去最后一位1，计算总共消去了多少次即可。如：</p><p>13： 1101</p><p>12： 1100</p><p>相与：1100， 消去最后一位</p><pre class="line-numbers language-none"><code class="language-none">1.  public class Main {3.      public static void main(String[] args) {4.          // 计算在一个 32 位的整数的二进制表示中有多少个 15.          int m = 13, num = 0;6.          while (true){7.              if (m == 0) break;8.              m &amp;= (m-1); 9.              num ++; 10.          }11.          System.out.println(num);12.      }14.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-正数变成负数，或者负数变成正数"><a href="#4-正数变成负数，或者负数变成正数" class="headerlink" title="4. 正数变成负数，或者负数变成正数"></a>4. 正数变成负数，或者负数变成正数</h3><p><strong>变换符号只需要取反后加1即可</strong></p><pre class="line-numbers language-none"><code class="language-none">1.  public class Main {3.      public static void main(String[] args) { 5.          int m = -13; 6.          int changeM = ~m + 1; 7.          System.out.println(changeM);8.      }10.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-判断一个数值的奇偶"><a href="#5-判断一个数值的奇偶" class="headerlink" title="5. 判断一个数值的奇偶"></a>5. 判断一个数值的奇偶</h3><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数，所以只需要与 1 相与。</p><p>因此可以用if ((a &amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。</p><pre class="line-numbers language-none"><code class="language-none">1.  public class Main {3.      public static void main(String[] args) {  4.          int m = -14;6.          if ((m &amp; 1) == 1){7.              System.out.println("ji");8.          }else{9.              System.out.println("ou"); 10.          }  11.      }13.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-乘以2-的m次方操作"><a href="#6-乘以2-的m次方操作" class="headerlink" title="6. 乘以2 的m次方操作"></a>6. 乘以2 的m次方操作</h3><p>乘以2的操作，即2的1次方，左移 1 位</p><pre class="line-numbers language-none"><code class="language-none">System.out.println(10&lt;&lt;1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>推导扩展，乘以2的m次方：</p><pre class="line-numbers language-none"><code class="language-none">System.out.println(10&lt;&lt;2); // 乘以 2的2次方，相当于乘以 4 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-除以2运算-负奇数的运算不可用"><a href="#7-除以2运算-负奇数的运算不可用" class="headerlink" title="7.除以2运算(负奇数的运算不可用)"></a>7.除以2运算(负奇数的运算不可用)</h3><pre class="line-numbers language-none"><code class="language-none">System.out.println(10&gt;&gt;1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="8-转换成绝对值"><a href="#8-转换成绝对值" class="headerlink" title="8. 转换成绝对值"></a>8. 转换成绝对值</h3><pre class="line-numbers language-none"><code class="language-none">1.  public class Main {3.      public static void main(String[] args) {  4.          int n = 12;6.          System.out.println(0 &gt;&gt; 31); // 0 7.          System.out.println(10 &gt;&gt; 31);  // 0  8.          System.out.println(-10 &gt;&gt; 31);  // -110.          System.out.println((n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31));  // 12 12.      }14.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.首先：n&gt;&gt;31 取得n的符号</p><p>若n为正数，n&gt;&gt;31等于0；若n为负数，n&gt;&gt;31等于-1 若n为正数 n^0-0数不变；</p><ol><li>若 n 为负数 n^-1 需要计算 n 和 -1 的补码，异或后再取补码， 结果n变号并且绝对值减1，再减去-1就是绝对值</li></ol><h3 id="9-判断两数符号是否相同"><a href="#9-判断两数符号是否相同" class="headerlink" title="9.判断两数符号是否相同"></a>9.判断两数符号是否相同</h3><p>true 表示 x和y有相同的符号， false表示x，y有相反的符号。</p><pre class="line-numbers language-none"><code class="language-none">System.out.println((a ^ b) &gt; 0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="10-求两个整数（int）的平均数"><a href="#10-求两个整数（int）的平均数" class="headerlink" title="10. 求两个整数（int）的平均数"></a>10. 求两个整数（int）的平均数</h3><pre class="line-numbers language-none"><code class="language-none">System.out.println((a+b) &gt;&gt; 1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="11-求两个整数的最大值"><a href="#11-求两个整数的最大值" class="headerlink" title="11. 求两个整数的最大值"></a>11. 求两个整数的最大值</h3><pre class="line-numbers language-none"><code class="language-none">1.  int max(int a,int b){2.      return b &amp; ((a-b) &gt;&gt; 31) | a &amp; (~(a-b) &gt;&gt; 31);3.      /*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/4.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-求两个整数的最小值"><a href="#12-求两个整数的最小值" class="headerlink" title="12.求两个整数的最小值"></a>12.求两个整数的最小值</h3><pre class="line-numbers language-none"><code class="language-none">1.  int min(int a,int b){2.      return a &amp; ((a-b) &gt;&gt; 31) | b &amp; (~(a-b) &gt;&gt; 31);3.      /*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/4.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-两个整数的加法运算"><a href="#13-两个整数的加法运算" class="headerlink" title="13. 两个整数的加法运算"></a>13. <strong>两个整数的加法运算</strong></h3><p>使用 <code>^</code> 和 <code>&amp;</code> 将两个整数相加</p><ol><li>两个数异或：相当于两个数相加，而不考虑进位；</li><li>两个数相与，并左移一位：相当于求得进位；</li></ol><pre class="line-numbers language-none"><code class="language-none">13+11 = ？;13 的二进制      1 1 0 1                     -----a        1311 的二进制      1 0 1 1                     -----b        11   (a&amp;b) &lt;&lt;1  -&gt;   1 0 0 1 0                         -----d         18          a^b  -&gt;     0 1 1 0                   -----e          6 (d&amp;e) &lt;&lt;1  -&gt;   0 0 1 0 0                       ------f         4          d^e  -&gt;  1 0 1 0 0                  -----g        20 (f&amp;g) &lt;&lt;1  -&gt;   0 1 0 0 0                       ------h        8          f^g  -&gt;  1 0 0 0 0                   ------i           16 (h&amp;i) &lt;&lt;1  -&gt;   0 0 0 0 0                      ------h        0       ---- -------- 没有进位了， 则退出循环          h^i  -&gt;  1 1 0 0 0                  ------i           24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">1.  private static int getSum(int a, int b) {2.      if (a == 0) return b;3.      if (b == 0) return a;4.      while (b != 0) {5.          int carry = a &amp; b; // 得到有进位的位置6.          a = a ^ b; // 直接相加，但是没有进位7.          b = carry &lt;&lt; 1; // 得到进位8.      }9.      return a;10.  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程的理解</title>
      <link href="/2022/04/05/mian-xiang-dui-xiang-bian-cheng-de-li-jie/"/>
      <url>/2022/04/05/mian-xiang-dui-xiang-bian-cheng-de-li-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h2><h3 id="面向过程思想概述"><a href="#面向过程思想概述" class="headerlink" title="面向过程思想概述"></a>面向过程思想概述</h3><p>面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。</p><h3 id="面向对象思想概述"><a href="#面向对象思想概述" class="headerlink" title="面向对象思想概述"></a>面向对象思想概述</h3><p>当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了，这时就开始思索，能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。面向对象是基于面向过程的编程思想。</p><h2 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h2><ul><li>抽象</li><li>封装</li><li>继承</li><li>多态</li></ul><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>把现实世界中的某一类东西，提取出来，用程序代码表示，抽象出来的一般叫做类或者接口。抽象并不打算了解全部问题，而是选择其中的一部分，暂时不用部分细节。抽象包括两个方面：</p><ul><li>数据抽象：表示世界中一类事物的特征,就是对象的属性.比如鸟有翅膀,羽毛等(类的属性)</li><li>过程抽象：表示世界中一类事物的行为,就是对象的行为.比如鸟会飞,会叫(类的方法)</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。隐藏之后，外部程序就不能接触和改变那些细节，所以不用担心自己的类会受到非法修改，可确保它们不会对其他程序造成影响。</p><h4 id="封装的原则"><a href="#封装的原则" class="headerlink" title="封装的原则"></a>封装的原则</h4><ul><li>将不需要对外提供的内容都隐藏起来</li><li>把属性都隐藏，提供公共方法对其访问</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>一种联结类的层次模型，并且允许和鼓励类的重用，提供一种明确表达共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类(子类)，原始类称为新类的基类(父类)。派生类可以从它的父类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。因此可以说，继承为了重用父类代码，同时为实现多态性作准备。</p><h4 id="继承概念的实现方式"><a href="#继承概念的实现方式" class="headerlink" title="继承概念的实现方式"></a>继承概念的实现方式</h4><ul><li>类继承：类继承是指直接使用基类的属性和方法而无需额外编码。</li><li>接口继承：接口继承是指仅使用属性和方法的名称、但是子类必须提供实现。</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><h4 id="实现多态的方式"><a href="#实现多态的方式" class="headerlink" title="实现多态的方式"></a>实现多态的方式</h4><ul><li>重载</li><li>重写</li><li>实现接口</li></ul><h2 id="面向对象总结"><a href="#面向对象总结" class="headerlink" title="面向对象总结"></a>面向对象总结</h2><p>封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了<strong>代码重用</strong>。而多态则是为了实现另一个目的：<strong>接口重用</strong>！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。</p><h3 id="面向对象开发"><a href="#面向对象开发" class="headerlink" title="面向对象开发"></a>面向对象开发</h3><p>就是不断的创建对象，使用对象，指挥对象做事情。</p><h3 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h3><p>更好的管理和维护对象之间的关系。</p><h3 id="面向对象优点"><a href="#面向对象优点" class="headerlink" title="面向对象优点"></a>面向对象优点</h3><ul><li>更符合我们思想习惯的思想</li><li>将复杂的事情简单化</li><li>将我们从执行者变成了指挥者</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源许可协议 GNU GPL</title>
      <link href="/2022/04/04/kai-yuan-xu-ke-xie-yi-gnu-gpl/"/>
      <url>/2022/04/04/kai-yuan-xu-ke-xie-yi-gnu-gpl/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>​        在开源领域中，许可协议是指开源社区为了维护作者和贡献者的合法权利，保证软件不被一些商业机构或个人窃取，影响软件的发展而开发的协议。其中，GPL是开源许可协议中非常流行的许可协议之一。</p><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a><strong>一、基本概念</strong></h2><p><img src="/2022/04/04/kai-yuan-xu-ke-xie-yi-gnu-gpl/GPL.png" alt="GPL标志"></p><p>​        GNU通用公共许可协议（英语：GNU General Public License，缩写GNU GPL 或 GPL），GPL是由理查德·斯托曼于1989年编写，最初提供给列入GNU项目的一些软件程序所使用。</p><p>​        GPL是自由软件和开源软件的最流行许可证。到2004年4月，GPL已占Freshmeat上所列的自由软件的约75%，SourceForge的约68%。类似的，2001年一项关于Red Hat Linux 7.1的调查显示一般的代码都以GPL发布。</p><h2 id="二、协议特点"><a href="#二、协议特点" class="headerlink" title="二、协议特点"></a><strong>二、协议特点</strong></h2><h3 id="2-1-传染性"><a href="#2-1-传染性" class="headerlink" title="2.1 传染性"></a><strong>2.1 传染性</strong></h3><p>​        GPL协议具有一个很显著的特点“传染性” ：即当具有GPL协议的软件与其它协议的软件相组合或者GPL的衍生产品，必须按照GPL的条款分发。“衍生产品”通常被解释为包含GPL代码或动态链接到GPL库的软件。GPL下所有衍生产品都必须属于GPL，许可证是根据著作权法运行的。</p><h3 id="2-2-可商用"><a href="#2-2-可商用" class="headerlink" title="2.2 可商用"></a><strong>2.2 可商用</strong></h3><p>​        GPL软件可以用于盈利，可以以任何价格出售，可以作为创建专有软件的工具（例如：GPL协议的编译器）。</p><h2 id="三、使用者的自由"><a href="#三、使用者的自由" class="headerlink" title="三、使用者的自由"></a><strong>三、使用者的自由</strong></h2><h3 id="1-自由运行"><a href="#1-自由运行" class="headerlink" title="1. 自由运行"></a><strong>1. 自由运行</strong></h3><p>​    可以按照自己的意愿运行软件；</p><h3 id="2-自由修改"><a href="#2-自由修改" class="headerlink" title="2. 自由修改"></a><strong>2. 自由修改</strong></h3><p>可以按己的意愿修改软件；</p><h3 id="3-自由复制"><a href="#3-自由复制" class="headerlink" title="3. 自由复制"></a><strong>3. 自由复制</strong></h3><p>可以自由分发软件副本；</p><h3 id="4-自由分发"><a href="#4-自由分发" class="headerlink" title="4. 自由分发"></a><strong>4. 自由分发</strong></h3><p>可以将你修改过的软件版本再分发给其他人，从而回馈开源，促进开源；</p><h2 id="四、符合GPL协议的软件"><a href="#四、符合GPL协议的软件" class="headerlink" title="四、符合GPL协议的软件"></a><strong>四、符合GPL协议的软件</strong></h2><p>著名的GPL自由软件包括EMACS，Linux内核（并非所有Linux发行版的内核都是开源的）和<a href="https://so.csdn.net/so/search?q=GCC&amp;spm=1001.2101.3001.7020">GCC</a>。</p><h2 id="五、GPL发展阶段"><a href="#五、GPL发展阶段" class="headerlink" title="五、GPL发展阶段"></a><strong>五、GPL发展阶段</strong></h2><p><strong>GPLv1：</strong>解决了软件经销商只分发软件的二进制，而不提供软件源码的问题；要求符合GPL的软件与其它软件组合后的整体必须以GPLv1条款分发，限制了经销商增加许可证的限制；</p><p><strong>GPLv2：</strong>规定被许可人只有在满足所有许可证的义务下才可以分发包含GPL许可的软件，就算有相互矛盾的义务，许可证的义务也可能不被切断，阻止任何一方使用专利侵权索赔或其他诉讼来损害用户在许可证下的自由；</p><p>**GPLv3提高了与许多开放源代码软件许可证（如Apache许可证版本2.0）和GNU Affero通用公共许可证（GPLv2无法组合）的兼容性；比较有意思的是，林纳斯·托瓦兹（Linux内核的发明人及该计划的合作者）决定不采用GPLv3作为Linux内核的许可协议，仍然使用GPLv2许可。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>GPL 维护了代码所有者的合法权益，保证了代码以及其衍生产品的开源，从而促进了代码的开源，让众多的软件开发者不断地从中收益，同时也不断的回馈开源社区，让开源队伍越来越壮大！</p>]]></content>
      
      
      <categories>
          
          <category> 开源协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几种常见的开源协议介绍</title>
      <link href="/2022/04/03/ji-chong-chang-jian-de-kai-yuan-xie-yi-jie-shao/"/>
      <url>/2022/04/03/ji-chong-chang-jian-de-kai-yuan-xie-yi-jie-shao/</url>
      
        <content type="html"><![CDATA[<h1 id="开源协议介绍"><a href="#开源协议介绍" class="headerlink" title="开源协议介绍"></a>开源协议介绍</h1><p>[TOC]</p><h2 id="一、几种常见的开源协议介绍"><a href="#一、几种常见的开源协议介绍" class="headerlink" title="一、几种常见的开源协议介绍"></a>一、几种常见的开源协议介绍</h2><p>常用的几种开源协议：</p><ul><li><p><strong>GPL （GNU General Public License） ：GNU通用公共许可协议</strong></p></li><li><p><strong>LGPL （GNU Lesser General Public License） ：GNU宽通用公共许可协议</strong></p></li><li><p><strong>BSD (Berkeley Software Distribution) :伯克利软件分发许可协议</strong></p></li><li><p><strong>MIT （Massachusetts Institute of Technology）：MIT许可协议之名源自麻省理工学院，又称“X许可协议”或“X11许可协议”</strong></p></li><li><p><strong>Apache （Apache License） ：Apache许可协议</strong></p></li><li><p><strong>MPL （Mozilla Public License） ：Mozilla公共许可协议</strong></p></li></ul><h3 id="1-BSD协议"><a href="#1-BSD协议" class="headerlink" title="1.BSD协议"></a>1.BSD协议</h3><p>​        BSD开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。但前提是发布使用了BSD协议的代码，或以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： </p><ul><li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li><li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 </li></ul><p>​        BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p><h3 id="2-MIT协议"><a href="#2-MIT协议" class="headerlink" title="2.MIT协议"></a>2.MIT协议</h3><p>​        MIT是和BSD一样宽范的许可协议，源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称X11协议。作者只想保留版权,而无任何其他了限制。MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。<br>​        MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。 </p><ul><li>被授权人有权利使用、复制、修改、合并、出版发行、散布、再授权及贩售软件及软件的副本。</li><li>被授权人可根据程序的需要修改授权条款为适当的内容。</li><li>在软件和软件的所有副本中都必须包含版权声明和许可声明。 </li></ul><p>​        此授权条款并非属copyleft的自由软件授权条款，允许在自由/开放源码软件或非自由软件（proprietary software）所使用。MIT的内容可依照程序著作权者的需求更改内容。此亦为MIT与BSD（The BSD license, 3-clause BSD license）本质上不同处。MIT条款可与其他授权条款并存。另外，MIT条款也是自由软件基金会（FSF）所认可的自由软件授权条款，与GPL兼容。</p><h3 id="3-Apache-协议"><a href="#3-Apache-协议" class="headerlink" title="3.Apache 协议"></a>3.Apache 协议</h3><p>​        Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件： </p><ol><li>需要给代码的用户一份Apache Licence。</li><li>如果修改了代码，需要再被修改的文件中说明。</li><li>在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li><li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。 </li></ol><p>使用这个协议的好处是: </p><ol><li>永久权利：一旦被授权，永久拥有。</li><li>全球范围的权利：在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。</li><li>授权免费：无版税， 前期、后期均无任何费用。</li><li>授权无排他性：任何人都可以获得授权</li><li>授权不可撤消 一旦获得授权，没有任何人可以取消。 </li></ol><p>Apache Licence也是对商业应用友好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。</p><h3 id="4-GPL协议"><a href="#4-GPL协议" class="headerlink" title="4.GPL协议"></a>4.GPL协议</h3><p>GPL（ GNU General Public Licence ）的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。Linux就是采用了GPL协议。</p><ol><li>可自由复制：你可以将软件复制到你的电脑，你客户的电脑，或者任何地方。复制份数没有任何限制。</li><li>可自由分发：在你的网站提供下载，拷贝到U盘送人，或者将源代码打印出来从窗户扔出去（环保起见，请别这样做）。</li><li>可以用来盈利：你可以在分发软件的时候收费，但你必须在收费前向你的客户提供该软件的 GNU GPL 许可协议，以便让他们知道，他们可以从别的渠道免费得到这份软件，以及你收费的理由。</li><li>可自由修改：如果你想添加或删除某个功能，没问题，如果你想在别的项目中使用部分代码，也没问题，唯一的要求是，使用了这段代码的项目也必须使用 GPL 协议。 </li></ol><p>还有一些要求 </p><ol><li>如果你使用了GPL协议的开源代码，将此开源代码用在了你的软件产品里，那么，你的整个软件产品必须开源，而且必须以GPL协议开源。</li><li>如果软件以GPL协议开源，那么源代码必须是面向社会开源的。而且你发布产品的时候源代码也必须一同附上。</li><li>如果软件以GPL协议开源，那么你可以对该软件收取一定的服务费用，但你永远不能对该软件的源代码收费。</li></ol><p>5.LGPL协议<br>        LGPL 是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并 发布和销售。 </p><p>​        但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因 此LGPL协议的开源 代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。 </p><p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p><h3 id="6-MPL"><a href="#6-MPL" class="headerlink" title="6.MPL"></a><strong>6.MPL</strong></h3><p>​        MPL既是得到自由软件基金会承认的自由软件许可证，也是得到开放源代码促进会承认的开源软件许可证。MPL允许在其授权下的源代码与其他授权的文件进行混合，包括私有许可证。但在MPL授权下的代码文件必须保持MPL授权，并且保持开源。这样的条款让MPL既不像MIT和BSD那样允许派生作品完全转化为私有，也不像GPL那样要求所有的派生作品，包括新的组件在内，全部必须保持GPL。通过允许在派生项目中存在私有模块，同时保证核心文件的开源，MPL同时激励了商业及开源社区来参与帮助开发核心软件。</p><p>​        使用MPL授权的软件并不受专利的限制，其可以自由使用，修改，并可自由的重新发布。带有专利代码的版本仍然可以使用，转让，甚至出售，但未经许可则不能修改代码。此外，MPL并不授予用户对于开发者商标的使用权。</p><p>​        为了满足MPL的条款限制，用户必须负担一些“责任”，主要是关于散发使用MPL授权的软件。用户必须确保重新散发的软件所有源代码均以MPL授权，即使是以可执行文件的方式提供或是与其他使用专有软件授权的源代码结合也一样。但若跟以GNU通用公共许可协议、GNU宽通用公共许可证、Affero通用公共许可证授权的源代码结合则是例外。此时开发者则可选用以上三种更加严格的条款来授权。</p><h2 id="二、开源协议选择"><a href="#二、开源协议选择" class="headerlink" title="二、开源协议选择"></a>二、开源协议选择</h2><p>按照使用条件的不同，开源软件许可证可以分为三类（严苛程度递减）。 </p><p>第一类使用该开源软件的代码再散布（redistribute）时，源码也必须以相同许可证公开。代表许可类型 GPL，AGPL。 </p><p>第二类使用该开源软件的代码并且对开源代码有所修改后再散布时，源码必须以相同许可证公开。如LGPL，CPL，CDDL，CPL，MPL等。 </p><p>第三类用该开源软件的代码（包括修改）再散布（redistribute）时，没有特殊限制，只需要明记许可。如ASL，BSD，MIT等。</p><p><img src="/2022/04/03/ji-chong-chang-jian-de-kai-yuan-xie-yi-jie-shao/%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE.png" alt="开源协议选择"></p>]]></content>
      
      
      <categories>
          
          <category> 开源协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码整洁之道内容概要</title>
      <link href="/2022/04/02/dai-ma-zheng-ji-zhi-dao-nei-rong-gai-yao/"/>
      <url>/2022/04/02/dai-ma-zheng-ji-zhi-dao-nei-rong-gai-yao/</url>
      
        <content type="html"><![CDATA[<p>读了代码整洁之道，觉得这本书写的很好，所以就将里面自己觉得很经典的内容记录下来，作为自己以后写代码的标准和准则。同时也为那些曾经困惑过的人一点参考吧！</p><h2 id="一、在正式开始之前，我们先思考几个几个问题："><a href="#一、在正式开始之前，我们先思考几个几个问题：" class="headerlink" title="一、在正式开始之前，我们先思考几个几个问题："></a>一、在正式开始之前，我们先思考几个几个问题：</h2><h3 id="1-需求与代码哪个重要？"><a href="#1-需求与代码哪个重要？" class="headerlink" title="1.需求与代码哪个重要？"></a>1.需求与代码哪个重要？</h3><p>答：并不是所有的产品都能提出合理的需求，当你面对一个提出不合理需求的产品的时候，你需要坚持自己的原则，不能妥协。</p><h3 id="2-易读和易懂是一回事吗？"><a href="#2-易读和易懂是一回事吗？" class="headerlink" title="2.易读和易懂是一回事吗？"></a>2.易读和易懂是一回事吗？</h3><p>答：易读的代码和易懂的代码是有区别的，不是易读的代码就是易懂的代码。</p><h3 id="3-什么是测试驱动代码？"><a href="#3-什么是测试驱动代码？" class="headerlink" title="3.什么是测试驱动代码？"></a>3.什么是测试驱动代码？</h3><p>答：测试驱动代码，你写的代码要可以执行单元测试。如果你发现你的代码很难写单元测试，那么你就要思考你的代码是不是已经不整洁了，或者说已经乱成一团了。</p><h3 id="4-什么是简单的代码？"><a href="#4-什么是简单的代码？" class="headerlink" title="4.什么是简单的代码？"></a>4.什么是简单的代码？</h3><p>答：<br>1.能通过所有测试<br>2.没有重复代码<br>3.体现系统中全部设计理念<br>4.包含尽量少的实体，包括，类，函数，方法等</p><p>如果某段代码在程序设计中反复出现，就证明想法在代码中没有很好的体现出来。总之，不要重复代码，只做一件事，表达力，小规模抽象。</p><h2 id="二、第二章-有意义的命名"><a href="#二、第二章-有意义的命名" class="headerlink" title="二、第二章 有意义的命名"></a>二、第二章 有意义的命名</h2><h3 id="1-名副其实"><a href="#1-名副其实" class="headerlink" title="1.名副其实"></a>1.名副其实</h3><p>变量，函数或类的名称应该已经答复了所有的大问题。它应该告诉你，它为什么会存在，它做什么事情，应该怎么用。如果名称需要注释来补充，那么就不算名副其实。</p><h3 id="2-避免误导"><a href="#2-避免误导" class="headerlink" title="2.避免误导"></a>2.避免误导</h3><p>必须避免留下掩藏代码本意的错误线索。</p><h3 id="3-做有意义的区分"><a href="#3-做有意义的区分" class="headerlink" title="3.做有意义的区分"></a>3.做有意义的区分</h3><p>只要体现出有意义的区分，使用a和the这样的前缀就没有错。废话就是冗余。</p><h3 id="4-使用读得出来的名称"><a href="#4-使用读得出来的名称" class="headerlink" title="4.使用读得出来的名称"></a>4.使用读得出来的名称</h3><p>不要用傻乎乎的自造词，而不是恰当的英语词。</p><h3 id="5-使用可搜索的名称"><a href="#5-使用可搜索的名称" class="headerlink" title="5.使用可搜索的名称"></a>5.使用可搜索的名称</h3><p>使用便于搜索的名字。</p><h3 id="6-避免使用编码"><a href="#6-避免使用编码" class="headerlink" title="6.避免使用编码"></a>6.避免使用编码</h3><p>把类型或者作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的代码之外，还要再搞懂另一种编码”语言”。</p><h3 id="7-避免思维映射"><a href="#7-避免思维映射" class="headerlink" title="7.避免思维映射"></a>7.避免思维映射</h3><p>不应当让读者在脑中把你的名称翻译为他们熟知的名称，尤其是在经常出现在选择是使用问题领域术语还是解决方案领域术语的时候。</p><h3 id="8-类名或对象名最好使用名词或者名词短语"><a href="#8-类名或对象名最好使用名词或者名词短语" class="headerlink" title="8.类名或对象名最好使用名词或者名词短语"></a>8.类名或对象名最好使用名词或者名词短语</h3><h3 id="9-方法名最好使用动词或者动词短语"><a href="#9-方法名最好使用动词或者动词短语" class="headerlink" title="9.方法名最好使用动词或者动词短语"></a>9.方法名最好使用动词或者动词短语</h3><h3 id="10-别扮可爱"><a href="#10-别扮可爱" class="headerlink" title="10.别扮可爱"></a>10.别扮可爱</h3><p>命名一定要通俗易懂。</p><h3 id="11-每一个概念对应一个词"><a href="#11-每一个概念对应一个词" class="headerlink" title="11.每一个概念对应一个词"></a>11.每一个概念对应一个词</h3><p>给每个抽象概念选择一个词，并一以贯之</p><h3 id="12-别用双关语词"><a href="#12-别用双关语词" class="headerlink" title="12.别用双关语词"></a>12.别用双关语词</h3><p>避免将同一个词用于不同目的，遵循一词一义的原则</p><h3 id="13-使用解决方案领域名"><a href="#13-使用解决方案领域名" class="headerlink" title="13.使用解决方案领域名"></a>13.使用解决方案领域名</h3><h3 id="14-使用源自所涉领域名"><a href="#14-使用源自所涉领域名" class="headerlink" title="14.使用源自所涉领域名"></a>14.使用源自所涉领域名</h3><h3 id="15-添加有意义的语境"><a href="#15-添加有意义的语境" class="headerlink" title="15.添加有意义的语境"></a>15.添加有意义的语境</h3><p>在一个bean中定义变量名的时候，变量名一定是基于实际使用场景。</p><h3 id="16-不要添加没用的语境"><a href="#16-不要添加没用的语境" class="headerlink" title="16.不要添加没用的语境"></a>16.不要添加没用的语境</h3><h2 id="三、第三章-函数"><a href="#三、第三章-函数" class="headerlink" title="三、第三章 函数"></a>三、第三章 函数</h2><h3 id="1-短小"><a href="#1-短小" class="headerlink" title="1.短小"></a>1.短小</h3><p>函数第一规则是要短小。第二条规则是还要更短小。</p><h3 id="2-只做一件事"><a href="#2-只做一件事" class="headerlink" title="2.只做一件事"></a>2.只做一件事</h3><ul><li>函数应该做一件事。做好这件事。只做一件事。如果可以从你的函数中还能拆分出一个函数，该函数不仅只是单纯地重新诠释其实现，那么你设计的函数就不是一个好的函数。</li><li>函数中的区段，如果函数被切分了多个区段，这就证明该函数做的事情太多了。</li></ul><h3 id="3-每个函数一个抽象层级"><a href="#3-每个函数一个抽象层级" class="headerlink" title="3.每个函数一个抽象层级"></a>3.每个函数一个抽象层级</h3><h3 id="4-switch语句"><a href="#4-switch语句" class="headerlink" title="4.switch语句"></a>4.switch语句</h3><p>确保每个switch都埋藏在较低的抽象层级，而且永远不重复。</p><h3 id="5-使用描述性的名称"><a href="#5-使用描述性的名称" class="headerlink" title="5.使用描述性的名称"></a>5.使用描述性的名称</h3><p>命名方式要保持一致。使用与模块名一脉相承的短语、名词和动词给函数命名。例如：includeSetupPages。</p><h3 id="6-函数参数"><a href="#6-函数参数" class="headerlink" title="6.函数参数"></a>6.函数参数</h3><ul><li>最理想的函数参数的数量是零个，其次是一，再次是二，应尽量避免三。有足够的理由才能用上三个以上的参数。</li><li>如果函数看来需要两个，三个或者三个以上参数，就说明其中一些参数应该封装为类了。</li><li>函数和函数的参数命名一般是动名词比较好。</li></ul><h3 id="7-无副作用"><a href="#7-无副作用" class="headerlink" title="7.无副作用"></a>7.无副作用</h3><h3 id="8-分割指令与查询"><a href="#8-分割指令与查询" class="headerlink" title="8.分割指令与查询"></a>8.分割指令与查询</h3><p>函数要么做什么事，要么回答什么事，但二者不可兼得</p><h3 id="9-使用异常替代返回错误码"><a href="#9-使用异常替代返回错误码" class="headerlink" title="9.使用异常替代返回错误码"></a>9.使用异常替代返回错误码</h3><ul><li>返回错误码的时候，就是在要求调用者立刻处理错误。</li><li>如果使用异常替代返回错误码，错误处理代码就能从住路径代码中分离出来，得到简化。</li><li>抽离try/catch代码块</li></ul><h3 id="10-别重复自己"><a href="#10-别重复自己" class="headerlink" title="10.别重复自己"></a>10.别重复自己</h3><h3 id="11-结构化编程"><a href="#11-结构化编程" class="headerlink" title="11.结构化编程"></a>11.结构化编程</h3><h2 id="四、第四章-注释"><a href="#四、第四章-注释" class="headerlink" title="四、第四章 注释"></a>四、第四章 注释</h2><h3 id="1-如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。"><a href="#1-如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。" class="headerlink" title="1.如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。"></a>1.如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。</h3><h3 id="2-真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？"><a href="#2-真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？" class="headerlink" title="2.真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？"></a>2.真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？</h3><ul><li>法律信息</li><li>提供信息的注释</li><li>提供意图的解释</li><li>阐释</li><li>警告</li><li>TODO注释</li><li>TODO是一种程序要认为应该要做的，但是由于某种原因没有做的</li><li>放大,放大某些看似不合理的地方</li></ul><h2 id="五、第六章-对象和数据结构"><a href="#五、第六章-对象和数据结构" class="headerlink" title="五、第六章 对象和数据结构"></a>五、第六章 对象和数据结构</h2><h3 id="1-得墨忒定律"><a href="#1-得墨忒定律" class="headerlink" title="1.得墨忒定律"></a>1.得墨忒定律</h3><p>模块不应该了解他所操作对象的内部情形。对象隐藏数据曝露操作，这就意味着对象不应该通过存取器曝露其内部结构。</p><h2 id="六、第七章-错误处理"><a href="#六、第七章-错误处理" class="headerlink" title="六、第七章 错误处理"></a>六、第七章 错误处理</h2><h3 id="1-将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。"><a href="#1-将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。" class="headerlink" title="1.将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。"></a>1.将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。</h3><h3 id="2-异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。"><a href="#2-异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。" class="headerlink" title="2.异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。"></a>2.异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。</h3><h2 id="七、第八章-边界"><a href="#七、第八章-边界" class="headerlink" title="七、第八章 边界"></a>七、第八章 边界</h2><h3 id="1-整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。"><a href="#1-整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。" class="headerlink" title="1.整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。"></a>1.整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。</h3><h2 id="八、第九章-单元测试"><a href="#八、第九章-单元测试" class="headerlink" title="八、第九章 单元测试"></a>八、第九章 单元测试</h2><h3 id="1-TDD三定律"><a href="#1-TDD三定律" class="headerlink" title="1.TDD三定律"></a>1.TDD三定律</h3><ul><li>在编写不能通过的单元测试前，不可编写生产代码。</li><li>只可编写刚好无法通过的单元测试，不能编译也算不通过</li><li>只可编写刚好足以通过当前失败测试的生产代码</li></ul><h3 id="2-整洁测试三要素"><a href="#2-整洁测试三要素" class="headerlink" title="2.整洁测试三要素"></a>2.整洁测试三要素</h3><ul><li>可读性</li><li>可读性</li><li>可读性</li></ul><h3 id="3-整洁测试的五条原则："><a href="#3-整洁测试的五条原则：" class="headerlink" title="3.整洁测试的五条原则："></a>3.整洁测试的五条原则：</h3><ul><li>快速，测试应该够快</li><li>独立，测试应该相互独立</li><li>可重复，测试应当可在任何环境中重复通过。</li><li>自足验证，测试应该有布尔值输出，无论测试是成功还是失败，不应该人工通过log来确认测试是否成功或者失败。</li><li>及时，测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，你会发现生产代码难以测试。你可能会认为某些生产代码本身难以测试。你可能不会去设计可测试的代码。</li></ul><h2 id="九、第十章-类"><a href="#九、第十章-类" class="headerlink" title="九、第十章 类"></a>九、第十章 类</h2><h3 id="1-单一权责原则，类或者模块应有且只有一条加以修改的理由。"><a href="#1-单一权责原则，类或者模块应有且只有一条加以修改的理由。" class="headerlink" title="1.单一权责原则，类或者模块应有且只有一条加以修改的理由。"></a>1.单一权责原则，类或者模块应有且只有一条加以修改的理由。</h3><h3 id="2-内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。"><a href="#2-内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。" class="headerlink" title="2.内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。"></a>2.内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。</h3><h2 id="十、第十一章-系统"><a href="#十、第十一章-系统" class="headerlink" title="十、第十一章 系统"></a>十、第十一章 系统</h2><h3 id="1-将系统的构造与使用分开"><a href="#1-将系统的构造与使用分开" class="headerlink" title="1.将系统的构造与使用分开"></a>1.将系统的构造与使用分开</h3><p>软件系统应将起始过程和启始过程之后的运行时逻辑分离开，在起始过程中构建应用对象，也会存在相互缠结的依赖关系。（延迟初始化可以加快程序运行速度）</p><h4 id="1-1分解main"><a href="#1-1分解main" class="headerlink" title="1.1分解main"></a>1.1分解main</h4><p>将程序的构造放到main，并使其与运行时逻辑分开，main只管构造并将构造后的数据对象发送给各个应用，或者被各个应用使用。但是，不参与运行时的任何逻辑控制。</p><h4 id="1-2工厂模式"><a href="#1-2工厂模式" class="headerlink" title="1.2工厂模式"></a>1.2工厂模式</h4><p>使用该模式可以将系统构造和系统运行时逻辑分开。</p><h4 id="1-3依赖注入（需要强化理解）"><a href="#1-3依赖注入（需要强化理解）" class="headerlink" title="1.3依赖注入（需要强化理解）"></a>1.3依赖注入（需要强化理解）</h4><h4 id="1-4扩容"><a href="#1-4扩容" class="headerlink" title="1.4扩容"></a>1.4扩容</h4><p>“一开始就做对系统”纯属神话。反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统，实现新用户的故事。这就是迭代和增量敏捷的精髓所在。测试驱动开发，重构以及他们打造出的整洁的代码。</p><h4 id="1-5测试驱动系统架构"><a href="#1-5测试驱动系统架构" class="headerlink" title="1.5测试驱动系统架构"></a>1.5测试驱动系统架构</h4><p>最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯编程语言对象实现。不同的领域之间用最不具有侵害性的方面或类方面工具结合起来。这种架构就能测试驱动，就像代码一样。(需要关注面向切片编程(POJO))</p><h4 id="1-6优化决策"><a href="#1-6优化决策" class="headerlink" title="1.6优化决策"></a>1.6优化决策</h4><p>模块化和关注面切分成就了分散化管理和决策。在巨大的系统中，不管是一座城市或是一个软件项目，无人能做所有的决策。最好是授权给最有资格的人。拥有模块化关注面的POJO系统提供的敏捷能力，允许我们基于最新的知识做出优化的，时机刚好的决策。决策的复杂性降低了。</p><h2 id="十一、第十二章-迭进"><a href="#十一、第十二章-迭进" class="headerlink" title="十一、第十二章 迭进"></a>十一、第十二章 迭进</h2><h3 id="1-通过迭进设计达到代码整洁的目的："><a href="#1-通过迭进设计达到代码整洁的目的：" class="headerlink" title="1. 通过迭进设计达到代码整洁的目的："></a>1. 通过迭进设计达到代码整洁的目的：</h3><p>通过这几个原则可以让你的设计变简单（DIP，SRP）</p><ul><li>运行所有测试</li><li>不可重复，</li><li>表达了程序员的意图</li><li>尽可能减少类和方法的数量</li><li>以上规则按其重要程度排序</li></ul><h3 id="2-简单设计规则1-运行所有测试"><a href="#2-简单设计规则1-运行所有测试" class="headerlink" title="2. 简单设计规则1:运行所有测试"></a>2. 简单设计规则1:运行所有测试</h3><p>编写的测试越多就越能持续走向编写较易测试的代码，紧耦合的代码很难编写测试。遵循有关编写测试并持续运行测试的简单，明确的规则，系统就会更贴近OO低耦合度，高内聚度的目标。编写测试引致更好的设计。</p><h3 id="3-简单设计规则2-4：重构"><a href="#3-简单设计规则2-4：重构" class="headerlink" title="3. 简单设计规则2-4：重构"></a>3. 简单设计规则2-4：重构</h3><p>在重构过程中，可以应用有关优秀软件设计的一切知识。提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称，如此等等。这也是简单设计原则后三条规则的地方:消除重复，保证表达力，尽可能减少类和方法的数量。</p><h3 id="4-不可重复"><a href="#4-不可重复" class="headerlink" title="4. 不可重复"></a>4. 不可重复</h3><h3 id="5-表达力"><a href="#5-表达力" class="headerlink" title="5. 表达力"></a>5. 表达力</h3><h3 id="6-尽可能少的类和方法"><a href="#6-尽可能少的类和方法" class="headerlink" title="6. 尽可能少的类和方法"></a>6. 尽可能少的类和方法</h3><h2 id="十二、第十三章-并发编程"><a href="#十二、第十三章-并发编程" class="headerlink" title="十二、第十三章 并发编程"></a>十二、第十三章 并发编程</h2><h3 id="1-为什么要并发"><a href="#1-为什么要并发" class="headerlink" title="1. 为什么要并发"></a>1. 为什么要并发</h3><p>并发是一种解耦策略。它帮我们把做什么和何时做分解开。</p><h3 id="2-并发的防御原则"><a href="#2-并发的防御原则" class="headerlink" title="2. 并发的防御原则"></a>2. 并发的防御原则</h3><h3 id="13-1-单一权责原则（SRP）"><a href="#13-1-单一权责原则（SRP）" class="headerlink" title="13.1 单一权责原则（SRP）"></a>13.1 单一权责原则（SRP）</h3><p>并发代码应该从其他代码中分离出来，因为，并发代码相比于其他的代码是很复杂的存在。但是，并发实现细节常常直接嵌入到其他生产代码中。那么下面几个问题需要考虑，</p><ul><li>并发相关代码由自己的开发，修改和调优生命周期</li><li>开发相关代码由自己要对付的挑战，和非并发相关代码不同，而且往往更为困难</li><li>即便没有周边应用程序增加负担，写得不好的并发代码可能的出错方式数量已经足具挑战性。</li></ul><blockquote><p>建议：分离并发相关代码与其他代码。</p></blockquote><h3 id="13-2-限制数据作用域"><a href="#13-2-限制数据作用域" class="headerlink" title="13.2 限制数据作用域"></a>13.2 限制数据作用域</h3><p>两个线程修改共享对象的同一字段时，可能相互干扰，导致未预期的行为。解决方案之一是采用<code>synchronized</code>关键字在代码中保护一块使用共享对象的临界区。限制临界区的数量很重要。更新共享数据的地方越多，就越可能出错。</p><blockquote><p>建议：谨记数据封装，严格限制对可能被共享的数据的访问。</p></blockquote><h3 id="13-3-使用数据副本"><a href="#13-3-使用数据副本" class="headerlink" title="13.3 使用数据副本"></a>13.3 使用数据副本</h3><p>避免共享数据的好方法之一就是一开始就避免共享数据。在某些情况下，有可能复制对象并以只读方式对待。在另外一种情况下，有可能复制对象，从多个线程收集所有副本的结果，并在单个线程中合并这些结果。</p><h3 id="13-4-线程尽可能地独立"><a href="#13-4-线程尽可能地独立" class="headerlink" title="13.4　线程尽可能地独立"></a>13.4　线程尽可能地独立</h3><p>让每个线程在自己的世界中存在，不与其他线程共享数据。每个线程处理一个客户端请求，从不共享的源头接纳所有请求数据，存储为本地变量。</p><p>建议：尝试将数据分解到可被独立线程操作的独立子集。</p><h3 id="13-5-了解执行模型"><a href="#13-5-了解执行模型" class="headerlink" title="13.5 了解执行模型"></a>13.5 了解执行模型</h3><h4 id="13-5-1-生产者－－－消费者模型"><a href="#13-5-1-生产者－－－消费者模型" class="headerlink" title="13.5.1 生产者－－－消费者模型"></a>13.5.1 生产者－－－消费者模型</h4><p>一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。</p><h4 id="13-5-2-读者－－－作者模型"><a href="#13-5-2-读者－－－作者模型" class="headerlink" title="13.5.2 读者－－－作者模型"></a>13.5.2 读者－－－作者模型</h4><p>当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的积累。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的消息，这是一种辛苦的平衡工作。作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题。</p><p>挑战之处在于平衡读者线程和作者线程的需求，实现正确的操作，提供合理的吞吐量，避免线程饥饿。</p><h4 id="13-5-3哲学家问题（故事内容不在这里描述）"><a href="#13-5-3哲学家问题（故事内容不在这里描述）" class="headerlink" title="13.5.3哲学家问题（故事内容不在这里描述）"></a>13.5.3哲学家问题（故事内容不在这里描述）</h4><p>从哲学家问题可以反映出编写并发经常遇到的问题，死锁，活锁，吞吐量和效率降低等问题。那么学习这些基础问题的解决算法可以帮助你解决大多数的并发问题，因为大多的并发问题都是上述问题的变种。</p><h3 id="13-6-警惕同步方法之间的依赖"><a href="#13-6-警惕同步方法之间的依赖" class="headerlink" title="13.6 警惕同步方法之间的依赖"></a>13.6 警惕同步方法之间的依赖</h3><p>同步方法之间的依赖会导致并发代码中的狡猾缺陷。Java语言有synchronized概念，可以用来保护单个方法。然而，如果在同一共享类中由多个同步方法，系统就可能写得不太正确了。</p><blockquote><p>建议：避免使用一个共享对象的多个方法。如果有时必须使用一个共享对象的多个方法。这种情况发生时，有３中写对代码的手段：</p></blockquote><ul><li>基于客户端的锁定－－客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码。</li><li>基于服务端的锁定－－在服务端内创建锁定服务端的方法，调用所有方法，然后解锁。让客户端代码调用新的方法。</li><li>适配服务端－－创建执行锁定的中间层。这是一种基于服务端的锁定例子，但不修改原始服务端代码。</li></ul><h3 id="13-7保持同步区域微小"><a href="#13-7保持同步区域微小" class="headerlink" title="13.7保持同步区域微小"></a>13.7保持同步区域微小</h3><p>应该尽可能少地设计临界区，如果有请尽可能减小同步区域。</p><h3 id="13-8-编写线程需要注意的几点："><a href="#13-8-编写线程需要注意的几点：" class="headerlink" title="13.8　编写线程需要注意的几点："></a>13.8　编写线程需要注意的几点：</h3><h4 id="1-将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。"><a href="#1-将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。" class="headerlink" title="(1). 将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。"></a>(1). 将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。</h4><h4 id="2-先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。"><a href="#2-先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。" class="headerlink" title="(2). 先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。"></a>(2). 先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。</h4><h4 id="3-编写可插拔的线程代码。编写在数个环境下运行的线程代码"><a href="#3-编写可插拔的线程代码。编写在数个环境下运行的线程代码" class="headerlink" title="(3). 编写可插拔的线程代码。编写在数个环境下运行的线程代码"></a>(3). 编写可插拔的线程代码。编写在数个环境下运行的线程代码</h4><ul><li>1.单线程与多线程在执行时不同的情况</li><li>2.线程代码与实物或测试替身互动</li><li>3.用运行速度,缓慢和有变动的测试替身执行</li><li>4.将测试配置为能运行一定数量的迭代</li></ul><blockquote><p>建议：编写可插拔的线程代码，这样就能在不同的配置环境下运行。</p></blockquote><h4 id="4-编写可调整的线程代码"><a href="#4-编写可调整的线程代码" class="headerlink" title="(4). 编写可调整的线程代码"></a>(4). 编写可调整的线程代码</h4><p>在系统运行时允许线程发生变动。允许线程依据吞吐量和使用率自我调整。</p><h4 id="5-运行多余处理器数量的线程"><a href="#5-运行多余处理器数量的线程" class="headerlink" title="(5). 运行多余处理器数量的线程"></a>(5). 运行多余处理器数量的线程</h4><p>任务交换越频繁，越有可能找到错过临界区或导致死锁的代码。</p><h4 id="6-在不同平台上运行"><a href="#6-在不同平台上运行" class="headerlink" title="(6). 在不同平台上运行"></a>(6). 在不同平台上运行</h4><h4 id="7-调整代码并强迫错误发生"><a href="#7-调整代码并强迫错误发生" class="headerlink" title="(7). 调整代码并强迫错误发生"></a>(7). 调整代码并强迫错误发生</h4><h2 id="十三、第14章-逐步改进"><a href="#十三、第14章-逐步改进" class="headerlink" title="十三、第14章 逐步改进"></a>十三、第14章 逐步改进</h2><p>代码并不是一次就能写的很干净的，需要我们不断的迭代和优化。</p><h2 id="十四、第17章-味道与启发"><a href="#十四、第17章-味道与启发" class="headerlink" title="十四、第17章 味道与启发"></a>十四、第17章 味道与启发</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h3><h4 id="1-不恰当的注释信息"><a href="#1-不恰当的注释信息" class="headerlink" title="(1). 不恰当的注释信息"></a>(1). 不恰当的注释信息</h4><p>让注释传达本该更好地在源代码控制系统，问题追踪系统或任何其他记录系统中保存的信息，是不恰当的。例如，修改历史记录只会用大量过时而无趣的文本搞乱源代码文件。注释只应该描述有关代码和设计的技术性信息。</p><h4 id="2-废弃的注释"><a href="#2-废弃的注释" class="headerlink" title="(2). 废弃的注释"></a>(2). 废弃的注释</h4><p>过时，无关或不正确的注释就是废弃的注释。</p><h4 id="3-冗余注释"><a href="#3-冗余注释" class="headerlink" title="(3). 冗余注释"></a>(3). 冗余注释</h4><p>如果注释描述的是某种充分自我描述了的东西，那么注释就是多余的。注释应该谈及代码自身没有提到的东西。</p><h4 id="4-注释要写就要写最好的注释，别画蛇添足"><a href="#4-注释要写就要写最好的注释，别画蛇添足" class="headerlink" title="(4). 注释要写就要写最好的注释，别画蛇添足"></a>(4). 注释要写就要写最好的注释，别画蛇添足</h4><h4 id="5-注释掉的代码，看到注释掉的代码就删。"><a href="#5-注释掉的代码，看到注释掉的代码就删。" class="headerlink" title="(5). 注释掉的代码，看到注释掉的代码就删。"></a>(5). 注释掉的代码，看到注释掉的代码就删。</h4><h3 id="2-环境"><a href="#2-环境" class="headerlink" title="2. 环境"></a>2. 环境</h3><h4 id="1-需要多步才能实现的构建"><a href="#1-需要多步才能实现的构建" class="headerlink" title="(1). 需要多步才能实现的构建"></a>(1). 需要多步才能实现的构建</h4><p>构建系统应该是单步的小操作。不应该从源代码控制系统中一小点一小点签出代码。不应该需要一系列神秘指令或环境依赖脚本来构建单个元素。不应该四出寻找额外的小jar,xml文件和其他系统所需的杂物。你应该能够用单个命令签出系统，并单个指令构建它。</p><h4 id="2-需要多步才能做到测试"><a href="#2-需要多步才能做到测试" class="headerlink" title="(2). 需要多步才能做到测试"></a>(2). 需要多步才能做到测试</h4><p>你应该能够用单个指令就可以运行全部单元测试。能够运行全部测试是如此基础和重要，应该快速，轻易和直接了当地做到。</p><h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h3><ul><li>函数的参数应该少。</li><li>输出参数违反直觉。如果非要修改，那就修改函数所在对象好了。</li><li>标示参数，布尔值参数宣告函数做了不止一件事，应该消灭掉，即函数只做一件事。</li><li>永不被调用的方法应该丢弃。</li></ul><h3 id="4-一般性问题"><a href="#4-一般性问题" class="headerlink" title="4. 一般性问题"></a>4. 一般性问题</h3><p>(1). 如果代码需要有多种语言，那么应该尽力减少源文件中额外语言的数量和范围。</p><p>(2). 明显的行为未被实现，如果明显的行为未被实现，读者和用户就不能再依靠他们对函数名称的直觉。他们不再信任原作者，不得不阅读代码细节。</p><p>(3). 不正确的边界行为，追索每种边界条件，编写测试。</p><p>(4). 忽视安全</p><p>(5). 重复，尽可能找到并消除重复。</p><p>(6). 在错误的抽象层级上的代码，创建分离较高层级一般性概念与较低层级细节概念的抽象模型，这很重要。</p><p>(7). 基类不可多度依赖于派生类，基类应该对派生类一无所知。</p><p>(8). 信息过多，设计良好的模块有着非常小的接口，让你事半功倍。设计良好的接口并不提供许多需要依靠的函数，所以耦合度比较低。</p><p>优秀的软件开发人员学会限制类或模块中暴露的接口数量。类中的方法越少越好。函数知道的变量越少越好。类拥有的实体变量越少越好。隐藏你的数据。隐藏你的工具函数。隐藏你的常量和你的临时变量。不要创建拥有大量方法或大量实体变量的类。不要为子类创建大量受保护变量和函数。尽力保持接口紧凑。通过限制信息来控制耦合度。</p><p>(9). 死代码一定要删除。</p><p>(10). 垂直分隔，变量和函数应该在靠近被使用的地方定义。私有函数应该刚好在其首次被使用的位置下面定义。</p><p>(11). 前后不一致，从一而终即一旦选中，就小心持续遵循。如果在特定函数中用了response的变量来持有HttpServletResponse对象，则在其他用到HttpServletResponse对象的函数中也用同样的变量名。这样会让你的代码更易阅读。</p><p>(12). 混淆视听，没用的变量或者函数直接删掉，以免造成不必要的干扰。</p><p>(13). 人为耦合，不互相依赖的东西不该耦合。一般来说，人为耦合是指两个没有直接目的之间的模块的耦合。其根源是将变量，常量或函数不恰当地放在临时方便的位置。</p><p>(14). 特性依恋，类的方法只应对其所属类中的变量和函数感兴趣，不该垂青其他类中的变量和函数。当方法通过某个其他对象的访问器和修改器来操作该对象内部数据，则它就依恋于该对象所属类的范围。</p><p>(15). 选择算子参数，尽量不要把boolean作为函数参数</p><p>(16). 晦涩意图，代码要尽可能具有表达力。</p><p>(17). 位置错误的权责，我们可以采用最小惊异原则来帮助我们即代码应该放在读者自然而然期待它所在的地方。</p><p>(18). 不恰当的静态方法，对于没有机会打算让它有多态行为的函数可以作为动态函数，否则可选用静态函数。</p><p>(19). 使用解释性变量，命名要有意义。</p><p>(20). 函数名称应该表达其行为</p><p>(21). 理解算法</p><p>(22). 把逻辑依赖改为物理依赖：</p><ul><li>1.逻辑依赖：原始数据和业务逻辑之间的依赖关系。例如：定义的常量和业务逻辑存在着依赖关系或者说被捆绑在了一起，即当业务逻辑发生变化或者存在其他可能性的时候且定义的常量无法满足导致常量需要修改。</li><li>2.物理依赖：函数方法和业务逻辑之间的依赖关系。例如：为了解决逻辑依赖的问题，我们可以通过构造一个方法将数据和业务隔离。</li></ul><p>(23). 用多态替代<code>if/else</code> 或 <code>switch/case</code></p><p>(24). 遵循标准约定</p><p>(25). 用命名常量替代魔术数，魔术数不仅仅指的是数字，也泛指任何不能自我描述的符号。</p><p>(26). 准确，在可以用List的时候，非要把变量声明为ArrayList就过分拘束了。在代码中做决定时，确认自己足够准确。明确自己为何要这么做，如果遇到异常情况如何处理。别懒得理会决定的准确性。代码中的含糊和不准确性要么是意见不同的结果，要么源于懒惰。无论原因是什么，都要消除。</p><p>(27). 结构甚于约定，坚守结构甚于约定的设计决策。</p><p>(28). 封装条件，如果没有if或while语句的上下文，布尔逻辑就难以理解。应该把解释了条件意图的函数抽离出来。</p><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">shouldBeDeleted</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要好于</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">.</span><span class="token function">hasExpired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timer<span class="token punctuation">.</span><span class="token function">isRecurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(29). 避免否定性条件，尽可能将条件表示为肯定形式。</p><p>(30). 函数只该做一件事</p><p>(31). 掩蔽时序耦合，排列函数参数，好让它们被调用的次序显而易见。</p><p>(32). 别随意，构建代码需要理由，而且理由应于代码结构相契合。</p><p>(33). 封装边界条件，把处理边界条件的代码集中到一处，不要散落于代码中。</p><p>(34). 函数应该只在一个抽象层级上，函数中的语句应该在同意抽象级上，该层级应该是函数名所示操作的下一层。</p><p>(35). 在较高层级放置可配置数据，如果你有个已知并在较高抽象层级的默认常量或配置值，不要将它埋藏到较低层级的函数中。把它作为较高层级函数调用较低层级函数时的一个参数。位于较高层级的配置性常量易于修改。它们向下贯穿应用程序。应用程序的较低层级并不拥有这些常量的值。</p><p>(36). 避免传递浏览，编写害羞代码。</p><p>(37). 不要继承常量</p><h3 id="17-5-测试"><a href="#17-5-测试" class="headerlink" title="17.5 测试"></a>17.5 测试</h3><ol><li>使用覆盖率工具，覆盖率工具能汇报你测试策略中的缺口。使用测试覆盖率工具能更容易地找到不足的模块，类和函数。</li><li>别略过小测试</li><li>被忽略的测试就是对不确定事物的疑问。</li><li>测试边界条件</li><li>全面测试相近的缺陷，缺陷趋向于扎堆。</li><li>测试失败的模式有启发性。</li><li>测试覆盖率的模式有启发性，查看被或未被以通过的测试执行的代码，往往能发现失败的测试为何失败的线索。</li><li>测试应该快速。</li></ol><p>来自：<a href="http://www.uml.org.cn/codeNorms/201701162.asp">代码整洁之道内容概要</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整洁代码 </tag>
            
            <tag> 重构 </tag>
            
            <tag> 测试 </tag>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2022/04/01/zheng-ze-biao-da-shi/"/>
      <url>/2022/04/01/zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“\n”匹配\n。“\n”匹配换行符。序列“\”匹配“\”而“(”则匹配“(”。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次(大于等于0次)。例如，zo<em>能匹配“z”，“zo”以及“zoo”。</em>等价于{0,}。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</td></tr><tr><td>{n}</td><td>n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td></tr><tr><td>{n,}</td><td>n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td></tr><tr><td>{n,m}</td><td>m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td>?</td><td>当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</td></tr><tr><td>.点</td><td>匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。</td></tr><tr><td>(pattern)</td><td>匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“”或“”或“ ”或“ ”。</td></tr><tr><td>(?:pattern)</td><td>匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。</td></tr><tr><td>(?=pattern)</td><td>正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?!pattern)</td><td>正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。</td></tr><tr><td>(?&lt;=pattern)</td><td>反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</td></tr><tr><td>(?&lt;!pattern)</td><td>反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。</td></tr><tr><td>x|y</td><td>匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。</td></tr><tr><td>[xyz]</td><td>字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</td></tr><tr><td>[^xyz]</td><td>负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。          注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.</td></tr><tr><td>[^a-z]</td><td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td></tr><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</td></tr><tr><td>\B</td><td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</td></tr><tr><td>\cx</td><td>匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于[0-9]。</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于[^0-9]。</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于\x0c和\cL。</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于\x0a和\cJ。</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于\x0d和\cM。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于\x09和\cI。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于\x0b和\cK。</td></tr><tr><td>\w</td><td>匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。</td></tr><tr><td>\W</td><td>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</td></tr><tr><td>\xn</td><td>匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。</td></tr><tr><td>\num</td><td>匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。</td></tr><tr><td>\n</td><td>标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。</td></tr><tr><td>\nm</td><td>标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。</td></tr><tr><td>\nml</td><td>如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。</td></tr><tr><td>\un</td><td>匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。</td></tr><tr><td>&lt; &gt;</td><td>匹配词（word）的开始（&lt;）和结束（&gt;）。例如正则表达式&lt;the&gt;能够匹配字符串”for the wise”中的”the”，但是不能匹配字符串”otherwise”中的”the”。注意：这个元字符不是所有的软件都支持的。</td></tr><tr><td></td><td>将 和和 和  之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \1 到\9 的符号来引用。</td></tr><tr><td>|</td><td>将两个匹配条件进行逻辑“或”（Or）运算。例如正则表达式(him|her) 匹配”it belongs to him”和”it belongs to her”，但是不能匹配”it belongs to them.”。注意：这个元字符不是所有的软件都支持的。</td></tr><tr><td>+</td><td>匹配1或多个正好在它之前的那个字符。例如正则表达式9+匹配9、99、999等。注意：这个元字符不是所有的软件都支持的。</td></tr><tr><td>?</td><td>匹配0或1个正好在它之前的那个字符。注意：这个元字符不是所有的软件都支持的。</td></tr><tr><td>{i} {i,j}</td><td>匹配指定数目的字符，这些字符是在它之前的表达式定义的。例如正则表达式A[0-9]{3} 能够匹配字符”A”后面跟着正好3个数字字符的串，例如A123、A348等，但是不匹配A1234。而正则表达式[0-9]{4,6} 匹配连续的任意4个、5个或者6个数字</td></tr></tbody></table><h3 id="等价字符："><a href="#等价字符：" class="headerlink" title="等价字符："></a>等价字符：</h3><p> ?,*,+,\d,\w 都是等价字符</p><ul><li> ？ 等价于匹配长度{0,1}</li><li> *   等价于匹配长度{0,} </li><li> +   等价于匹配长度{1,}</li><li> \d 等价于[0-9]</li><li> \w 等价于[A-Za-z_0-9]</li></ul><h3 id="常用运算符与表达式："><a href="#常用运算符与表达式：" class="headerlink" title="常用运算符与表达式："></a>常用运算符与表达式：</h3><ul><li> ^ 开始</li><li> () 域段</li><li> [] 包含,默认是一个字符长度</li><li> [^] 不包含,默认是一个字符长度</li><li> {n,m} 匹配长度 </li><li> . 任何单个字符(. 字符点)</li><li> | 或</li><li> \ 转义</li><li> $ 结尾</li><li> [A-Z] 26个大写字母</li><li> [a-z] 26个小写字母</li><li> [0-9] 0至9数字</li><li> [A-Za-z0-9] 26个大写字母、26个小写字母和0至9数字</li></ul><h3 id="分割语法："><a href="#分割语法：" class="headerlink" title="分割语法："></a>分割语法：</h3><ul><li> [A,H,T,W] 包含A或H或T或W字母</li><li> [a,h,t,w] 包含a或h或t或w字母</li><li> [0,3,6,8] 包含0或3或6或8数字</li></ul><h3 id="语法与释义："><a href="#语法与释义：" class="headerlink" title="语法与释义："></a>语法与释义：</h3><ul><li> 基础语法 “^([]{})([]{})([]{})$”</li><li> 正则字符串 = “开始（[包含内容]{长度}）（[包含内容]{长度}）（[包含内容]{长度}）结束” </li><li> ?,,+,\d,\w 这些都是简写的,完全可以用[]和{}代替，在(?:)(?=)(?!)(?&lt;=)(?&lt;!)(?i)(?)(+?)这种特殊组合情况下除外。</li></ul><h3 id="简写实例："><a href="#简写实例：" class="headerlink" title="简写实例："></a>简写实例：</h3><ul><li><p> 字符串；tel:086-0666-88810009999</p></li><li><p> 原始正则：”^tel:[0-9]{1,3}-[0][0-9]{2,3}-[0-9]{8,11}$” </p></li><li><p> 速记理解：开始 “tel:普通文本”[0-9数字]{1至3位}”-普通文本”[0数字][0-9数字]{2至3位}”-普通文本”[0-9数字]{8至11位} 结束”</p></li><li><p> 等价简写后正则写法：”^tel:\d{1,3}-[0]\d{2,3}-\d{8,11}$” ，简写语法不是所有语言都支持。</p></li></ul><h3 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h3><ol><li> 验证用户名和密码：（”^[a-zA-Z]\w{5,15}$”）正确格式：”[A-Z][a-z]_[0-9]”组成,并且第一个字必须为字母6~16位； </li><li> 验证电话号码：（”^(\d{3,4}-)\d{7,8}$”）正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx； </li><li> 验证手机号码：”^1[3|4|5|7|8][0-9]\d{8}$”； </li><li> 验证身份证号（15位或18位数字）：”\d{14}[[0-9],0-9xX]”； </li><li> 验证Email地址：(“^\w+([-+.]\w+)*@\w+([-.]\w+)<em>.\w+([-.]\w+)</em>$”)； </li><li> 只能输入由数字和26个英文字母组成的字符串：(“^[A-Za-z0-9]+$”) ; </li><li> 整数或者小数：^[0-9]+([.]{0,1}[0-9]+){0,1}$ </li><li> 只能输入数字：”^[0-9]*$”。 </li><li> 只能输入n位的数字：”^\d{n}$”。 </li><li> 只能输入至少n位的数字：”^\d{n,}$”。 </li><li> 只能输入m~n位的数字：”^\d{m,n}$”。 </li><li> 只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$”。 </li><li> 只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$”。 </li><li> 只能输入有1~3位小数的正实数：”^[0-9]+(.[0-9]{1,3})?$”。 </li><li> 只能输入非零的正整数：”^+?[1-9][0-9]*$”。 </li><li> 只能输入非零的负整数：”^-[1-9][]0-9”*$。 </li><li> 只能输入长度为3的字符：”^.{3}$”。 </li><li> 只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。 </li><li> 只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。 </li><li> 只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。 </li><li> 验证是否含有^%&amp;’,;=?$"等字符：”[^%&amp;’,;=?$\x22]+”。 </li><li> 只能输入汉字：”^[\u4e00-\u9fa5]{0,}$”。 </li><li> 验证URL：”^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$”。 </li><li> 验证一年的12个月：”^(0?[1-9]|1[0-2])$” 正确格为：”01”～”09”和”10”～”12”。 </li><li> 验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为；”01”～”09”、”10”～”29”和“30”~“31”。 </li><li> 获取日期正则表达式：\d{4}[年|-|.]\d{\1-\12}[月|-|.]\d{\1-\31}日?  可用来匹配大多数年月日信息。 </li><li> 匹配双字节字符(包括汉字在内)：[^\x00-\xff]  评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） </li><li> 匹配空白行的正则表达式：\n\s*\r  评注：可以用来删除空白行 </li><li> 匹配HTML标记的正则表达式：&lt;(\S*?)[^&gt;]<em>&gt;.</em>?&lt;/&gt;|&lt;.*? /&gt;  评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 </li><li> 匹配首尾空白字符的正则表达式：^\s*|\s*$  评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 </li><li> 匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*  评注：网上流传的版本功能很有限，上面这个基本可以满足需求 </li><li> 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$  评注：表单验证时很实用 </li><li> 匹配腾讯QQ号：[1-9][0-9]{4,}   评注：腾讯QQ号从10 000 开始 </li><li> 匹配中国邮政编码：[1-9]\d{5}(?!\d)   评注：中国邮政编码为6位数字 </li><li> 匹配ip地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序内存概念</title>
      <link href="/2022/04/01/cheng-xu-nei-cun-gai-nian/"/>
      <url>/2022/04/01/cheng-xu-nei-cun-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="程序内存概念"><a href="#程序内存概念" class="headerlink" title="程序内存概念"></a>程序内存概念</h1><p><strong>一 预备知识</strong></p><p>​        在区分一个程序的<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E6%A0%88&amp;spm=1001.2101.3001.7020">堆栈</a>、bss、text段、RO、RW、ZI等概念时，首先区分一下程序进程和程序文件，然后了解一下哈弗结构和冯诺依曼结构。</p><p>​        程序进程就是程序运行时的程序，程序文件是编译后生成的可执行程序，比如.bin文件等，这两个概念很好区分，特别强调一下，分开表达主要是怕读者在阅读过程中混淆了。</p><p>​        哈佛结构和冯诺依曼结构的主要区别就是处理器能不能实现取指令和取数据的并发进行。嵌入式芯片中主要是哈佛结构，PC机上是冯诺依曼结构。</p><p><strong>经典的哈佛结构</strong><br>        程序存储器和数据存储器是各自独立的存储器。处理器应该有两套总线，一套是程序存储器的数据和地址总线，一套是数据存储器的数据和地址总线。取指令和取数据能并发进行。51的程序进程的逻辑代码段放在ROM中，而变量部分则放在RAM中，取ROM中的指令和RAM中的变量是两套总线。</p><p><strong>改进型哈佛结构</strong><br>        程序存储器和数据存储器是各自独立的存储器。处理器只有一套总线，分时访问程序存储器和数据存储器，但是在处理器中有icache和dcache将程序和数据分开，所以处理器仍然可以并步执行取指令和取数据。从ARM9开始以后所有的ARM处理器内核都是改进型的哈佛结构。ARM的逻辑代码和变量都是存放在RAM中的，但是，它在内存中划分了两部分的空间，其中一部分放逻辑代码，另一部分存放变量，之间不会相互干扰。</p><p><strong>冯诺依曼结构</strong>：<br>        没有程序存储空间和数据存储空间之分。处理器只有一套总线，取指令和取数据是不能同时进行的。程序进程全部在RAM中，他们之间一般是按照代码的执行顺序依次存储。由于全部在RAM中，运行速度快，所需的RAM多。</p><p><strong>二 程序文件中的分区</strong></p><p>备注：只针对嵌入式，pc程序文件没有探究过。小标题“程序文件中的分区”其实不是很恰当，不知道该如何形容，此部分概念通常出现在一个程序编译完成后的大小统计，请自行理解。</p><p>​    相关概念：Code，RO_data，RW_data，ZI_data，RO，RW，常出现在嵌入式程序编译完成后的统计，例如MDK，IAR，ARM GCC。</p><p>有些技术文章中会直接使用RO，请注意区分RO和RO-data的区别。 </p><p><strong>Code</strong>：即代码域，它指的是编译器生成的机器指令。<br><strong>RO_data</strong>：ReadOnly data，即只读数据域，它指程序中用到的只读数据，全局变量，例如C语言中const关键字定义的全局变量就是典型的RO-data。<br><strong>RW_data</strong>：ReadWrite data，即可读写数据域，它指初始化为“非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。例如全局变量或者静态变量，且定义时赋予“非0值”给该变量进行初始化。<br><strong>ZI_data</strong>：ZeroInitialie data，即0初始化数据，它指初始化为“0值”的可读写数据域，它与RW_data的区别是程序刚运行时这些数据初始值全都为0，而后续运行过程与RW-data的性质一样，它们也常驻在RAM区，因而应用程序可以更改其内容。包括未初始化的全局变量，和初始化为0的全局变量。<br><strong>RO</strong>：只读区域，包括RO_data和code。 </p><p>当程序存储在ROM中时，所占用的大小为Code + RO_data + RW_data 。<br>当程序执行时， RW_data和 ZI_data在RAM中，RO_data和code视cpu架构（51、arm、x86）不同处于ROM或者RAM中。其中ZI_data对应了BSS段，RW_data对应数据段，code对应代码段， RO_data对应数据段。</p><p><strong>三 程序进程中的分区</strong></p><p> <strong>三 程序进程中的分区</strong>：</p><p>相关概念：堆(heap)，栈(stack)，BSS段，数据段(data)，代码段( code /text)，全局静态区，文字常量区，程序代码区。<br> <strong>BSS段</strong>：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。<br> <strong>数据段</strong>：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。<br> <strong>代码段</strong>：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。<br> <strong>堆（heap）</strong>：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。<br> **栈(stack)**：栈又称堆栈，用户存放程序临时创建的局部变量。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场。</p><p> 全局静态区，文字常量区，程序代码区是从内存地址分配的角度来描述的。<br><strong>全局区（静态区）（static）</strong>—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。</p><p><strong>文字常量区</strong>—常量字符串就是放在这里的。<br><strong>程序代码区</strong>—存放函数体的二进制代码。</p><p><img src="/2022/04/01/cheng-xu-nei-cun-gai-nian/code_ram.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> RAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my first blog</title>
      <link href="/2021/10/27/my-first-blog/"/>
      <url>/2021/10/27/my-first-blog/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>quick start</title>
      <link href="/2021/10/24/hello-world/"/>
      <url>/2021/10/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
